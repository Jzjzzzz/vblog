/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 50732
 Source Host           : localhost:3306
 Source Schema         : vblog

 Target Server Type    : MySQL
 Target Server Version : 50732
 File Encoding         : 65001

 Date: 09/10/2022 17:30:20
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for admin_user
-- ----------------------------
DROP TABLE IF EXISTS `admin_user`;
CREATE TABLE `admin_user`  (
  `id` bigint(11) UNSIGNED ZEROFILL NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `phone` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `avatar` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `create_time` datetime NOT NULL,
  `update_time` datetime NOT NULL,
  `roles` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `introduction` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '管理员用户表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of admin_user
-- ----------------------------
INSERT INTO `admin_user` VALUES (00000000001, 'admin', '9bda42f78a579ca9e9397936c9558338', '18176702572', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/adminAvatar/2022/08/19/80b086d23aac408c95517bd5ebc4eea3.jpg', '2022-06-07 15:06:24', '2022-09-05 16:42:14', 'admin', 'I am a super administrator');

-- ----------------------------
-- Table structure for article_comment
-- ----------------------------
DROP TABLE IF EXISTS `article_comment`;
CREATE TABLE `article_comment`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `nick_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `content` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '内容',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `status` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '状态',
  `parent_status` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否为父节点',
  `article_id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章id',
  `comment_type` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论类型(0-留言板,1-文章评论)',
  `parent_id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '父节点id',
  `avatar` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `ip` varchar(15) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论ip地址',
  `city` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '所属省市',
  `audit_status` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '审核状态(0-未审核,1-审核通过,2-审核未通过)',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '留言板' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_comment
-- ----------------------------

-- ----------------------------
-- Table structure for article_content
-- ----------------------------
DROP TABLE IF EXISTS `article_content`;
CREATE TABLE `article_content`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章内容id',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '文章内容',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `html_content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '文章内容转html',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章内容' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_content
-- ----------------------------
INSERT INTO `article_content` VALUES ('0ae360525f681ccd6c35c0cda7bc87c2', '# 一、开通“对象存储OSS”服务\n为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。 \n## 1、开通“对象存储OSS”服务\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png)\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png)\n## 2、进入管理控制台\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png)\n# 二、控制台使用\n## 1、创建Bucket\n命名：vblog-file\n读写权限：公共读\n## 2、上传默认头像\n创建文件夹avatar，上传默认的用户头像\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png)\n三、使用RAM子用户\n## 三、使用RAM子用户\n## 1、进入子用户管理页面\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png)\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png)\n## 2、添加用户\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png)\n## 3、获取子用户key\nAccessKeyId, AccessKeySecret\n\n## 4、设置用户权限\nAliyunOSSFullAccess\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png)\n', '2022-09-26 10:01:37', '2022-09-26 14:54:23', '<h1><a id=\"OSS_0\"></a>一、开通“对象存储OSS”服务</h1>\n<p>为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。</p>\n<h2><a id=\"1OSS_2\"></a>1、开通“对象存储OSS”服务</h2>\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png\" alt=\"image.png\" /><br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png\" alt=\"image.png\" /></p>\n<h2><a id=\"2_5\"></a>2、进入管理控制台</h2>\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png\" alt=\"image.png\" /></p>\n<h1><a id=\"_7\"></a>二、控制台使用</h1>\n<h2><a id=\"1Bucket_8\"></a>1、创建Bucket</h2>\n<p>命名：vblog-file<br />\n读写权限：公共读</p>\n<h2><a id=\"2_11\"></a>2、上传默认头像</h2>\n<p>创建文件夹avatar，上传默认的用户头像<br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png\" alt=\"image.png\" /><br />\n三、使用RAM子用户</p>\n<h2><a id=\"RAM_15\"></a>三、使用RAM子用户</h2>\n<h2><a id=\"1_16\"></a>1、进入子用户管理页面</h2>\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png\" alt=\"image.png\" /><br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png\" alt=\"image.png\" /></p>\n<h2><a id=\"2_19\"></a>2、添加用户</h2>\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png\" alt=\"image.png\" /></p>\n<h2><a id=\"3key_21\"></a>3、获取子用户key</h2>\n<p>AccessKeyId, AccessKeySecret</p>\n<h2><a id=\"4_24\"></a>4、设置用户权限</h2>\n<p>AliyunOSSFullAccess<br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png\" alt=\"image.png\" /></p>\n');
INSERT INTO `article_content` VALUES ('320ab09bf4402f0abb812e8530e217ea', '### 1.在腾讯云短信服务上新建短信签名\n[https://console.cloud.tencent.com/smsv2/guide](https://console.cloud.tencent.com/smsv2/guide)\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a3b11520c7ed4b298d21c4dd5979d19c.png)\n### 2.新建短信模板\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/7feac028c2944636b246bc0a5eaf114a.png)\n### 3.获取腾讯云的API秘钥\n[https://console.cloud.tencent.com/cam/capi](https://console.cloud.tencent.com/cam/capi)\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d8fbecd8be214a94bab3c53c73b47d30.png)\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/98f0e0e797d940ea814f1516061ed5eb.png)\n### 4.开发指南\n[https://cloud.tencent.com/document/product/382/38778](https://cloud.tencent.com/document/product/382/38778)\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/593d6ff8b053478da6e65d2c71066709.png)\n可通过改控制台实时调试\n### 5.新建SMS微服务service-sms\n\n- POM\n```java\n    <dependencies>\n\n        <dependency>\n            <groupId>com.jzj</groupId>\n            <artifactId>service-base</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--lombok用来简化实体类：需要安装lombok插件-->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n        <!--腾讯云短信-->\n        <dependency>\n            <groupId>com.tencentcloudapi</groupId>\n            <artifactId>tencentcloud-sdk-java-common</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.tencentcloudapi</groupId>\n            <artifactId>tencentcloud-sdk-java</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.tencentcloudapi</groupId>\n            <artifactId>tencentcloud-sdk-java-sms</artifactId>\n        </dependency>\n        <!--  配置文件处理器  -->\n        <!--让自定义的配置在application.yaml进行自动提示-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n\n```\n\n- YML\n```java\nserver:\n  port: 8120 # 服务端口\n\nspring:\n  profiles:\n    active: dev # 环境设置\n  application:\n    name: service-sms # 服务名\n  #spring:\n  redis:\n    host: 192.168.1.113\n    port: 6379\n    database: 0\n    password:  #默认为空\n    timeout: 3000ms #最大等待时间，超时则抛出异常，否则请求一直等待\n    lettuce:\n      pool:\n        max-active: 20  #最大连接数，负值表示没有限制，默认8\n        max-wait: -1    #最大阻塞等待时间，负值表示没限制，默认-1\n        max-idle: 8     #最大空闲连接，默认8\n        min-idle: 0     #最小空闲连接，默认0\n\n#腾讯云短信\ntengxun:\n  sms:\n    secretId: 你的secretId\n    secretKey: 你的secretKey\n    #短信应用 ID\n    appid: 你的appid\n    #短信签名内容\n    sign: 你的sign\n    #短信模板ID\n    templateID: 你的templateID\n\n```\n\n- 启动类\n```java\npackage com.jzj.srb.sms;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n@ComponentScan({\"com.jzj.srb\", \"com.jzj.common\"})\npublic class ServiceSmsApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceSmsApplication.class,args);\n    }\n}\n```\n\n- 工具类\n```java\npackage com.jzj.srb.sms.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\n@Getter  //idea2020.2.3版配置文件自动提示需要这个\n@Setter\n@Component\n//注意prefix要写到最后一个 \".\" 符号之前\n//调用setter为成员赋值\n@ConfigurationProperties(prefix = \"tengxun.sms\")\npublic class TengXunSmsProperties implements InitializingBean {\n    private String secretId;\n    private String secretKey;\n    private String appid;\n    private String sign;\n    private String templateID;\n    public static String SECRET_ID;\n    public static String SECRET_KEY;\n    public static String APP_ID;\n    public static String SIGN;\n    public static String TEMPLATE_ID;\n    //当私有成员被赋值后，此方法自动被调用，从而初始化常量\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        SECRET_ID=secretId;\n        SECRET_KEY=secretKey;\n        APP_ID=appid;\n        SIGN=sign;\n        TEMPLATE_ID=templateID;\n    }\n\n}\n```\n\n- service\n```java\npackage com.jzj.srb.sms.service;\n\npublic interface TengXunSmsService {\n    void send(String mobile, String code);\n}\n\n```\n\n- service实现类\n```java\npackage com.jzj.srb.sms.service.impl;\n\nimport com.jzj.common.exception.Assert;\nimport com.jzj.common.exception.BusinessException;\nimport com.jzj.common.result.ResponseEnum;\nimport com.jzj.srb.sms.service.TengXunSmsService;\nimport com.jzj.srb.sms.util.TengXunSmsProperties;\nimport com.tencentcloudapi.common.Credential;\nimport com.tencentcloudapi.common.exception.TencentCloudSDKException;\nimport com.tencentcloudapi.common.profile.ClientProfile;\nimport com.tencentcloudapi.sms.v20190711.SmsClient;\nimport com.tencentcloudapi.sms.v20190711.models.SendSmsRequest;\nimport com.tencentcloudapi.sms.v20190711.models.SendSmsResponse;\nimport com.tencentcloudapi.sms.v20190711.models.SendStatus;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\n@Service\n@Slf4j\npublic class TengXunSmsServiceImpl implements TengXunSmsService {\n    @Override\n    public void send(String mobile,String code) {\n        String jointMobile=\"+86\"+mobile;\n        String secretId = TengXunSmsProperties.SECRET_ID;\n        String secretKey= TengXunSmsProperties.SECRET_KEY;\n        //短信应用 ID\n        String appid = TengXunSmsProperties.APP_ID;\n        //短信签名内容\n        String sign = TengXunSmsProperties.SIGN;\n        //短信模板 ID\n        String templateID = TengXunSmsProperties.TEMPLATE_ID;\n        //+86为国家码，182********为手机号，最多不要超过200个手机号\n\n        String[] phoneNumbers = { jointMobile};\n        //模板参数: 若无模板参数，则设置为空\n        String[] templateParams = { code };//对应模板中{1}\n        try {\n            //必要步骤： 实例化一个认证对象，入参需要传入腾讯云账户密钥对 secretId 和 secretKey\n            Credential cred = new Credential(secretId , secretKey);\n\n            ClientProfile clientProfile = new ClientProfile();\n            //SDK 默认用 TC3-HMAC-SHA256 进行签名 非必要请不要修改该字段\n            clientProfile.setSignMethod(\"HmacSHA256\");\n            // 实例化 SMS 的 client 对象 第二个参数是地域信息，可以直接填写字符串 ap-guangzhou，或者引用预设的常量\n            SmsClient client = new SmsClient(cred, \"\", clientProfile);\n            //实例化一个请求对象，根据调用的接口和实际情况，可以进一步设置请求参数 您可以直接查询 SDK 源码确定接口有哪些属性可以设置\n            SendSmsRequest req = new SendSmsRequest();\n\n            // 短信应用 ID: 在 [短信控制台] 添加应用后生成的实际 SDKAppID，例如1400006666\n            req.setSmsSdkAppid(appid);\n\n            // 短信签名内容: 使用 UTF-8 编码，必须填写已审核通过的签名，可登录 [短信控制台] 查看签名信息\n            req.setSign(sign);\n\n            //短信模板 ID: 必须填写已审核通过的模板 ID，可登录 [短信控制台] 查看模板 ID\n            req.setTemplateID(templateID);\n\n            //下发手机号码，采用 e.164 标准，+[国家或地区码][手机号] 例如+8613711112222\n            req.setPhoneNumberSet(phoneNumbers);\n\n            req.setTemplateParamSet(templateParams);\n\n            // 通过 client 对象调用 SendSms 方法发起请求。注意请求方法名与请求对象是对应的 返回的 res 是一个SendSmsResponse 类的实例，与请求对象对应\n            SendSmsResponse res = client.SendSms(req);\n            //获取响应结果\n            SendStatus[] sendStatusSet = res.getSendStatusSet();\n            log.info(\"短信发送返回的响应：\"+sendStatusSet);\n            Assert.notEquals(\"LimitExceeded.PhoneNumberThirtySecondLimit\",sendStatusSet[0].getCode(),ResponseEnum.TENGXUN_SMS_LIMIT_CONTROL_ERROR);\n            Assert.equals(\"Ok\",sendStatusSet[0].getCode(),ResponseEnum.TENGXUN_SMS_ERROR);\n\n        } catch (TencentCloudSDKException e) {\n            log.error(\"腾讯云短信发送sdk调用失败：\"+e.getErrorCode()+\",\"+e.getMessage());\n            throw new BusinessException(ResponseEnum.TENGXUN_SMS_ERROR,e);\n        }\n    }\n}\n\n```\n\n- controller\n```java\npackage com.jzj.srb.sms.controller.api;\n\nimport com.jzj.common.exception.Assert;\nimport com.jzj.common.result.R;\nimport com.jzj.common.result.ResponseEnum;\nimport com.jzj.common.util.RandomUtils;\nimport com.jzj.common.util.RegexValidateUtils;\nimport com.jzj.srb.sms.service.TengXunSmsService;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.annotation.Resource;\nimport java.util.concurrent.TimeUnit;\n\n@CrossOrigin //跨域\n@RestController\n@RequestMapping(\"/api/sms\")\n@Api(tags = \"短信管理\")\n@Slf4j\npublic class ApiSmsController {\n\n    @Resource\n    private TengXunSmsService tengXunSmsService;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @ApiOperation(\"获取验证码\")\n    @GetMapping(\"/send/{mobile}\")\n    public R send(@PathVariable String mobile){\n        //手机号码不能为空\n        Assert.notEmpty(mobile, ResponseEnum.MOBILE_NULL_ERROR);\n        //是否是合法的手机号码\n        Assert.isTrue(RegexValidateUtils.checkCellphone(mobile),ResponseEnum.MOBILE_ERROR);\n        String code=RandomUtils.getFourBitRandom();\n        tengXunSmsService.send(mobile,code);\n        //将验证码存入redis中\n        redisTemplate.opsForValue().set(\"srb:sms:code:\"+mobile,code,5, TimeUnit.MINUTES);\n        return R.ok().message(\"短信发送成功\");\n    }\n}\n\n```\n', '2022-09-26 14:58:03', '2022-09-26 14:58:03', '<h3><a id=\"1_0\"></a>1.在腾讯云短信服务上新建短信签名</h3>\n<p><a href=\"https://console.cloud.tencent.com/smsv2/guide\" target=\"_blank\">https://console.cloud.tencent.com/smsv2/guide</a><br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a3b11520c7ed4b298d21c4dd5979d19c.png\" alt=\"image.png\" /></p>\n<h3><a id=\"2_3\"></a>2.新建短信模板</h3>\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/7feac028c2944636b246bc0a5eaf114a.png\" alt=\"image.png\" /></p>\n<h3><a id=\"3API_5\"></a>3.获取腾讯云的API秘钥</h3>\n<p><a href=\"https://console.cloud.tencent.com/cam/capi\" target=\"_blank\">https://console.cloud.tencent.com/cam/capi</a><br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d8fbecd8be214a94bab3c53c73b47d30.png\" alt=\"image.png\" /><br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/98f0e0e797d940ea814f1516061ed5eb.png\" alt=\"image.png\" /></p>\n<h3><a id=\"4_9\"></a>4.开发指南</h3>\n<p><a href=\"https://cloud.tencent.com/document/product/382/38778\" target=\"_blank\">https://cloud.tencent.com/document/product/382/38778</a><br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/593d6ff8b053478da6e65d2c71066709.png\" alt=\"image.png\" /><br />\n可通过改控制台实时调试</p>\n<h3><a id=\"5SMSservicesms_13\"></a>5.新建SMS微服务service-sms</h3>\n<ul>\n<li>POM</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\">    &lt;dependencies&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.jzj&lt;/groupId&gt;\n            &lt;artifactId&gt;service-base&lt;/artifactId&gt;\n            &lt;version&gt;${project.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--腾讯云短信--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.tencentcloudapi&lt;/groupId&gt;\n            &lt;artifactId&gt;tencentcloud-sdk-java-common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.tencentcloudapi&lt;/groupId&gt;\n            &lt;artifactId&gt;tencentcloud-sdk-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.tencentcloudapi&lt;/groupId&gt;\n            &lt;artifactId&gt;tencentcloud-sdk-java-sms&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--  配置文件处理器  --&gt;\n        &lt;!--让自定义的配置在application.yaml进行自动提示--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n            &lt;optional&gt;<span class=\"hljs-literal\">true</span>&lt;/optional&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n</code></div></pre>\n<ul>\n<li>YML</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\">server:\n  port: <span class=\"hljs-number\">8120</span> # 服务端口\n\nspring:\n  profiles:\n    active: dev # 环境设置\n  application:\n    name: service-sms # 服务名\n  #spring:\n  redis:\n    host: <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.113</span>\n    port: <span class=\"hljs-number\">6379</span>\n    database: <span class=\"hljs-number\">0</span>\n    password:  #默认为空\n    timeout: 3000ms #最大等待时间，超时则抛出异常，否则请求一直等待\n    lettuce:\n      pool:\n        max-active: <span class=\"hljs-number\">20</span>  #最大连接数，负值表示没有限制，默认<span class=\"hljs-number\">8</span>\n        max-wait: -<span class=\"hljs-number\">1</span>    #最大阻塞等待时间，负值表示没限制，默认-<span class=\"hljs-number\">1</span>\n        max-idle: <span class=\"hljs-number\">8</span>     #最大空闲连接，默认<span class=\"hljs-number\">8</span>\n        min-idle: <span class=\"hljs-number\">0</span>     #最小空闲连接，默认<span class=\"hljs-number\">0</span>\n\n#腾讯云短信\ntengxun:\n  sms:\n    secretId: 你的secretId\n    secretKey: 你的secretKey\n    #短信应用 ID\n    appid: 你的appid\n    #短信签名内容\n    sign: 你的sign\n    #短信模板ID\n    templateID: 你的templateID\n\n</code></div></pre>\n<ul>\n<li>启动类</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.jzj.srb.sms;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.ComponentScan;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@ComponentScan({&quot;com.jzj.srb&quot;, &quot;com.jzj.common&quot;})</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServiceSmsApplication</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        SpringApplication.run(ServiceSmsApplication.class,args);\n    }\n}\n</code></div></pre>\n<ul>\n<li>工具类</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.jzj.srb.sms.util;\n\n<span class=\"hljs-keyword\">import</span> lombok.Getter;\n<span class=\"hljs-keyword\">import</span> lombok.Setter;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.InitializingBean;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-meta\">@Getter</span>  <span class=\"hljs-comment\">//idea2020.2.3版配置文件自动提示需要这个</span>\n<span class=\"hljs-meta\">@Setter</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-comment\">//注意prefix要写到最后一个 &quot;.&quot; 符号之前</span>\n<span class=\"hljs-comment\">//调用setter为成员赋值</span>\n<span class=\"hljs-meta\">@ConfigurationProperties(prefix = &quot;tengxun.sms&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TengXunSmsProperties</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">InitializingBean</span> {\n    <span class=\"hljs-keyword\">private</span> String secretId;\n    <span class=\"hljs-keyword\">private</span> String secretKey;\n    <span class=\"hljs-keyword\">private</span> String appid;\n    <span class=\"hljs-keyword\">private</span> String sign;\n    <span class=\"hljs-keyword\">private</span> String templateID;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String SECRET_ID;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String SECRET_KEY;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String APP_ID;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String SIGN;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String TEMPLATE_ID;\n    <span class=\"hljs-comment\">//当私有成员被赋值后，此方法自动被调用，从而初始化常量</span>\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">afterPropertiesSet</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        SECRET_ID=secretId;\n        SECRET_KEY=secretKey;\n        APP_ID=appid;\n        SIGN=sign;\n        TEMPLATE_ID=templateID;\n    }\n\n}\n</code></div></pre>\n<ul>\n<li>service</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.jzj.srb.sms.service;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">TengXunSmsService</span> {\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">send</span><span class=\"hljs-params\">(String mobile, String code)</span>;\n}\n\n</code></div></pre>\n<ul>\n<li>service实现类</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.jzj.srb.sms.service.impl;\n\n<span class=\"hljs-keyword\">import</span> com.jzj.common.exception.Assert;\n<span class=\"hljs-keyword\">import</span> com.jzj.common.exception.BusinessException;\n<span class=\"hljs-keyword\">import</span> com.jzj.common.result.ResponseEnum;\n<span class=\"hljs-keyword\">import</span> com.jzj.srb.sms.service.TengXunSmsService;\n<span class=\"hljs-keyword\">import</span> com.jzj.srb.sms.util.TengXunSmsProperties;\n<span class=\"hljs-keyword\">import</span> com.tencentcloudapi.common.Credential;\n<span class=\"hljs-keyword\">import</span> com.tencentcloudapi.common.exception.TencentCloudSDKException;\n<span class=\"hljs-keyword\">import</span> com.tencentcloudapi.common.profile.ClientProfile;\n<span class=\"hljs-keyword\">import</span> com.tencentcloudapi.sms.v20190711.SmsClient;\n<span class=\"hljs-keyword\">import</span> com.tencentcloudapi.sms.v20190711.models.SendSmsRequest;\n<span class=\"hljs-keyword\">import</span> com.tencentcloudapi.sms.v20190711.models.SendSmsResponse;\n<span class=\"hljs-keyword\">import</span> com.tencentcloudapi.sms.v20190711.models.SendStatus;\n<span class=\"hljs-keyword\">import</span> lombok.extern.slf4j.Slf4j;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Service;\n\n<span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-meta\">@Slf4j</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TengXunSmsServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">TengXunSmsService</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">send</span><span class=\"hljs-params\">(String mobile,String code)</span> {\n        String jointMobile=<span class=\"hljs-string\">&quot;+86&quot;</span>+mobile;\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">secretId</span> <span class=\"hljs-operator\">=</span> TengXunSmsProperties.SECRET_ID;\n        String secretKey= TengXunSmsProperties.SECRET_KEY;\n        <span class=\"hljs-comment\">//短信应用 ID</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">appid</span> <span class=\"hljs-operator\">=</span> TengXunSmsProperties.APP_ID;\n        <span class=\"hljs-comment\">//短信签名内容</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sign</span> <span class=\"hljs-operator\">=</span> TengXunSmsProperties.SIGN;\n        <span class=\"hljs-comment\">//短信模板 ID</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">templateID</span> <span class=\"hljs-operator\">=</span> TengXunSmsProperties.TEMPLATE_ID;\n        <span class=\"hljs-comment\">//+86为国家码，182********为手机号，最多不要超过200个手机号</span>\n\n        String[] phoneNumbers = { jointMobile};\n        <span class=\"hljs-comment\">//模板参数: 若无模板参数，则设置为空</span>\n        String[] templateParams = { code };<span class=\"hljs-comment\">//对应模板中{1}</span>\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">//必要步骤： 实例化一个认证对象，入参需要传入腾讯云账户密钥对 secretId 和 secretKey</span>\n            <span class=\"hljs-type\">Credential</span> <span class=\"hljs-variable\">cred</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Credential</span>(secretId , secretKey);\n\n            <span class=\"hljs-type\">ClientProfile</span> <span class=\"hljs-variable\">clientProfile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ClientProfile</span>();\n            <span class=\"hljs-comment\">//SDK 默认用 TC3-HMAC-SHA256 进行签名 非必要请不要修改该字段</span>\n            clientProfile.setSignMethod(<span class=\"hljs-string\">&quot;HmacSHA256&quot;</span>);\n            <span class=\"hljs-comment\">// 实例化 SMS 的 client 对象 第二个参数是地域信息，可以直接填写字符串 ap-guangzhou，或者引用预设的常量</span>\n            <span class=\"hljs-type\">SmsClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SmsClient</span>(cred, <span class=\"hljs-string\">&quot;&quot;</span>, clientProfile);\n            <span class=\"hljs-comment\">//实例化一个请求对象，根据调用的接口和实际情况，可以进一步设置请求参数 您可以直接查询 SDK 源码确定接口有哪些属性可以设置</span>\n            <span class=\"hljs-type\">SendSmsRequest</span> <span class=\"hljs-variable\">req</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SendSmsRequest</span>();\n\n            <span class=\"hljs-comment\">// 短信应用 ID: 在 [短信控制台] 添加应用后生成的实际 SDKAppID，例如1400006666</span>\n            req.setSmsSdkAppid(appid);\n\n            <span class=\"hljs-comment\">// 短信签名内容: 使用 UTF-8 编码，必须填写已审核通过的签名，可登录 [短信控制台] 查看签名信息</span>\n            req.setSign(sign);\n\n            <span class=\"hljs-comment\">//短信模板 ID: 必须填写已审核通过的模板 ID，可登录 [短信控制台] 查看模板 ID</span>\n            req.setTemplateID(templateID);\n\n            <span class=\"hljs-comment\">//下发手机号码，采用 e.164 标准，+[国家或地区码][手机号] 例如+8613711112222</span>\n            req.setPhoneNumberSet(phoneNumbers);\n\n            req.setTemplateParamSet(templateParams);\n\n            <span class=\"hljs-comment\">// 通过 client 对象调用 SendSms 方法发起请求。注意请求方法名与请求对象是对应的 返回的 res 是一个SendSmsResponse 类的实例，与请求对象对应</span>\n            <span class=\"hljs-type\">SendSmsResponse</span> <span class=\"hljs-variable\">res</span> <span class=\"hljs-operator\">=</span> client.SendSms(req);\n            <span class=\"hljs-comment\">//获取响应结果</span>\n            SendStatus[] sendStatusSet = res.getSendStatusSet();\n            log.info(<span class=\"hljs-string\">&quot;短信发送返回的响应：&quot;</span>+sendStatusSet);\n            Assert.notEquals(<span class=\"hljs-string\">&quot;LimitExceeded.PhoneNumberThirtySecondLimit&quot;</span>,sendStatusSet[<span class=\"hljs-number\">0</span>].getCode(),ResponseEnum.TENGXUN_SMS_LIMIT_CONTROL_ERROR);\n            Assert.equals(<span class=\"hljs-string\">&quot;Ok&quot;</span>,sendStatusSet[<span class=\"hljs-number\">0</span>].getCode(),ResponseEnum.TENGXUN_SMS_ERROR);\n\n        } <span class=\"hljs-keyword\">catch</span> (TencentCloudSDKException e) {\n            log.error(<span class=\"hljs-string\">&quot;腾讯云短信发送sdk调用失败：&quot;</span>+e.getErrorCode()+<span class=\"hljs-string\">&quot;,&quot;</span>+e.getMessage());\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ResponseEnum.TENGXUN_SMS_ERROR,e);\n        }\n    }\n}\n\n</code></div></pre>\n<ul>\n<li>controller</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.jzj.srb.sms.controller.api;\n\n<span class=\"hljs-keyword\">import</span> com.jzj.common.exception.Assert;\n<span class=\"hljs-keyword\">import</span> com.jzj.common.result.R;\n<span class=\"hljs-keyword\">import</span> com.jzj.common.result.ResponseEnum;\n<span class=\"hljs-keyword\">import</span> com.jzj.common.util.RandomUtils;\n<span class=\"hljs-keyword\">import</span> com.jzj.common.util.RegexValidateUtils;\n<span class=\"hljs-keyword\">import</span> com.jzj.srb.sms.service.TengXunSmsService;\n<span class=\"hljs-keyword\">import</span> io.swagger.annotations.Api;\n<span class=\"hljs-keyword\">import</span> io.swagger.annotations.ApiOperation;\n<span class=\"hljs-keyword\">import</span> lombok.extern.slf4j.Slf4j;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.*;\n\n<span class=\"hljs-keyword\">import</span> javax.annotation.Resource;\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.TimeUnit;\n\n<span class=\"hljs-meta\">@CrossOrigin</span> <span class=\"hljs-comment\">//跨域</span>\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping(&quot;/api/sms&quot;)</span>\n<span class=\"hljs-meta\">@Api(tags = &quot;短信管理&quot;)</span>\n<span class=\"hljs-meta\">@Slf4j</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApiSmsController</span> {\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> TengXunSmsService tengXunSmsService;\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> RedisTemplate redisTemplate;\n\n    <span class=\"hljs-meta\">@ApiOperation(&quot;获取验证码&quot;)</span>\n    <span class=\"hljs-meta\">@GetMapping(&quot;/send/{mobile}&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> R <span class=\"hljs-title function_\">send</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@PathVariable</span> String mobile)</span>{\n        <span class=\"hljs-comment\">//手机号码不能为空</span>\n        Assert.notEmpty(mobile, ResponseEnum.MOBILE_NULL_ERROR);\n        <span class=\"hljs-comment\">//是否是合法的手机号码</span>\n        Assert.isTrue(RegexValidateUtils.checkCellphone(mobile),ResponseEnum.MOBILE_ERROR);\n        String code=RandomUtils.getFourBitRandom();\n        tengXunSmsService.send(mobile,code);\n        <span class=\"hljs-comment\">//将验证码存入redis中</span>\n        redisTemplate.opsForValue().set(<span class=\"hljs-string\">&quot;srb:sms:code:&quot;</span>+mobile,code,<span class=\"hljs-number\">5</span>, TimeUnit.MINUTES);\n        <span class=\"hljs-keyword\">return</span> R.ok().message(<span class=\"hljs-string\">&quot;短信发送成功&quot;</span>);\n    }\n}\n\n</code></div></pre>\n');
INSERT INTO `article_content` VALUES ('4fd382ced2e902c7ff6373c440b95174', '# 一、新建云存储微服务\n## 1、创建模块\nservice-oss\n## 2、配置pom.xml\n```java\n<dependencies>\n    <dependency>\n        <groupId>com.atguigu</groupId>\n        <artifactId>service-base</artifactId>\n        <version>0.0.1-SNAPSHOT</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    \n    <!--lombok用来简化实体类：需要安装lombok插件-->\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n    <!--aliyunOSS-->\n    <dependency>\n        <groupId>com.aliyun.oss</groupId>\n        <artifactId>aliyun-sdk-oss</artifactId>\n        <version>3.1.0</version>\n    </dependency>\n    <!-- 日期工具栏依赖 -->\n    <dependency>\n        <groupId>joda-time</groupId>\n        <artifactId>joda-time</artifactId>\n        <version>2.10.1</version>\n    </dependency>\n    <!--让自定义的配置在application.yaml进行自动提示-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-configuration-processor</artifactId>\n        <optional>true</optional>\n    </dependency>\n</dependencies>\n```\n## 3、配置application.yml\n```java\nserver:\n  port: 8130 # 服务端口\nspring:\n  profiles:\n    active: dev # 环境设置\n  application:\n    name: service-oss # 服务名\naliyun:\n  oss:\n    endpoint: 你的endponit\n    keyId: 你的阿里云keyid\n    keySecret: 你的阿里云keysecret\n    bucketName: srb-file\n```\n## 4、logback-spring.xml\n修改日志路径为 srb_log/oss\n## 5、创建启动类\n创建ServiceOssApplication.java\n```java\npackage com.atguigu.srb.oss;\n@SpringBootApplication\n@ComponentScan({\"com.atguigu.srb\", \"com.atguigu.common\"})\npublic class ServiceOssApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceOssApplication.class, args);\n    }\n}\n```\n## 6、启动项目\n\n# 二、实现文件上传\n## 1、从配置文件读取常量\n创建常量读取工具类：OssProperties.java\n```java\npackage com.atguigu.srb.oss.util;\n@Setter\n@Getter\n@Component\n@ConfigurationProperties(prefix = \"aliyun.oss\")\npublic class OssProperties implements InitializingBean {\n    private String endpoint;\n    private String keyId;\n    private String keySecret;\n    private String bucketName;\n    public static String ENDPOINT;\n    public static String KEY_ID;\n    public static String KEY_SECRET;\n    public static String BUCKET_NAME;\n    //当私有成员被赋值后，此方法自动被调用，从而初始化常量\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        ENDPOINT = endpoint;\n        KEY_ID = keyId;\n        KEY_SECRET = keySecret;\n        BUCKET_NAME = bucketName;\n    }\n}\n```\n## 2、文件上传业务\n创建Service接口：FileService.java\n```java\npackage com.atguigu.srb.oss.service;\npublic interface FileService {\n    /**\n     * 文件上传至阿里云\n     */\n    String upload(InputStream inputStream, String module, String fileName);\n}\n\n```\n实现：FileServiceImpl.java\n参考SDK中的：Java->上传文件->简单上传->流式上传->上传文件流\n```java\npackage com.atguigu.srb.oss.service.impl;\n@Service\npublic class FileServiceImpl implements FileService {\n    /**\n     * 文件上传至阿里云\n     */\n    @Override\n    public String upload(InputStream inputStream, String module, String fileName) {\n        // 创建OSSClient实例。\n        OSS ossClient = new OSSClientBuilder().build(\n                OssProperties.ENDPOINT,\n                OssProperties.KEY_ID,\n                OssProperties.KEY_SECRET);\n        //判断oss实例是否存在：如果不存在则创建，如果存在则获取\n        if(!ossClient.doesBucketExist(OssProperties.BUCKET_NAME)){\n            //创建bucket\n            ossClient.createBucket(OssProperties.BUCKET_NAME);\n            //设置oss实例的访问权限：公共读\n            ossClient.setBucketAcl(OssProperties.BUCKET_NAME, CannedAccessControlList.PublicRead);\n        }\n        //构建日期路径：avatar/2019/02/26/文件名\n        String folder = new DateTime().toString(\"yyyy/MM/dd\");\n        //文件名：uuid.扩展名\n        fileName = UUID.randomUUID().toString() + fileName.substring(fileName.lastIndexOf(\".\"));\n        //文件根路径\n        String key = module + \"/\" + folder + \"/\" + fileName;\n        //文件上传至阿里云\n        ossClient.putObject(OssProperties.BUCKET_NAME, key, inputStream);\n        // 关闭OSSClient。\n        ossClient.shutdown();\n        //阿里云文件绝对路径\n        return \"https://\" + OssProperties.BUCKET_NAME + \".\" + OssProperties.ENDPOINT + \"/\" + key;\n    }\n}\n```\n## 3、控制层\n创建controller.admin：FileController.java\n```java\npackage com.atguigu.srb.oss.controller.api;\n@Api(tags = \"阿里云文件管理\")\n@CrossOrigin //跨域\n@RestController\n@RequestMapping(\"/api/oss/file\")\npublic class FileController {\n    @Resource\n    private FileService fileService;\n    /**\n     * 文件上传\n     */\n    @ApiOperation(\"文件上传\")\n    @PostMapping(\"/upload\")\n    public R upload(\n            @ApiParam(value = \"文件\", required = true)\n            @RequestParam(\"file\") MultipartFile file,\n            @ApiParam(value = \"模块\", required = true)\n            @RequestParam(\"module\") String module)  {\n        try {\n            InputStream inputStream = file.getInputStream();\n            String originalFilename = file.getOriginalFilename();\n            String uploadUrl = fileService.upload(inputStream, module, originalFilename);\n            //返回r对象\n            return R.ok().message(\"文件上传成功\").data(\"url\", uploadUrl);\n        } catch (IOException e) {\n            throw new BusinessException(ResponseEnum.UPLOAD_ERROR, e);\n        }\n    }\n}\n```\n## 4、Swagger测试\n\n# 三、实现文件删除\n## 1、业务层\nService接口：FileService.java\n```java\n/**\n     * 根据路径删除文件\n     * @param url\n     */\nvoid removeFile(String url);\n```\n实现：FileServiceImpl.java\n```java\n/**\n     * 根据路径删除文件\n     * @param url\n     */\n@Override\npublic void removeFile(String url) {\n    // 创建OSSClient实例。\n    OSS ossClient = new OSSClientBuilder().build(\n        OssProperties.ENDPOINT,\n        OssProperties.KEY_ID,\n        OssProperties.KEY_SECRET);\n    //文件名（服务器上的文件路径）\n    String host = \"https://\" + OssProperties.BUCKET_NAME + \".\" + OssProperties.ENDPOINT + \"/\";\n    String objectName = url.substring(host.length());\n    // 删除文件。\n    ossClient.deleteObject(OssProperties.BUCKET_NAME, objectName);\n    // 关闭OSSClient。\n    ossClient.shutdown();\n}\n```\n## 2、控制层\n```java\n@ApiOperation(\"删除OSS文件\")\n@DeleteMapping(\"/remove\")\npublic R remove(\n    @ApiParam(value = \"要删除的文件路径\", required = true)\n    @RequestParam(\"url\") String url) {\n    fileService.removeFile(url);\n    return R.ok().message(\"删除成功\");\n}\n```\n==标记==', '2022-09-26 14:47:31', '2022-09-26 15:26:16', '<h1><a id=\"_0\"></a>一、新建云存储微服务</h1>\n<h2><a id=\"1_1\"></a>1、创建模块</h2>\n<p>service-oss</p>\n<h2><a id=\"2pomxml_3\"></a>2、配置pom.xml</h2>\n<pre><div class=\"hljs\"><code class=\"lang-java\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.atguigu&lt;/groupId&gt;\n        &lt;artifactId&gt;service-base&lt;/artifactId&gt;\n        &lt;version&gt;<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.1</span>-SNAPSHOT&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!--aliyunOSS--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;\n        &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;\n        &lt;version&gt;<span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span>&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 日期工具栏依赖 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;joda-time&lt;/groupId&gt;\n        &lt;artifactId&gt;joda-time&lt;/artifactId&gt;\n        &lt;version&gt;<span class=\"hljs-number\">2.10</span><span class=\"hljs-number\">.1</span>&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!--让自定义的配置在application.yaml进行自动提示--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n        &lt;optional&gt;<span class=\"hljs-literal\">true</span>&lt;/optional&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></div></pre>\n<h2><a id=\"3applicationyml_41\"></a>3、配置application.yml</h2>\n<pre><div class=\"hljs\"><code class=\"lang-java\">server:\n  port: <span class=\"hljs-number\">8130</span> # 服务端口\nspring:\n  profiles:\n    active: dev # 环境设置\n  application:\n    name: service-oss # 服务名\naliyun:\n  oss:\n    endpoint: 你的endponit\n    keyId: 你的阿里云keyid\n    keySecret: 你的阿里云keysecret\n    bucketName: srb-file\n</code></div></pre>\n<h2><a id=\"4logbackspringxml_57\"></a>4、logback-spring.xml</h2>\n<p>修改日志路径为 srb_log/oss</p>\n<h2><a id=\"5_59\"></a>5、创建启动类</h2>\n<p>创建ServiceOssApplication.java</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.atguigu.srb.oss;\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@ComponentScan({&quot;com.atguigu.srb&quot;, &quot;com.atguigu.common&quot;})</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServiceOssApplication</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        SpringApplication.run(ServiceOssApplication.class, args);\n    }\n}\n</code></div></pre>\n<h2><a id=\"6_71\"></a>6、启动项目</h2>\n<h1><a id=\"_73\"></a>二、实现文件上传</h1>\n<h2><a id=\"1_74\"></a>1、从配置文件读取常量</h2>\n<p>创建常量读取工具类：OssProperties.java</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.atguigu.srb.oss.util;\n<span class=\"hljs-meta\">@Setter</span>\n<span class=\"hljs-meta\">@Getter</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-meta\">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OssProperties</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">InitializingBean</span> {\n    <span class=\"hljs-keyword\">private</span> String endpoint;\n    <span class=\"hljs-keyword\">private</span> String keyId;\n    <span class=\"hljs-keyword\">private</span> String keySecret;\n    <span class=\"hljs-keyword\">private</span> String bucketName;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String ENDPOINT;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String KEY_ID;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String KEY_SECRET;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String BUCKET_NAME;\n    <span class=\"hljs-comment\">//当私有成员被赋值后，此方法自动被调用，从而初始化常量</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">afterPropertiesSet</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        ENDPOINT = endpoint;\n        KEY_ID = keyId;\n        KEY_SECRET = keySecret;\n        BUCKET_NAME = bucketName;\n    }\n}\n</code></div></pre>\n<h2><a id=\"2_101\"></a>2、文件上传业务</h2>\n<p>创建Service接口：FileService.java</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.atguigu.srb.oss.service;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">FileService</span> {\n    <span class=\"hljs-comment\">/**\n     * 文件上传至阿里云\n     */</span>\n    String <span class=\"hljs-title function_\">upload</span><span class=\"hljs-params\">(InputStream inputStream, String <span class=\"hljs-keyword\">module</span>, String fileName)</span>;\n}\n\n</code></div></pre>\n<p>实现：FileServiceImpl.java<br />\n参考SDK中的：Java-&gt;上传文件-&gt;简单上传-&gt;流式上传-&gt;上传文件流</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.atguigu.srb.oss.service.impl;\n<span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FileServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">FileService</span> {\n    <span class=\"hljs-comment\">/**\n     * 文件上传至阿里云\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">upload</span><span class=\"hljs-params\">(InputStream inputStream, String <span class=\"hljs-keyword\">module</span>, String fileName)</span> {\n        <span class=\"hljs-comment\">// 创建OSSClient实例。</span>\n        <span class=\"hljs-type\">OSS</span> <span class=\"hljs-variable\">ossClient</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OSSClientBuilder</span>().build(\n                OssProperties.ENDPOINT,\n                OssProperties.KEY_ID,\n                OssProperties.KEY_SECRET);\n        <span class=\"hljs-comment\">//判断oss实例是否存在：如果不存在则创建，如果存在则获取</span>\n        <span class=\"hljs-keyword\">if</span>(!ossClient.doesBucketExist(OssProperties.BUCKET_NAME)){\n            <span class=\"hljs-comment\">//创建bucket</span>\n            ossClient.createBucket(OssProperties.BUCKET_NAME);\n            <span class=\"hljs-comment\">//设置oss实例的访问权限：公共读</span>\n            ossClient.setBucketAcl(OssProperties.BUCKET_NAME, CannedAccessControlList.PublicRead);\n        }\n        <span class=\"hljs-comment\">//构建日期路径：avatar/2019/02/26/文件名</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">folder</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DateTime</span>().toString(<span class=\"hljs-string\">&quot;yyyy/MM/dd&quot;</span>);\n        <span class=\"hljs-comment\">//文件名：uuid.扩展名</span>\n        fileName = UUID.randomUUID().toString() + fileName.substring(fileName.lastIndexOf(<span class=\"hljs-string\">&quot;.&quot;</span>));\n        <span class=\"hljs-comment\">//文件根路径</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">key</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">module</span> + <span class=\"hljs-string\">&quot;/&quot;</span> + folder + <span class=\"hljs-string\">&quot;/&quot;</span> + fileName;\n        <span class=\"hljs-comment\">//文件上传至阿里云</span>\n        ossClient.putObject(OssProperties.BUCKET_NAME, key, inputStream);\n        <span class=\"hljs-comment\">// 关闭OSSClient。</span>\n        ossClient.shutdown();\n        <span class=\"hljs-comment\">//阿里云文件绝对路径</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;https://&quot;</span> + OssProperties.BUCKET_NAME + <span class=\"hljs-string\">&quot;.&quot;</span> + OssProperties.ENDPOINT + <span class=\"hljs-string\">&quot;/&quot;</span> + key;\n    }\n}\n</code></div></pre>\n<h2><a id=\"3_151\"></a>3、控制层</h2>\n<p>创建controller.admin：FileController.java</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.atguigu.srb.oss.controller.api;\n<span class=\"hljs-meta\">@Api(tags = &quot;阿里云文件管理&quot;)</span>\n<span class=\"hljs-meta\">@CrossOrigin</span> <span class=\"hljs-comment\">//跨域</span>\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping(&quot;/api/oss/file&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FileController</span> {\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> FileService fileService;\n    <span class=\"hljs-comment\">/**\n     * 文件上传\n     */</span>\n    <span class=\"hljs-meta\">@ApiOperation(&quot;文件上传&quot;)</span>\n    <span class=\"hljs-meta\">@PostMapping(&quot;/upload&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> R <span class=\"hljs-title function_\">upload</span><span class=\"hljs-params\">(\n            <span class=\"hljs-meta\">@ApiParam(value = &quot;文件&quot;, required = true)</span>\n            <span class=\"hljs-meta\">@RequestParam(&quot;file&quot;)</span> MultipartFile file,\n            <span class=\"hljs-meta\">@ApiParam(value = &quot;模块&quot;, required = true)</span>\n            <span class=\"hljs-meta\">@RequestParam(&quot;module&quot;)</span> String <span class=\"hljs-keyword\">module</span>)</span>  {\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-type\">InputStream</span> <span class=\"hljs-variable\">inputStream</span> <span class=\"hljs-operator\">=</span> file.getInputStream();\n            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">originalFilename</span> <span class=\"hljs-operator\">=</span> file.getOriginalFilename();\n            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">uploadUrl</span> <span class=\"hljs-operator\">=</span> fileService.upload(inputStream, <span class=\"hljs-keyword\">module</span>, originalFilename);\n            <span class=\"hljs-comment\">//返回r对象</span>\n            <span class=\"hljs-keyword\">return</span> R.ok().message(<span class=\"hljs-string\">&quot;文件上传成功&quot;</span>).data(<span class=\"hljs-string\">&quot;url&quot;</span>, uploadUrl);\n        } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ResponseEnum.UPLOAD_ERROR, e);\n        }\n    }\n}\n</code></div></pre>\n<h2><a id=\"4Swagger_184\"></a>4、Swagger测试</h2>\n<h1><a id=\"_186\"></a>三、实现文件删除</h1>\n<h2><a id=\"1_187\"></a>1、业务层</h2>\n<p>Service接口：FileService.java</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n     * 根据路径删除文件\n     * <span class=\"hljs-doctag\">@param</span> url\n     */</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">removeFile</span><span class=\"hljs-params\">(String url)</span>;\n</code></div></pre>\n<p>实现：FileServiceImpl.java</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n     * 根据路径删除文件\n     * <span class=\"hljs-doctag\">@param</span> url\n     */</span>\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">removeFile</span><span class=\"hljs-params\">(String url)</span> {\n    <span class=\"hljs-comment\">// 创建OSSClient实例。</span>\n    <span class=\"hljs-type\">OSS</span> <span class=\"hljs-variable\">ossClient</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OSSClientBuilder</span>().build(\n        OssProperties.ENDPOINT,\n        OssProperties.KEY_ID,\n        OssProperties.KEY_SECRET);\n    <span class=\"hljs-comment\">//文件名（服务器上的文件路径）</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">host</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;https://&quot;</span> + OssProperties.BUCKET_NAME + <span class=\"hljs-string\">&quot;.&quot;</span> + OssProperties.ENDPOINT + <span class=\"hljs-string\">&quot;/&quot;</span>;\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">objectName</span> <span class=\"hljs-operator\">=</span> url.substring(host.length());\n    <span class=\"hljs-comment\">// 删除文件。</span>\n    ossClient.deleteObject(OssProperties.BUCKET_NAME, objectName);\n    <span class=\"hljs-comment\">// 关闭OSSClient。</span>\n    ossClient.shutdown();\n}\n</code></div></pre>\n<h2><a id=\"2_218\"></a>2、控制层</h2>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@ApiOperation(&quot;删除OSS文件&quot;)</span>\n<span class=\"hljs-meta\">@DeleteMapping(&quot;/remove&quot;)</span>\n<span class=\"hljs-keyword\">public</span> R <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(\n    <span class=\"hljs-meta\">@ApiParam(value = &quot;要删除的文件路径&quot;, required = true)</span>\n    <span class=\"hljs-meta\">@RequestParam(&quot;url&quot;)</span> String url)</span> {\n    fileService.removeFile(url);\n    <span class=\"hljs-keyword\">return</span> R.ok().message(<span class=\"hljs-string\">&quot;删除成功&quot;</span>);\n}\n</code></div></pre>\n<p><mark>标记</mark></p>\n');
INSERT INTO `article_content` VALUES ('5dc9ccb15fe3224878945a842f7f6427', '1. SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。\n2. socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。\n3. 设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。\n\n\nAbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png)\n\n:::\n\n下面分别介绍这 3 个通道\n\n### 1 ServerSocketChannel\nServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。\n\n由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。\n\n同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。\n\n以下代码演示了如何使用一个非阻塞的 accept( )方法：\n```java\npublic class ServerSocketChannelDemo {\n    public static void main(String[] args) throws Exception {\n        //端口号\n        int port = 9999;\n        //buffer\n        ByteBuffer buffer = ByteBuffer.wrap(\"hello word\".getBytes(StandardCharsets.UTF_8));\n\n        //ServerSocketChannel\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        //绑定\n        ssc.socket().bind(new InetSocketAddress(port));\n        //设置非阻塞模式\n        ssc.configureBlocking(false);\n\n        //监听是否有新链接传入\n        while (true){\n            System.out.println(\"Waiting for connections\");\n            SocketChannel sc = ssc.accept();\n            if(sc == null){\n                //没有链接传入\n                System.out.println(\"null\");\n                Thread.sleep(2000);\n            }else {\n                System.out.println(\"Incoming connection from:\"+sc.socket().getRemoteSocketAddress());\n                buffer.rewind(); //指针0\n                sc.write(buffer);\n                sc.close();\n            }\n        }\n    }\n}\n```\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/57a63832c66f45c5bbff395c36d92be7.png)\n\n:::\n\n- 打开 ServerSocketChannel\n通过调用 ServerSocketChannel.open() 方法来打开 ServerSocketChannel.\n```java\nServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n```\n- 关闭 ServerSocketChannel\n通过调用 ServerSocketChannel.close() 方法来关闭 ServerSocketChannel.\n```java\nserverSocketChannel.close();\n```\n\n\n- 监听新的连接\n通过 ServerSocketChannel.accept() 方法监听新进的连接。当 accept()方法返回时 候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞 到有新连接到达。\n通常不会仅仅只监听一个连接,在 while 循环中调用 accept()方法. 如下面的例子：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/3e5b7a01f90e49efa8f1f6ad814858cd.png)\n\n:::\n\n- 阻塞模式\n会在 SocketChannel sc = ssc.accept();这里阻塞住进程。\n\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/3b10263a28184fa199557f6f2aeaa674.png)\n\n:::\n\n\n- 非阻塞模式\nServerSocketChannel 可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立 刻返回，如果还没有新进来的连接,返回的将是 null。 因此，需要检查返回的 SocketChannel 是否是 null.如：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/07e22f9e39af427b817c698bdc089c43.png)\n\n:::\n\n### 2 SocketChannel\n#### 2.1 SocketChannel 介绍\nJava NIO 中的 SocketChannel 是一个连接到 TCP 网络套接字的通道。\n> A selectable channel for stream-oriented connecting sockets.\n\n以上是 Java docs 中对于 SocketChannel 的描述：SocketChannel 是一种面向流连接 sockets 套接字的可选择通道。从这里可以看出：\n-  SocketChannel 是用来连接 Socket 套接字\n- SocketChannel 主要用途用来处理网络 I/O 的通道\n- SocketChannel 是基于 TCP 连接传输\n- SocketChannel 实现了可选择通道，可以被多路复用的\n\n#### 2.2 SocketChannel 特征\n- 对于已经存在的 socket 不能创建 SocketChannel\n- SocketChannel 中提供的 open 接口创建的 Channel 并没有进行网络级联，需要使 用 connect 接口连接到指定地址\n- 未进行连接的 SocketChannle 执行 I/O 操作时，会抛出 NotYetConnectedException\n- SocketChannel 支持两种 I/O 模式：阻塞式和非阻塞式\n- SocketChannel 支持异步关闭。如果 SocketChannel 在一个线程上 read 阻塞，另 一个线程对该 SocketChannel 调用 shutdownInput，则读阻塞的线程将返回-1 表示没有 读取任何数据；如果 SocketChannel 在一个线程上 write 阻塞，另一个线程对该 SocketChannel 调用 shutdownWrite，则写阻塞的线程将抛出 AsynchronousCloseException\n- SocketChannel 支持设定参数 SO_SNDBUF 套接字发送缓冲区大小, SO_RCVBUF 套接字接收缓冲区大小, SO_KEEPALIVE 保活连接 O_REUSEADDR 复用地址, SO_LINGER 有数据传输时延缓关闭 Channel (只有在非阻塞模式下有用), TCP_NODELAY 禁用 Nagle 算法\n\n#### 2.3 SocketChannel 的使用\n- 创建 SocketChannel\n\n\n第一种：\n```java\nSocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"www.baidu.com\", 80));\n```\n第二种：\n```java\nSocketChannel socketChanne2 = SocketChannel.open(); \nsocketChanne2.connect(new InetSocketAddress(\"www.baidu.com\", 80));\n```\n直接使用有参 open api 或者使用无参 open api，但是在无参 open 只是创建了一个 SocketChannel 对象，并没有进行实质的 tcp 连接。\n- 连接校验\n```java\nsocketChannel.isOpen(); // 测试 SocketChannel 是否为 open 状态 \nsocketChannel.isConnected(); //测试 SocketChannel 是否已经被连接 \nsocketChannel.isConnectionPending(); //测试 SocketChannel 是否正在进行 连接\nsocketChannel.finishConnect(); //校验正在进行套接字连接的 SocketChannel 是否已经完成连接\n```\n- 读写模式\n前面提到 SocketChannel 支持阻塞和非阻塞两种模式：\n```java\nsocketChannel.configureBlocking(false);\n```\n通过以上方法设置 SocketChannel 的读写模式。false 表示非阻塞，true 表示阻塞。\n- 读写\n```java\nSocketChannel socketChannel = SocketChannel.open( new InetSocketAddress(\"www.baidu.com\", 80)); \nByteBuffer byteBuffer = ByteBuffer.allocate(16); \nsocketChannel.read(byteBuffer); socketChannel.close(); \nSystem.out.println(\"read over\");\n```\n以上为阻塞式读，当执行到 read 出，线程将阻塞，控制台将无法打印 read over\n```java\nSocketChannel socketChannel = SocketChannel.open( new InetSocketAddress(\"www.baidu.com\", 80)); \nsocketChannel.configureBlocking(false); ByteBuffer byteBuffer = ByteBuffer.allocate(16); \nsocketChannel.read(byteBuffer); socketChannel.close();\nSystem.out.println(\"read over\");\n```\n以上为非阻塞读，控制台将打印 read over\n读写都是面向缓冲区，这个读写方式与前文中的 FileChannel 相同。\n- 设置和获取参数\n```java\nsocketChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, Boolean.TRUE)\n.setOption(StandardSocketOptions.TCP_NODELAY, Boolean.TRUE);\n```\n通过 setOptions 方法可以设置 socket 套接字的相关参数\n```java\nsocketChannel.getOption(StandardSocketOptions.SO_KEEPALIVE); \nsocketChannel.getOption(StandardSocketOptions.SO_RCVBUF);\n```\n可以通过 getOption 获取相关参数的值。如默认的接收缓冲区大小是 8192byte。\nSocketChannel 还支持多路复用，但是多路复用在后续内容中会介绍到。\n\n### 3 DatagramChannel\n正如 SocketChannel 对应 Socket，ServerSocketChannel 对应 ServerSocket，每 一个 DatagramChannel 对象也有一个关联的 DatagramSocket 对象。正如 SocketChannel 模拟连接导向的流协议（如 TCP/IP），DatagramChannel 则模拟包 导向的无连接协议（如 UDP/IP）。DatagramChannel 是无连接的，每个数据报 （datagram）都是一个自包含的实体，拥有它自己的目的地址及不依赖其他数据报的 数据负载。与面向流的的 socket 不同，DatagramChannel 可以发送单独的数据报给 不同的目的地址。同样，DatagramChannel 对象也可以接收来自任意地址的数据包。 每个到达的数据报都含有关于它来自何处的信息（源地址）。\n\n#### 3.1 打开 DatagramChannel\n```java\nDatagramChannel server = DatagramChannel.open(); \nserver.socket().bind(new InetSocketAddress(10086));\n```\n此例子是打开 10086 端口接收 UDP 数据包\n\n#### 3.2 接收数据\n通过 receive()接收 UDP 包\n```java\nByteBuffer receiveBuffer = ByteBuffer.allocate(64); \nreceiveBuffer.clear(); \nSocketAddress receiveAddr = server.receive(receiveBuffer);\n```\nSocketAddress 可以获得发包的 ip、端口等信息，用 toString 查看\n\n#### 3.3 发送数据\n通过 send()发送 UDP 包\n```java\nDatagramChannel server = DatagramChannel.open(); \nByteBuffer sendBuffer = ByteBuffer.wrap(\"client send\".getBytes()); \nserver.send(sendBuffer, new InetSocketAddress(\"127.0.0.1\",10086));\n```\n\n#### 3.4 连接\nUDP 不存在真正意义上的连接，这里的连接是向特定服务地址用 read 和 write 接收 发送数据包。\n```java\nclient.connect(new InetSocketAddress(\"127.0.0.1\",10086)); \nint readSize= client.read(sendBuffer); \nserver.write(sendBuffer);\n```\nread()和 write()只有在 connect()后才能使用，不然会抛 NotYetConnectedException 异常。用 read()接收时，如果没有接收到包，会抛 PortUnreachableException 异常。\n\n#### 3.4 DatagramChannel 示例\n客户端发送，服务端接收的例子\n```java\npublic class DatagramChannelDemo {\n\n    //发送实现\n    @Test\n    public void sendDatagram() throws Exception {\n        //打开DatagramChannel\n        DatagramChannel sendChannel = DatagramChannel.open();\n        InetSocketAddress sendAddress = new InetSocketAddress(\"127.0.0.1\", 9999);\n\n        //发送\n        while (true){\n            ByteBuffer buffer = ByteBuffer.wrap(\"发送Jzj\".getBytes(StandardCharsets.UTF_8));\n            sendChannel.send(buffer,sendAddress);\n            System.out.println(\"已经完成发送\");\n            Thread.sleep(1000);\n        }\n    }\n\n\n    //接收实现\n    @Test\n    public void receiveDatagram() throws Exception{\n        //打开DatagramChannel\n        DatagramChannel receiveChannel = DatagramChannel.open();\n        InetSocketAddress receiveAddress = new InetSocketAddress(9999);\n        //绑定\n        receiveChannel.bind(receiveAddress);\n        //Buffer\n        ByteBuffer receiveBuffer = ByteBuffer.allocate(1024);\n        while (true){\n            receiveBuffer.clear();\n            SocketAddress socketAddress = receiveChannel.receive(receiveBuffer);\n            receiveBuffer.flip();\n            System.out.println(socketAddress.toString());\n            System.out.println(Charset.forName(\"UTF-8\").decode(receiveBuffer));\n        }\n    }\n\n    //连接 read 和 write\n    @Test\n    public void testConnect() throws Exception {\n        //打开DatagramChannel\n        DatagramChannel connChannel = DatagramChannel.open();\n        //绑定\n        connChannel.bind(new InetSocketAddress(9999));\n        //连接\n        connChannel.connect(new InetSocketAddress(\"127.0.0.1\",9999));\n        //write方法\n        connChannel.write(ByteBuffer.wrap(\"发送Jzj\".getBytes(StandardCharsets.UTF_8)));\n        //buffer\n        ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n        while (true){\n            readBuffer.clear();\n            connChannel.read(readBuffer);\n            readBuffer.flip();\n            System.out.println(Charset.forName(\"UTF-8\").decode(readBuffer));\n        }\n    }\n}\n```\n', '2022-09-30 16:30:45', '2022-10-08 16:26:27', '<ol>\n<li>SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。</li>\n<li>socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。</li>\n<li>设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。</li>\n</ol>\n<p>AbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png\" alt=\"image.png\" /></p>\n</div>\n<p>下面分别介绍这 3 个通道</p>\n<h3><a id=\"1_ServerSocketChannel_14\"></a>1 ServerSocketChannel</h3>\n<p>ServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。</p>\n<p>由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。</p>\n<p>同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。</p>\n<p>以下代码演示了如何使用一个非阻塞的 accept( )方法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServerSocketChannelDemo</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">//端口号</span>\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">9999</span>;\n        <span class=\"hljs-comment\">//buffer</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(<span class=\"hljs-string\">&quot;hello word&quot;</span>.getBytes(StandardCharsets.UTF_8));\n\n        <span class=\"hljs-comment\">//ServerSocketChannel</span>\n        <span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">ssc</span> <span class=\"hljs-operator\">=</span> ServerSocketChannel.open();\n        <span class=\"hljs-comment\">//绑定</span>\n        ssc.socket().bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(port));\n        <span class=\"hljs-comment\">//设置非阻塞模式</span>\n        ssc.configureBlocking(<span class=\"hljs-literal\">false</span>);\n\n        <span class=\"hljs-comment\">//监听是否有新链接传入</span>\n        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>){\n            System.out.println(<span class=\"hljs-string\">&quot;Waiting for connections&quot;</span>);\n            <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> ssc.accept();\n            <span class=\"hljs-keyword\">if</span>(sc == <span class=\"hljs-literal\">null</span>){\n                <span class=\"hljs-comment\">//没有链接传入</span>\n                System.out.println(<span class=\"hljs-string\">&quot;null&quot;</span>);\n                Thread.sleep(<span class=\"hljs-number\">2000</span>);\n            }<span class=\"hljs-keyword\">else</span> {\n                System.out.println(<span class=\"hljs-string\">&quot;Incoming connection from:&quot;</span>+sc.socket().getRemoteSocketAddress());\n                buffer.rewind(); <span class=\"hljs-comment\">//指针0</span>\n                sc.write(buffer);\n                sc.close();\n            }\n        }\n    }\n}\n</code></div></pre>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/57a63832c66f45c5bbff395c36d92be7.png\" alt=\"image.png\" /></p>\n</div>\n<ul>\n<li>打开 ServerSocketChannel<br />\n通过调用 ServerSocketChannel.open() 方法来打开 ServerSocketChannel.</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">serverSocketChannel</span> <span class=\"hljs-operator\">=</span> ServerSocketChannel.open();\n</code></div></pre>\n<ul>\n<li>关闭 ServerSocketChannel<br />\n通过调用 ServerSocketChannel.close() 方法来关闭 ServerSocketChannel.</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\">serverSocketChannel.close();\n</code></div></pre>\n<ul>\n<li>监听新的连接<br />\n通过 ServerSocketChannel.accept() 方法监听新进的连接。当 accept()方法返回时 候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞 到有新连接到达。<br />\n通常不会仅仅只监听一个连接,在 while 循环中调用 accept()方法. 如下面的例子：</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/3e5b7a01f90e49efa8f1f6ad814858cd.png\" alt=\"image.png\" /></p>\n</div>\n<ul>\n<li>阻塞模式<br />\n会在 SocketChannel sc = ssc.accept();这里阻塞住进程。</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/3b10263a28184fa199557f6f2aeaa674.png\" alt=\"image.png\" /></p>\n</div>\n<ul>\n<li>非阻塞模式<br />\nServerSocketChannel 可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立 刻返回，如果还没有新进来的连接,返回的将是 null。 因此，需要检查返回的 SocketChannel 是否是 null.如：</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/07e22f9e39af427b817c698bdc089c43.png\" alt=\"image.png\" /></p>\n</div>\n<h3><a id=\"2_SocketChannel_100\"></a>2 SocketChannel</h3>\n<h4><a id=\"21_SocketChannel__101\"></a>2.1 SocketChannel 介绍</h4>\n<p>Java NIO 中的 SocketChannel 是一个连接到 TCP 网络套接字的通道。</p>\n<blockquote>\n<p>A selectable channel for stream-oriented connecting sockets.</p>\n</blockquote>\n<p>以上是 Java docs 中对于 SocketChannel 的描述：SocketChannel 是一种面向流连接 sockets 套接字的可选择通道。从这里可以看出：</p>\n<ul>\n<li>SocketChannel 是用来连接 Socket 套接字</li>\n<li>SocketChannel 主要用途用来处理网络 I/O 的通道</li>\n<li>SocketChannel 是基于 TCP 连接传输</li>\n<li>SocketChannel 实现了可选择通道，可以被多路复用的</li>\n</ul>\n<h4><a id=\"22_SocketChannel__111\"></a>2.2 SocketChannel 特征</h4>\n<ul>\n<li>对于已经存在的 socket 不能创建 SocketChannel</li>\n<li>SocketChannel 中提供的 open 接口创建的 Channel 并没有进行网络级联，需要使 用 connect 接口连接到指定地址</li>\n<li>未进行连接的 SocketChannle 执行 I/O 操作时，会抛出 NotYetConnectedException</li>\n<li>SocketChannel 支持两种 I/O 模式：阻塞式和非阻塞式</li>\n<li>SocketChannel 支持异步关闭。如果 SocketChannel 在一个线程上 read 阻塞，另 一个线程对该 SocketChannel 调用 shutdownInput，则读阻塞的线程将返回-1 表示没有 读取任何数据；如果 SocketChannel 在一个线程上 write 阻塞，另一个线程对该 SocketChannel 调用 shutdownWrite，则写阻塞的线程将抛出 AsynchronousCloseException</li>\n<li>SocketChannel 支持设定参数 SO_SNDBUF 套接字发送缓冲区大小, SO_RCVBUF 套接字接收缓冲区大小, SO_KEEPALIVE 保活连接 O_REUSEADDR 复用地址, SO_LINGER 有数据传输时延缓关闭 Channel (只有在非阻塞模式下有用), TCP_NODELAY 禁用 Nagle 算法</li>\n</ul>\n<h4><a id=\"23_SocketChannel__119\"></a>2.3 SocketChannel 的使用</h4>\n<ul>\n<li>创建 SocketChannel</li>\n</ul>\n<p>第一种：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChannel</span> <span class=\"hljs-operator\">=</span> SocketChannel.open(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;www.baidu.com&quot;</span>, <span class=\"hljs-number\">80</span>));\n</code></div></pre>\n<p>第二种：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChanne2</span> <span class=\"hljs-operator\">=</span> SocketChannel.open(); \nsocketChanne2.connect(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;www.baidu.com&quot;</span>, <span class=\"hljs-number\">80</span>));\n</code></div></pre>\n<p>直接使用有参 open api 或者使用无参 open api，但是在无参 open 只是创建了一个 SocketChannel 对象，并没有进行实质的 tcp 连接。</p>\n<ul>\n<li>连接校验</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\">socketChannel.isOpen(); <span class=\"hljs-comment\">// 测试 SocketChannel 是否为 open 状态 </span>\nsocketChannel.isConnected(); <span class=\"hljs-comment\">//测试 SocketChannel 是否已经被连接 </span>\nsocketChannel.isConnectionPending(); <span class=\"hljs-comment\">//测试 SocketChannel 是否正在进行 连接</span>\nsocketChannel.finishConnect(); <span class=\"hljs-comment\">//校验正在进行套接字连接的 SocketChannel 是否已经完成连接</span>\n</code></div></pre>\n<ul>\n<li>读写模式<br />\n前面提到 SocketChannel 支持阻塞和非阻塞两种模式：</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\">socketChannel.configureBlocking(<span class=\"hljs-literal\">false</span>);\n</code></div></pre>\n<p>通过以上方法设置 SocketChannel 的读写模式。false 表示非阻塞，true 表示阻塞。</p>\n<ul>\n<li>读写</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChannel</span> <span class=\"hljs-operator\">=</span> SocketChannel.open( <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;www.baidu.com&quot;</span>, <span class=\"hljs-number\">80</span>)); \n<span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">byteBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">16</span>); \nsocketChannel.read(byteBuffer); socketChannel.close(); \nSystem.out.println(<span class=\"hljs-string\">&quot;read over&quot;</span>);\n</code></div></pre>\n<p>以上为阻塞式读，当执行到 read 出，线程将阻塞，控制台将无法打印 read over</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChannel</span> <span class=\"hljs-operator\">=</span> SocketChannel.open( <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;www.baidu.com&quot;</span>, <span class=\"hljs-number\">80</span>)); \nsocketChannel.configureBlocking(<span class=\"hljs-literal\">false</span>); <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">byteBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">16</span>); \nsocketChannel.read(byteBuffer); socketChannel.close();\nSystem.out.println(<span class=\"hljs-string\">&quot;read over&quot;</span>);\n</code></div></pre>\n<p>以上为非阻塞读，控制台将打印 read over<br />\n读写都是面向缓冲区，这个读写方式与前文中的 FileChannel 相同。</p>\n<ul>\n<li>设置和获取参数</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\">socketChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, Boolean.TRUE)\n.setOption(StandardSocketOptions.TCP_NODELAY, Boolean.TRUE);\n</code></div></pre>\n<p>通过 setOptions 方法可以设置 socket 套接字的相关参数</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">socketChannel.getOption(StandardSocketOptions.SO_KEEPALIVE); \nsocketChannel.getOption(StandardSocketOptions.SO_RCVBUF);\n</code></div></pre>\n<p>可以通过 getOption 获取相关参数的值。如默认的接收缓冲区大小是 8192byte。<br />\nSocketChannel 还支持多路复用，但是多路复用在后续内容中会介绍到。</p>\n<h3><a id=\"3_DatagramChannel_175\"></a>3 DatagramChannel</h3>\n<p>正如 SocketChannel 对应 Socket，ServerSocketChannel 对应 ServerSocket，每 一个 DatagramChannel 对象也有一个关联的 DatagramSocket 对象。正如 SocketChannel 模拟连接导向的流协议（如 TCP/IP），DatagramChannel 则模拟包 导向的无连接协议（如 UDP/IP）。DatagramChannel 是无连接的，每个数据报 （datagram）都是一个自包含的实体，拥有它自己的目的地址及不依赖其他数据报的 数据负载。与面向流的的 socket 不同，DatagramChannel 可以发送单独的数据报给 不同的目的地址。同样，DatagramChannel 对象也可以接收来自任意地址的数据包。 每个到达的数据报都含有关于它来自何处的信息（源地址）。</p>\n<h4><a id=\"31__DatagramChannel_178\"></a>3.1 打开 DatagramChannel</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">DatagramChannel</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> DatagramChannel.open(); \nserver.socket().bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">10086</span>));\n</code></div></pre>\n<p>此例子是打开 10086 端口接收 UDP 数据包</p>\n<h4><a id=\"32__185\"></a>3.2 接收数据</h4>\n<p>通过 receive()接收 UDP 包</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">receiveBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">64</span>); \nreceiveBuffer.clear(); \n<span class=\"hljs-type\">SocketAddress</span> <span class=\"hljs-variable\">receiveAddr</span> <span class=\"hljs-operator\">=</span> server.receive(receiveBuffer);\n</code></div></pre>\n<p>SocketAddress 可以获得发包的 ip、端口等信息，用 toString 查看</p>\n<h4><a id=\"33__194\"></a>3.3 发送数据</h4>\n<p>通过 send()发送 UDP 包</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">DatagramChannel</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> DatagramChannel.open(); \n<span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">sendBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(<span class=\"hljs-string\">&quot;client send&quot;</span>.getBytes()); \nserver.send(sendBuffer, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>,<span class=\"hljs-number\">10086</span>));\n</code></div></pre>\n<h4><a id=\"34__202\"></a>3.4 连接</h4>\n<p>UDP 不存在真正意义上的连接，这里的连接是向特定服务地址用 read 和 write 接收 发送数据包。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">client.connect(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>,<span class=\"hljs-number\">10086</span>)); \n<span class=\"hljs-type\">int</span> readSize= client.read(sendBuffer); \nserver.write(sendBuffer);\n</code></div></pre>\n<p>read()和 write()只有在 connect()后才能使用，不然会抛 NotYetConnectedException 异常。用 read()接收时，如果没有接收到包，会抛 PortUnreachableException 异常。</p>\n<h4><a id=\"34_DatagramChannel__211\"></a>3.4 DatagramChannel 示例</h4>\n<p>客户端发送，服务端接收的例子</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DatagramChannelDemo</span> {\n\n    <span class=\"hljs-comment\">//发送实现</span>\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sendDatagram</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">//打开DatagramChannel</span>\n        <span class=\"hljs-type\">DatagramChannel</span> <span class=\"hljs-variable\">sendChannel</span> <span class=\"hljs-operator\">=</span> DatagramChannel.open();\n        <span class=\"hljs-type\">InetSocketAddress</span> <span class=\"hljs-variable\">sendAddress</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>, <span class=\"hljs-number\">9999</span>);\n\n        <span class=\"hljs-comment\">//发送</span>\n        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>){\n            <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(<span class=\"hljs-string\">&quot;发送Jzj&quot;</span>.getBytes(StandardCharsets.UTF_8));\n            sendChannel.send(buffer,sendAddress);\n            System.out.println(<span class=\"hljs-string\">&quot;已经完成发送&quot;</span>);\n            Thread.sleep(<span class=\"hljs-number\">1000</span>);\n        }\n    }\n\n\n    <span class=\"hljs-comment\">//接收实现</span>\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">receiveDatagram</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception{\n        <span class=\"hljs-comment\">//打开DatagramChannel</span>\n        <span class=\"hljs-type\">DatagramChannel</span> <span class=\"hljs-variable\">receiveChannel</span> <span class=\"hljs-operator\">=</span> DatagramChannel.open();\n        <span class=\"hljs-type\">InetSocketAddress</span> <span class=\"hljs-variable\">receiveAddress</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">9999</span>);\n        <span class=\"hljs-comment\">//绑定</span>\n        receiveChannel.bind(receiveAddress);\n        <span class=\"hljs-comment\">//Buffer</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">receiveBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>){\n            receiveBuffer.clear();\n            <span class=\"hljs-type\">SocketAddress</span> <span class=\"hljs-variable\">socketAddress</span> <span class=\"hljs-operator\">=</span> receiveChannel.receive(receiveBuffer);\n            receiveBuffer.flip();\n            System.out.println(socketAddress.toString());\n            System.out.println(Charset.forName(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>).decode(receiveBuffer));\n        }\n    }\n\n    <span class=\"hljs-comment\">//连接 read 和 write</span>\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testConnect</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">//打开DatagramChannel</span>\n        <span class=\"hljs-type\">DatagramChannel</span> <span class=\"hljs-variable\">connChannel</span> <span class=\"hljs-operator\">=</span> DatagramChannel.open();\n        <span class=\"hljs-comment\">//绑定</span>\n        connChannel.bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">9999</span>));\n        <span class=\"hljs-comment\">//连接</span>\n        connChannel.connect(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>,<span class=\"hljs-number\">9999</span>));\n        <span class=\"hljs-comment\">//write方法</span>\n        connChannel.write(ByteBuffer.wrap(<span class=\"hljs-string\">&quot;发送Jzj&quot;</span>.getBytes(StandardCharsets.UTF_8)));\n        <span class=\"hljs-comment\">//buffer</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">readBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>){\n            readBuffer.clear();\n            connChannel.read(readBuffer);\n            readBuffer.flip();\n            System.out.println(Charset.forName(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>).decode(readBuffer));\n        }\n    }\n}\n</code></div></pre>\n');
INSERT INTO `article_content` VALUES ('68c89984823c939509f7601517b358ad', '### 1 Selector 简介\n#### 1.1 Selector 和 Channel 关系\nSelector 一般称 为选择器 ，也可以翻译为 多路复用器 。它是 Java NIO 核心组件中 的一个，用于检查一个或多个 NIO Channel（通道）的状态是否处于可读、可写。如 此可以实现单线程管理多个 channels,也就是可以管理多个网络链接。\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/7ae9446e0bca4a518b305073e07475d0.png)\n\n:::\n\n使用 Selector 的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个 线程，避免了线程上下文切换带来的开销。\n\n#### 1.2 可选择通道(SelectableChannel)\n（1）不是所有的 Channel 都可以被 Selector 复用的。比方说，FileChannel 就不能 被选择器复用。判断一个 Channel 能被 Selector 复用，有一个前提：判断他是否继承了一个抽象类 SelectableChannel。如果继承了 SelectableChannel，则可以被复 用，否则不能。\n\n（2）SelectableChannel 类提供了实现通道的可选择性所需要的公共方法。它是所有 支持就绪检查的通道类的父类。所有 socket 通道，都继承了 SelectableChannel 类 都是可选择的，包括从管道(Pipe)对象的中获得的通道。而 FileChannel 类，没有继 承 SelectableChannel，因此是不是可选通道。\n\n（3）一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。通 道和选择器之间的关系，使用注册的方式完成。SelectableChannel 可以被注册到 Selector 对象上，在注册的时候，需要指定通道的哪些操作，是 Selector 感兴趣的。\n\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/4f68bfeb91434f1eb900f948f52e0dae.png)\n\n:::\n\n#### 1.3 Channel 注册到 Selector\n（1）使用 Channel.register（Selector sel，int ops）方法，将一个通道注册到一个 选择器时。第一个参数，指定通道要注册的选择器。第二个参数指定选择器需要查询 的通道操作。 \n（2）可以供选择器查询的通道操作，从类型来分，包括以下四种：\n- 可读 : SelectionKey.OP_READ\n- 可写 : SelectionKey.OP_WRITE\n- 连接 : SelectionKey.OP_CONNECT\n- 接收 : SelectionKey.OP_ACCEPT\n\n如果 Selector 对通道的多操作类型感兴趣，可以用“位或”操作符来实现： 比如：int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE ;\n\n（3）选择器查询的不是通道的操作，而是通道的某个操作的一种就绪状态。什么是操 作的就绪状态？一旦通道具备完成某个操作的条件，表示该通道的某个操作已经就绪， 就可以被 Selector 查询到，程序可以对通道进行对应的操作。比方说，某个 SocketChannel 通道可以连接到一个服务器，则处于“连接就绪”(OP_CONNECT)。 再比方说，一个 ServerSocketChannel 服务器通道准备好接收新进入的连接，则处于 “接收就绪”（OP_ACCEPT）状态。还比方说，一个有数据可读的通道，可以说是 “读就绪”(OP_READ)。一个等待写数据的通道可以说是“写就绪”(OP_WRITE)。\n\n#### 1.4 选择键(SelectionKey)\n（1）Channel 注册到后，并且一旦通道处于某种就绪的状态，就可以被选择器查询到。 这个工作，使用选择器 Selector 的 select（）方法完成。select 方法的作用，对感兴 趣的通道操作，进行就绪状态的查询。\n\n（2）Selector 可以不断的查询 Channel 中发生的操作的就绪状态。并且挑选感兴趣 的操作就绪状态。一旦通道有操作的就绪状态达成，并且是 Selector 感兴趣的操作， 就会被 Selector 选中，放入选择键集合中。\n\n（3）一个选择键，首先是包含了注册在 Selector 的通道操作的类型，比方说 SelectionKey.OP_READ。也包含了特定的通道与特定的选择器之间的注册关系。\n\n开发应用程序是，选择键是编程的关键。NIO 的编程，就是根据对应的选择键，进行 不同的业务逻辑处理。\n\n（4）选择键的概念，和事件的概念比较相似。一个选择键类似监听器模式里边的一个 事件。由于 Selector 不是事件触发的模式，而是主动去查询的模式，所以不叫事件 Event，而是叫 SelectionKey 选择键。\n\n### 2 Selector 的使用方法\n\n#### 2.1 Selector 的创建\n通过调用 Selector.open()方法创建一个 Selector 对象，如下：\n```java\n// 1、获取 Selector 选择器 \nSelector selector = Selector.open();\n```\n#### 2.2 注册 Channel 到 Selector\n要实现 Selector 管理 Channel，需要将 channel 注册到相应的 Selector 上\n```java\n// 1、获取 Selector 选择器 \nSelector selector = Selector.open(); \n// 2、获取通道 \nServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); \n// 3.设置为非阻塞 \nserverSocketChannel.configureBlocking(false); \n// 4、绑定连接 \nserverSocketChannel.bind(new InetSocketAddress(9999)); \n// 5、将通道注册到选择器上,并制定监听事件为：“接收”事件 \nserverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n```\n上面通过调用通道的 register()方法会将它注册到一个选择器上。 首先需要注意的是：\n\n（1）与 Selector 一起使用时，Channel 必须处于非阻塞模式下，否则将抛出异常 IllegalBlockingModeException。这意味着，FileChannel 不能与 Selector 一起使用，因 为 FileChannel 不能切换到非阻塞模式，而套接字相关的所有的通道都可以。 \n\n（2）一个通道，并没有一定要支持所有的四种操作。比如服务器通道 ServerSocketChannel 支持 Accept 接受操作，而 SocketChannel 客户端通道则不支持。 可以通过通道上的 validOps()方法，来获取特定通道下所有支持的操作集合。\n\n#### 2.3 轮询查询就绪操作\n\n（1）通过 Selector 的 select（）方法，可以查询出已经就绪的通道操作，这些就绪的 状态集合，包存在一个元素是 SelectionKey 对象的 Set 集合中。\n\n（2）下面是 Selector 几个重载的查询 select()方法：\n- select():阻塞到至少有一个通道在你注册的事件上就绪了。\n- select(long timeout)：和 select()一样，但最长阻塞事件为 timeout 毫秒。\n- selectNow():非阻塞，只要有通道就绪就立刻返回。\n\nselect()方法返回的 int 值，表示有多少通道已经就绪，更准确的说，是自前一次 select 方法以来到这一次 select 方法之间的时间段上，有多少通道变成就绪状态。\n\n例如：首次调用 select()方法，如果有一个通道变成就绪状态，返回了 1，若再次调用 select()方法，如果另一个通道就绪了，它会再次返回 1。如果对第一个就绪的 channel 没有做任何操作，现在就有两个就绪的通道，但在每次 select()方法调用之间， 只有一个通道就绪了。\n\n一旦调用 select()方法，并且返回值不为 0 时，在 Selector 中有一个 selectedKeys()方 法，用来访问已选择键集合，迭代集合的每一个选择键元素，根据就绪操作的类型， 完成对应的操作：\n```java\nSet selectedKeys = selector.selectedKeys(); \nIterator keyIterator = selectedKeys.iterator();\nwhile (iterator.hasNext()) {\n            SelectionKey key = iterator.next();\n            if (key.isAcceptable()) {\n                // a connection was accepted by a ServerSocketChannel.\n            } else if (key.isConnectable()) {\n                // a connection was established with a remote server.\n            } else if (key.isReadable()) {\n                // a channel is ready for reading\n            } else if (key.isWritable()) {\n                // a channel is ready for writing\n            }\n        }\n```\n#### 2.4 停止选择的方法\n选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能 会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在 select（）方法中 阻塞的线程。\n\nwakeup()方法 ：通过调用 Selector 对象的 wakeup（）方法让处在阻塞状态的 select()方法立刻返回该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中 的选择操作，那么下一次对 select()方法的一次调用将立即返回。\n\nclose()方法 ：通过 close（）方法关闭 Selector。\n\n该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似 wakeup（）），同时 使得注册到该 Selector 的所有 Channel 被注销，所有的键将被取消，但是 Channel 本身并不会关闭。\n\n### 3 NIO 编程步骤\n第一步：创建 Selector 选择器 \n第二步：创建 ServerSocketChannel 通道，并绑定监听端口 \n第三步：设置 Channel 通道是非阻塞模式 \n第四步：把 Channel 注册到 Socketor 选择器上，监听连接事件 \n第五步：调用 Selector 的 select 方法（循环调用），监测通道的就绪状况 \n第六步：调用 selectKeys 方法获取就绪 channel 集合 \n第七步：遍历就绪 channel 集合，判断就绪事件类型，实现具体的业务操作 \n第八步：根据业务，决定是否需要再次注册监听事件，重复执行第三步操作\n\n### 4 示例代码\n\n#### 4.1 服务端代码\n```java\n//服务端\n    @Test\n    public void serverDemo() throws Exception {\n        //获取服务端通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        //切换非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n        //创建buffer\n        ByteBuffer serverByteBuffer = ByteBuffer.allocate(1024);\n        //绑定端口号\n        serverSocketChannel.bind(new InetSocketAddress(9999));\n        //获取selector选择器\n        Selector selector = Selector.open();\n        //通道注册到选择器，\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        //选择器进行轮询\n        while (selector.select()>0){\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = selectionKeys.iterator();\n            while (iterator.hasNext()){\n                SelectionKey next = iterator.next();\n                //判断什么操作\n                if(next.isAcceptable()){\n                    //获取链接\n                    SocketChannel accept = serverSocketChannel.accept();\n                    //切换非阻塞模式\n                    accept.configureBlocking(false);\n                    //注册\n                    accept.register(selector,SelectionKey.OP_READ);\n                }else if(next.isReadable()){\n                    SocketChannel channel = (SocketChannel) next.channel();\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                    //读取数据\n                    int length =0;\n                    while ((length = channel.read(byteBuffer))>0){\n                        byteBuffer.flip();\n                        System.out.println(new String(byteBuffer.array(),0,length));\n                        byteBuffer.clear();\n                    }\n                }\n            }\n            iterator.remove();\n        }\n    }\n```\n#### 4.2 客户端代码\n```java\npublic static void main(String[] args) throws Exception{\n        //获取通道，绑定主机端口号\n        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\",9999));\n        //切换非阻塞模式\n        socketChannel.configureBlocking(false);\n\n        //创建buffer\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()){\n            String str = scanner.next();\n            //写入buffer数据\n            byteBuffer.put((new Date() +\"--->\"+str).getBytes(StandardCharsets.UTF_8));\n            //模式切换\n            byteBuffer.flip();\n            //写入通道\n            socketChannel.write(byteBuffer);\n            //关闭\n            byteBuffer.clear();\n        }\n\n    }\n```\n', '2022-10-09 10:56:26', '2022-10-09 15:59:38', '<h3><a id=\"1_Selector__0\"></a>1 Selector 简介</h3>\n<h4><a id=\"11_Selector__Channel__1\"></a>1.1 Selector 和 Channel 关系</h4>\n<p>Selector 一般称 为选择器 ，也可以翻译为 多路复用器 。它是 Java NIO 核心组件中 的一个，用于检查一个或多个 NIO Channel（通道）的状态是否处于可读、可写。如 此可以实现单线程管理多个 channels,也就是可以管理多个网络链接。</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/7ae9446e0bca4a518b305073e07475d0.png\" alt=\"image.png\" /></p>\n</div>\n<p>使用 Selector 的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个 线程，避免了线程上下文切换带来的开销。</p>\n<h4><a id=\"12_SelectableChannel_11\"></a>1.2 可选择通道(SelectableChannel)</h4>\n<p>（1）不是所有的 Channel 都可以被 Selector 复用的。比方说，FileChannel 就不能 被选择器复用。判断一个 Channel 能被 Selector 复用，有一个前提：判断他是否继承了一个抽象类 SelectableChannel。如果继承了 SelectableChannel，则可以被复 用，否则不能。</p>\n<p>（2）SelectableChannel 类提供了实现通道的可选择性所需要的公共方法。它是所有 支持就绪检查的通道类的父类。所有 socket 通道，都继承了 SelectableChannel 类 都是可选择的，包括从管道(Pipe)对象的中获得的通道。而 FileChannel 类，没有继 承 SelectableChannel，因此是不是可选通道。</p>\n<p>（3）一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。通 道和选择器之间的关系，使用注册的方式完成。SelectableChannel 可以被注册到 Selector 对象上，在注册的时候，需要指定通道的哪些操作，是 Selector 感兴趣的。</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/4f68bfeb91434f1eb900f948f52e0dae.png\" alt=\"image.png\" /></p>\n</div>\n<h4><a id=\"13_Channel__Selector_24\"></a>1.3 Channel 注册到 Selector</h4>\n<p>（1）使用 Channel.register（Selector sel，int ops）方法，将一个通道注册到一个 选择器时。第一个参数，指定通道要注册的选择器。第二个参数指定选择器需要查询 的通道操作。<br />\n（2）可以供选择器查询的通道操作，从类型来分，包括以下四种：</p>\n<ul>\n<li>可读 : SelectionKey.OP_READ</li>\n<li>可写 : SelectionKey.OP_WRITE</li>\n<li>连接 : SelectionKey.OP_CONNECT</li>\n<li>接收 : SelectionKey.OP_ACCEPT</li>\n</ul>\n<p>如果 Selector 对通道的多操作类型感兴趣，可以用“位或”操作符来实现： 比如：int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE ;</p>\n<p>（3）选择器查询的不是通道的操作，而是通道的某个操作的一种就绪状态。什么是操 作的就绪状态？一旦通道具备完成某个操作的条件，表示该通道的某个操作已经就绪， 就可以被 Selector 查询到，程序可以对通道进行对应的操作。比方说，某个 SocketChannel 通道可以连接到一个服务器，则处于“连接就绪”(OP_CONNECT)。 再比方说，一个 ServerSocketChannel 服务器通道准备好接收新进入的连接，则处于 “接收就绪”（OP_ACCEPT）状态。还比方说，一个有数据可读的通道，可以说是 “读就绪”(OP_READ)。一个等待写数据的通道可以说是“写就绪”(OP_WRITE)。</p>\n<h4><a id=\"14_SelectionKey_36\"></a>1.4 选择键(SelectionKey)</h4>\n<p>（1）Channel 注册到后，并且一旦通道处于某种就绪的状态，就可以被选择器查询到。 这个工作，使用选择器 Selector 的 select（）方法完成。select 方法的作用，对感兴 趣的通道操作，进行就绪状态的查询。</p>\n<p>（2）Selector 可以不断的查询 Channel 中发生的操作的就绪状态。并且挑选感兴趣 的操作就绪状态。一旦通道有操作的就绪状态达成，并且是 Selector 感兴趣的操作， 就会被 Selector 选中，放入选择键集合中。</p>\n<p>（3）一个选择键，首先是包含了注册在 Selector 的通道操作的类型，比方说 SelectionKey.OP_READ。也包含了特定的通道与特定的选择器之间的注册关系。</p>\n<p>开发应用程序是，选择键是编程的关键。NIO 的编程，就是根据对应的选择键，进行 不同的业务逻辑处理。</p>\n<p>（4）选择键的概念，和事件的概念比较相似。一个选择键类似监听器模式里边的一个 事件。由于 Selector 不是事件触发的模式，而是主动去查询的模式，所以不叫事件 Event，而是叫 SelectionKey 选择键。</p>\n<h3><a id=\"2_Selector__47\"></a>2 Selector 的使用方法</h3>\n<h4><a id=\"21_Selector__49\"></a>2.1 Selector 的创建</h4>\n<p>通过调用 Selector.open()方法创建一个 Selector 对象，如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">// 1、获取 Selector 选择器 </span>\n<span class=\"hljs-type\">Selector</span> <span class=\"hljs-variable\">selector</span> <span class=\"hljs-operator\">=</span> Selector.open();\n</code></div></pre>\n<h4><a id=\"22__Channel__Selector_55\"></a>2.2 注册 Channel 到 Selector</h4>\n<p>要实现 Selector 管理 Channel，需要将 channel 注册到相应的 Selector 上</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">// 1、获取 Selector 选择器 </span>\n<span class=\"hljs-type\">Selector</span> <span class=\"hljs-variable\">selector</span> <span class=\"hljs-operator\">=</span> Selector.open(); \n<span class=\"hljs-comment\">// 2、获取通道 </span>\n<span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">serverSocketChannel</span> <span class=\"hljs-operator\">=</span> ServerSocketChannel.open(); \n<span class=\"hljs-comment\">// 3.设置为非阻塞 </span>\nserverSocketChannel.configureBlocking(<span class=\"hljs-literal\">false</span>); \n<span class=\"hljs-comment\">// 4、绑定连接 </span>\nserverSocketChannel.bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">9999</span>)); \n<span class=\"hljs-comment\">// 5、将通道注册到选择器上,并制定监听事件为：“接收”事件 </span>\nserverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n</code></div></pre>\n<p>上面通过调用通道的 register()方法会将它注册到一个选择器上。 首先需要注意的是：</p>\n<p>（1）与 Selector 一起使用时，Channel 必须处于非阻塞模式下，否则将抛出异常 IllegalBlockingModeException。这意味着，FileChannel 不能与 Selector 一起使用，因 为 FileChannel 不能切换到非阻塞模式，而套接字相关的所有的通道都可以。</p>\n<p>（2）一个通道，并没有一定要支持所有的四种操作。比如服务器通道 ServerSocketChannel 支持 Accept 接受操作，而 SocketChannel 客户端通道则不支持。 可以通过通道上的 validOps()方法，来获取特定通道下所有支持的操作集合。</p>\n<h4><a id=\"23__75\"></a>2.3 轮询查询就绪操作</h4>\n<p>（1）通过 Selector 的 select（）方法，可以查询出已经就绪的通道操作，这些就绪的 状态集合，包存在一个元素是 SelectionKey 对象的 Set 集合中。</p>\n<p>（2）下面是 Selector 几个重载的查询 select()方法：</p>\n<ul>\n<li>select():阻塞到至少有一个通道在你注册的事件上就绪了。</li>\n<li>select(long timeout)：和 select()一样，但最长阻塞事件为 timeout 毫秒。</li>\n<li>selectNow():非阻塞，只要有通道就绪就立刻返回。</li>\n</ul>\n<p>select()方法返回的 int 值，表示有多少通道已经就绪，更准确的说，是自前一次 select 方法以来到这一次 select 方法之间的时间段上，有多少通道变成就绪状态。</p>\n<p>例如：首次调用 select()方法，如果有一个通道变成就绪状态，返回了 1，若再次调用 select()方法，如果另一个通道就绪了，它会再次返回 1。如果对第一个就绪的 channel 没有做任何操作，现在就有两个就绪的通道，但在每次 select()方法调用之间， 只有一个通道就绪了。</p>\n<p>一旦调用 select()方法，并且返回值不为 0 时，在 Selector 中有一个 selectedKeys()方 法，用来访问已选择键集合，迭代集合的每一个选择键元素，根据就绪操作的类型， 完成对应的操作：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">Set</span> <span class=\"hljs-variable\">selectedKeys</span> <span class=\"hljs-operator\">=</span> selector.selectedKeys(); \n<span class=\"hljs-type\">Iterator</span> <span class=\"hljs-variable\">keyIterator</span> <span class=\"hljs-operator\">=</span> selectedKeys.iterator();\n<span class=\"hljs-keyword\">while</span> (iterator.hasNext()) {\n            <span class=\"hljs-type\">SelectionKey</span> <span class=\"hljs-variable\">key</span> <span class=\"hljs-operator\">=</span> iterator.next();\n            <span class=\"hljs-keyword\">if</span> (key.isAcceptable()) {\n                <span class=\"hljs-comment\">// a connection was accepted by a ServerSocketChannel.</span>\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key.isConnectable()) {\n                <span class=\"hljs-comment\">// a connection was established with a remote server.</span>\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key.isReadable()) {\n                <span class=\"hljs-comment\">// a channel is ready for reading</span>\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key.isWritable()) {\n                <span class=\"hljs-comment\">// a channel is ready for writing</span>\n            }\n        }\n</code></div></pre>\n<h4><a id=\"24__105\"></a>2.4 停止选择的方法</h4>\n<p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能 会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在 select（）方法中 阻塞的线程。</p>\n<p>wakeup()方法 ：通过调用 Selector 对象的 wakeup（）方法让处在阻塞状态的 select()方法立刻返回该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中 的选择操作，那么下一次对 select()方法的一次调用将立即返回。</p>\n<p>close()方法 ：通过 close（）方法关闭 Selector。</p>\n<p>该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似 wakeup（）），同时 使得注册到该 Selector 的所有 Channel 被注销，所有的键将被取消，但是 Channel 本身并不会关闭。</p>\n<h3><a id=\"3_NIO__114\"></a>3 NIO 编程步骤</h3>\n<p>第一步：创建 Selector 选择器<br />\n第二步：创建 ServerSocketChannel 通道，并绑定监听端口<br />\n第三步：设置 Channel 通道是非阻塞模式<br />\n第四步：把 Channel 注册到 Socketor 选择器上，监听连接事件<br />\n第五步：调用 Selector 的 select 方法（循环调用），监测通道的就绪状况<br />\n第六步：调用 selectKeys 方法获取就绪 channel 集合<br />\n第七步：遍历就绪 channel 集合，判断就绪事件类型，实现具体的业务操作<br />\n第八步：根据业务，决定是否需要再次注册监听事件，重复执行第三步操作</p>\n<h3><a id=\"4__124\"></a>4 示例代码</h3>\n<h4><a id=\"41__126\"></a>4.1 服务端代码</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//服务端</span>\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">serverDemo</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">//获取服务端通道</span>\n        <span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">serverSocketChannel</span> <span class=\"hljs-operator\">=</span> ServerSocketChannel.open();\n        <span class=\"hljs-comment\">//切换非阻塞模式</span>\n        serverSocketChannel.configureBlocking(<span class=\"hljs-literal\">false</span>);\n        <span class=\"hljs-comment\">//创建buffer</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">serverByteBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n        <span class=\"hljs-comment\">//绑定端口号</span>\n        serverSocketChannel.bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">9999</span>));\n        <span class=\"hljs-comment\">//获取selector选择器</span>\n        <span class=\"hljs-type\">Selector</span> <span class=\"hljs-variable\">selector</span> <span class=\"hljs-operator\">=</span> Selector.open();\n        <span class=\"hljs-comment\">//通道注册到选择器，</span>\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        <span class=\"hljs-comment\">//选择器进行轮询</span>\n        <span class=\"hljs-keyword\">while</span> (selector.select()&gt;<span class=\"hljs-number\">0</span>){\n            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();\n            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();\n            <span class=\"hljs-keyword\">while</span> (iterator.hasNext()){\n                <span class=\"hljs-type\">SelectionKey</span> <span class=\"hljs-variable\">next</span> <span class=\"hljs-operator\">=</span> iterator.next();\n                <span class=\"hljs-comment\">//判断什么操作</span>\n                <span class=\"hljs-keyword\">if</span>(next.isAcceptable()){\n                    <span class=\"hljs-comment\">//获取链接</span>\n                    <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">accept</span> <span class=\"hljs-operator\">=</span> serverSocketChannel.accept();\n                    <span class=\"hljs-comment\">//切换非阻塞模式</span>\n                    accept.configureBlocking(<span class=\"hljs-literal\">false</span>);\n                    <span class=\"hljs-comment\">//注册</span>\n                    accept.register(selector,SelectionKey.OP_READ);\n                }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(next.isReadable()){\n                    <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> (SocketChannel) next.channel();\n                    <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">byteBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n                    <span class=\"hljs-comment\">//读取数据</span>\n                    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">length</span> <span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0</span>;\n                    <span class=\"hljs-keyword\">while</span> ((length = channel.read(byteBuffer))&gt;<span class=\"hljs-number\">0</span>){\n                        byteBuffer.flip();\n                        System.out.println(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(byteBuffer.array(),<span class=\"hljs-number\">0</span>,length));\n                        byteBuffer.clear();\n                    }\n                }\n            }\n            iterator.remove();\n        }\n    }\n</code></div></pre>\n<h4><a id=\"42__173\"></a>4.2 客户端代码</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception{\n        <span class=\"hljs-comment\">//获取通道，绑定主机端口号</span>\n        <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChannel</span> <span class=\"hljs-operator\">=</span> SocketChannel.open(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>,<span class=\"hljs-number\">9999</span>));\n        <span class=\"hljs-comment\">//切换非阻塞模式</span>\n        socketChannel.configureBlocking(<span class=\"hljs-literal\">false</span>);\n\n        <span class=\"hljs-comment\">//创建buffer</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">byteBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n\n        <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">scanner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);\n        <span class=\"hljs-keyword\">while</span> (scanner.hasNext()){\n            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> scanner.next();\n            <span class=\"hljs-comment\">//写入buffer数据</span>\n            byteBuffer.put((<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>() +<span class=\"hljs-string\">&quot;---&gt;&quot;</span>+str).getBytes(StandardCharsets.UTF_8));\n            <span class=\"hljs-comment\">//模式切换</span>\n            byteBuffer.flip();\n            <span class=\"hljs-comment\">//写入通道</span>\n            socketChannel.write(byteBuffer);\n            <span class=\"hljs-comment\">//关闭</span>\n            byteBuffer.clear();\n        }\n\n    }\n</code></div></pre>\n');
INSERT INTO `article_content` VALUES ('6ad6bbb7161e5ad89760b8ca830870ef', '### 1 IO概述\nIO 的操作方式通常分为几种：同步阻塞 BIO、同步非阻塞 NIO、异步非阻塞 AIO。\n\n- 在 JDK1.4 之前，我们建立网络连接的时候采用的是 BIO 模式。\n- Java NIO（New IO 或 Non Blocking IO）是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API。NIO 支持面向缓冲区的、基于通道的 IO 操作。 NIO 将以更加高效的方式进行文件的读写操作。BIO 与 NIO 一个比较重要的不同是， 我们使用 BIO 的时候往往会引入多线程，每个连接对应一个单独的线程；而 NIO 则是 使用单线程或者只使用少量的多线程，让连接共用一个线程。\n- AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。\n\n\n下面我们来详细介绍这几种 IO 方式\n\n### 2 阻塞 IO (BIO)\n阻塞 IO（BIO）是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，直至 有可供读取的数据或者数据能够写入。\n\n- 在 BIO 模式中，服务器会为每个客户端请求建立一个线程，由该线程单独负责 处理一个客户请求，这种模式虽然简单方便，但由于服务器为每个客户端的连接都采 用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，如果再有 用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。\n- 大多数情况下为了避免上述问题，都采用了线程池模型。也就是创建一个固定大 小的线程池，如果有客户端请求，就从线程池中取一个空闲线程来处理，当客户端处 理完操作之后，就会释放对线程的占用。因此这样就避免为每一个客户端都要创建线 程带来的资源浪费，使得线程可以重用。但线程池也有它的弊端，如果连接大多是长 连接，可能会导致在一段时间内，线程池中的线程都被占用，那么当再有客户端请求 连接时，由于没有空闲线程来处理，就会导致客户端连接失败。传统的 BIO 模式如下 图所示：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/86e940e7fb5e478aa334c15a9d8d8e8e.png)\n\n:::\n\n\n### 3 非阻塞 IO(NIO)\n基于 BIO 的各种弊端，在 JDK1.4 开始出现了高性能 IO 设计模式非阻塞 IO（NIO）。\n\n- NIO 采用非阻塞模式，基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，它 的实现过程是：会先对每个客户端注册感兴趣的事件，然后有一个线程专门去轮询每 个客户端是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理 完之后，便再转去继续轮询。如下图所示：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/33ee136a8a2d491887385a59a60c952a.png)\n\n:::\n\n\n- NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的事件， 如下图所示：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/bfd0b9ea9f8f4e72bdace86e7596c0ef.png)\n\n:::\n\n\n- NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被 注册到多路复用器上面，一个选择器线程可以同时处理成千上万个连接，系统不必创 建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/c1b3c7c99b8c4c70bacebc1db33a3b07.png)\n\n:::\n\n\n### 4 异步非阻塞 IO(AIO)\n- AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞 的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是说 AIO 模式不需要selector 操作，而是是事件驱动形式，也就是当客户端发送数据之后，会主动通知服 务器，接着服务器再进行读写操作。\n- Java 的 AIO API 其实就是 Proactor 模式的应用，和 Reactor 模式类似。 Reactor 和 Proactor 模式的主要区别就是真正的读取和写入操作是有谁来完成的， Reactor 中需要应用程序自己读取或者写入数据，而 Proactor 模式中，应用程序不需 要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存 区或者写入缓存区到真正的 IO 设备。\n\n### 5 NIO 概述\nJava NIO 由以下几个核心部分组成：\n1. Channels\n2. Buffers\n3. Selectors\n\n虽然 Java NIO 中除此之外还有很多类和组件，但 Channel，Buffer 和 Selector 构成 了核心的 API。其它组件，如 Pipe 和 FileLock，只不过是与三个核心组件共同使用的 工具类。\n\n#### 5.1 Channel\n首先说一下 Channel，可以翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不 多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream.而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。\n\nNIO 中的 Channel 的主要实现有：FileChannel、DatagramChannel、 SocketChannel 和 ServerSocketChannel，这里看名字就可以猜出个所以然来：分别 可以对应文件 IO、UDP 和 TCP（Server 和 Client）。\n\n#### 5.2 Buffer\nNIO 中的关键 Buffer 实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。\n\n#### 5.3 Selector\nSelector 运行单线程处理多个 Channel，如果你的应用打开了多个通道，但每个连接 的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中。要使用 Selector, 得向 Selector 注册 Channel，然后调用它的 select()方法。这个方法会一直 阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件， 事件的例子有如新的连接进来、数据接收等。\n\n#### 5.4 Channel Buffer Selector 三者关系\n\n- 一个 Channel 就像一个流，只是 Channel 是双向的，Channel 读数据到 Buffer， Buffer 写数据到 Channel。\n\n\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/917086f4944c4bb1b15cc4e756622905.png)\n\n:::\n\n\n- 一个 selector 允许一个线程处理多个 channel。\n\n\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/0209d1cac2b74cf5bd7345fd87888c9b.png)\n\n:::\n', '2022-09-30 14:45:15', '2022-09-30 15:13:52', '<h3><a id=\"1_IO_0\"></a>1 IO概述</h3>\n<p>IO 的操作方式通常分为几种：同步阻塞 BIO、同步非阻塞 NIO、异步非阻塞 AIO。</p>\n<ul>\n<li>在 JDK1.4 之前，我们建立网络连接的时候采用的是 BIO 模式。</li>\n<li>Java NIO（New IO 或 Non Blocking IO）是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API。NIO 支持面向缓冲区的、基于通道的 IO 操作。 NIO 将以更加高效的方式进行文件的读写操作。BIO 与 NIO 一个比较重要的不同是， 我们使用 BIO 的时候往往会引入多线程，每个连接对应一个单独的线程；而 NIO 则是 使用单线程或者只使用少量的多线程，让连接共用一个线程。</li>\n<li>AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。</li>\n</ul>\n<p>下面我们来详细介绍这几种 IO 方式</p>\n<h3><a id=\"2__IO_BIO_10\"></a>2 阻塞 IO (BIO)</h3>\n<p>阻塞 IO（BIO）是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，直至 有可供读取的数据或者数据能够写入。</p>\n<ul>\n<li>在 BIO 模式中，服务器会为每个客户端请求建立一个线程，由该线程单独负责 处理一个客户请求，这种模式虽然简单方便，但由于服务器为每个客户端的连接都采 用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，如果再有 用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。</li>\n<li>大多数情况下为了避免上述问题，都采用了线程池模型。也就是创建一个固定大 小的线程池，如果有客户端请求，就从线程池中取一个空闲线程来处理，当客户端处 理完操作之后，就会释放对线程的占用。因此这样就避免为每一个客户端都要创建线 程带来的资源浪费，使得线程可以重用。但线程池也有它的弊端，如果连接大多是长 连接，可能会导致在一段时间内，线程池中的线程都被占用，那么当再有客户端请求 连接时，由于没有空闲线程来处理，就会导致客户端连接失败。传统的 BIO 模式如下 图所示：</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/86e940e7fb5e478aa334c15a9d8d8e8e.png\" alt=\"image.png\" /></p>\n</div>\n<h3><a id=\"3__IONIO_22\"></a>3 非阻塞 IO(NIO)</h3>\n<p>基于 BIO 的各种弊端，在 JDK1.4 开始出现了高性能 IO 设计模式非阻塞 IO（NIO）。</p>\n<ul>\n<li>NIO 采用非阻塞模式，基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，它 的实现过程是：会先对每个客户端注册感兴趣的事件，然后有一个线程专门去轮询每 个客户端是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理 完之后，便再转去继续轮询。如下图所示：</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/33ee136a8a2d491887385a59a60c952a.png\" alt=\"image.png\" /></p>\n</div>\n<ul>\n<li>NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的事件， 如下图所示：</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/bfd0b9ea9f8f4e72bdace86e7596c0ef.png\" alt=\"image.png\" /></p>\n</div>\n<ul>\n<li>NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被 注册到多路复用器上面，一个选择器线程可以同时处理成千上万个连接，系统不必创 建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/c1b3c7c99b8c4c70bacebc1db33a3b07.png\" alt=\"image.png\" /></p>\n</div>\n<h3><a id=\"4__IOAIO_49\"></a>4 异步非阻塞 IO(AIO)</h3>\n<ul>\n<li>AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞 的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是说 AIO 模式不需要selector 操作，而是是事件驱动形式，也就是当客户端发送数据之后，会主动通知服 务器，接着服务器再进行读写操作。</li>\n<li>Java 的 AIO API 其实就是 Proactor 模式的应用，和 Reactor 模式类似。 Reactor 和 Proactor 模式的主要区别就是真正的读取和写入操作是有谁来完成的， Reactor 中需要应用程序自己读取或者写入数据，而 Proactor 模式中，应用程序不需 要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存 区或者写入缓存区到真正的 IO 设备。</li>\n</ul>\n<h3><a id=\"5_NIO__53\"></a>5 NIO 概述</h3>\n<p>Java NIO 由以下几个核心部分组成：</p>\n<ol>\n<li>Channels</li>\n<li>Buffers</li>\n<li>Selectors</li>\n</ol>\n<p>虽然 Java NIO 中除此之外还有很多类和组件，但 Channel，Buffer 和 Selector 构成 了核心的 API。其它组件，如 Pipe 和 FileLock，只不过是与三个核心组件共同使用的 工具类。</p>\n<h4><a id=\"51_Channel_61\"></a>5.1 Channel</h4>\n<p>首先说一下 Channel，可以翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不 多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream.而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>\n<p>NIO 中的 Channel 的主要实现有：FileChannel、DatagramChannel、 SocketChannel 和 ServerSocketChannel，这里看名字就可以猜出个所以然来：分别 可以对应文件 IO、UDP 和 TCP（Server 和 Client）。</p>\n<h4><a id=\"52_Buffer_66\"></a>5.2 Buffer</h4>\n<p>NIO 中的关键 Buffer 实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。</p>\n<h4><a id=\"53_Selector_69\"></a>5.3 Selector</h4>\n<p>Selector 运行单线程处理多个 Channel，如果你的应用打开了多个通道，但每个连接 的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中。要使用 Selector, 得向 Selector 注册 Channel，然后调用它的 select()方法。这个方法会一直 阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件， 事件的例子有如新的连接进来、数据接收等。</p>\n<h4><a id=\"54_Channel_Buffer_Selector__72\"></a>5.4 Channel Buffer Selector 三者关系</h4>\n<ul>\n<li>一个 Channel 就像一个流，只是 Channel 是双向的，Channel 读数据到 Buffer， Buffer 写数据到 Channel。</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/917086f4944c4bb1b15cc4e756622905.png\" alt=\"image.png\" /></p>\n</div>\n<ul>\n<li>一个 selector 允许一个线程处理多个 channel。</li>\n</ul>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/0209d1cac2b74cf5bd7345fd87888c9b.png\" alt=\"image.png\" /></p>\n</div>\n');
INSERT INTO `article_content` VALUES ('6bb0a02f479905e24398dfe187c49641', '### 1 Path\n#### 1.1 Path 简介\nJava Path 接口是 Java NIO 更新的一部分，同 Java NIO 一起已经包括在 Java6 和 Java7 中。Java Path 接口是在 Java7 中添加到 Java NIO 的。Path 接口位于 java.nio.file 包中，所以 Path 接口的完全限定名称为 java.nio.file.Path。\n\nJava Path 实例表示文件系统中的路径。一个路径可以指向一个文件或一个目录。路径 可以是绝对路径，也可以是相对路径。绝对路径包含从文件系统的根目录到它指向的 文件或目录的完整路径。相对路径包含相对于其他路径的文件或目录的路径。\n\n在许多方面，java.nio.file.Path 接口类似于 java.io.File 类，但是有一些差别。不过， 在许多情况下，可以使用 Path 接口来替换 File 类的使用。\n\n#### 1.2 创建 Path 实例\n\n使用 java.nio.file.Path 实例必须创建一个 Path 实例。可以使用 Paths 类 (java.nio.file.Paths)中的静态方法 Paths.get()来创建路径实例。\n\n示例代码:\n\n```java\npublic static void main(String[] args) {\n        //创建Path实例\n        Path path = Paths.get(\"d:\\\\111.txt\");\n    }\n```\n上述代码，可以理解为，Paths.get()方法是 Path 实例的工厂方法。\n\n#### 1.3 创建绝对路径\n\n（1）创建绝对路径，通过调用 Paths.get()方法，给定绝对路径文件作为参数来完成。\n\n示例代码：\n```java\nPath path = Paths.get(\"d:\\\\atguigu\\\\001.txt\");\n```\n上述代码中，绝对路径是 d:\\atguigu\\001.txt。在 Java 字符串中， \\是一个转义字符， 需要编写\\\\，告诉 Java 编译器在字符串中写入一个\\字符。\n\n（2）如果在 Linux、MacOS 等操作字体上，上面的绝对路径可能如下:\n\n```java\nPath path = Paths.get(\"/home/jakobjenkov/myfile.txt\");\n```\n\n绝对路径现在为/home/jakobjenkov/myfile.txt.\n\n（3）如果在 Windows 机器上使用了从/开始的路径，那么路径将被解释为相对于当 前驱动器。\n\n#### 1.4 创建相对路径\nJava NIO Path 类也可以用于处理相对路径。您可以使用 Paths.get(basePath, relativePath)方法创建一个相对路径。\n\n示例代码:\n\n```java\n//代码 1 \nPath projects = Paths.get(\"d:\\\\atguigu\", \"projects\"); \n//代码 2 \nPath file = Paths.get(\"d:\\\\atguigu\", \"projects\\\\002.txt\");\n```\n代码 1 创建了一个 Java Path 的实例，指向路径(目录):d:\\atguigu\\projects \n代码 2 创建了一个 Path 的实例，指向路径(文件):d:\\atguigu\\projects\\002.txt\n\n#### 1.5 Path.normalize()\nPath 接口的 normalize()方法可以使路径标准化。标准化意味着它将移除所有在路径 字符串的中间的.和..代码，并解析路径字符串所引用的路径。\n\nPath.normalize()示例:\n```java\nString originalPath = \"d:\\\\atguigu\\\\projects\\\\..\\\\yygh-project\"; \nPath path1 = Paths.get(originalPath); \nSystem.out.println(\"path1 = \" + path1); \nPath path2 = path1.normalize(); \nSystem.out.println(\"path2 = \" + path2);\n```\n输出结果：标准化的路径不包含 projects\\..部分\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/99340617865d41659cbde12e476c8b64.png)\n\n:::\n', '2022-10-09 17:29:00', '2022-10-09 17:29:00', '<h3><a id=\"1_Path_0\"></a>1 Path</h3>\n<h4><a id=\"11_Path__1\"></a>1.1 Path 简介</h4>\n<p>Java Path 接口是 Java NIO 更新的一部分，同 Java NIO 一起已经包括在 Java6 和 Java7 中。Java Path 接口是在 Java7 中添加到 Java NIO 的。Path 接口位于 java.nio.file 包中，所以 Path 接口的完全限定名称为 java.nio.file.Path。</p>\n<p>Java Path 实例表示文件系统中的路径。一个路径可以指向一个文件或一个目录。路径 可以是绝对路径，也可以是相对路径。绝对路径包含从文件系统的根目录到它指向的 文件或目录的完整路径。相对路径包含相对于其他路径的文件或目录的路径。</p>\n<p>在许多方面，java.nio.file.Path 接口类似于 java.io.File 类，但是有一些差别。不过， 在许多情况下，可以使用 Path 接口来替换 File 类的使用。</p>\n<h4><a id=\"12__Path__8\"></a>1.2 创建 Path 实例</h4>\n<p>使用 java.nio.file.Path 实例必须创建一个 Path 实例。可以使用 Paths 类 (java.nio.file.Paths)中的静态方法 Paths.get()来创建路径实例。</p>\n<p>示例代码:</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">//创建Path实例</span>\n        <span class=\"hljs-type\">Path</span> <span class=\"hljs-variable\">path</span> <span class=\"hljs-operator\">=</span> Paths.get(<span class=\"hljs-string\">&quot;d:\\\\111.txt&quot;</span>);\n    }\n</code></div></pre>\n<p>上述代码，可以理解为，Paths.get()方法是 Path 实例的工厂方法。</p>\n<h4><a id=\"13__22\"></a>1.3 创建绝对路径</h4>\n<p>（1）创建绝对路径，通过调用 Paths.get()方法，给定绝对路径文件作为参数来完成。</p>\n<p>示例代码：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">Path</span> <span class=\"hljs-variable\">path</span> <span class=\"hljs-operator\">=</span> Paths.get(<span class=\"hljs-string\">&quot;d:\\\\atguigu\\\\001.txt&quot;</span>);\n</code></div></pre>\n<p>上述代码中，绝对路径是 d:\\atguigu\\001.txt。在 Java 字符串中， \\是一个转义字符， 需要编写\\，告诉 Java 编译器在字符串中写入一个\\字符。</p>\n<p>（2）如果在 Linux、MacOS 等操作字体上，上面的绝对路径可能如下:</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">Path</span> <span class=\"hljs-variable\">path</span> <span class=\"hljs-operator\">=</span> Paths.get(<span class=\"hljs-string\">&quot;/home/jakobjenkov/myfile.txt&quot;</span>);\n</code></div></pre>\n<p>绝对路径现在为/home/jakobjenkov/myfile.txt.</p>\n<p>（3）如果在 Windows 机器上使用了从/开始的路径，那么路径将被解释为相对于当 前驱动器。</p>\n<h4><a id=\"14__42\"></a>1.4 创建相对路径</h4>\n<p>Java NIO Path 类也可以用于处理相对路径。您可以使用 Paths.get(basePath, relativePath)方法创建一个相对路径。</p>\n<p>示例代码:</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//代码 1 </span>\n<span class=\"hljs-type\">Path</span> <span class=\"hljs-variable\">projects</span> <span class=\"hljs-operator\">=</span> Paths.get(<span class=\"hljs-string\">&quot;d:\\\\atguigu&quot;</span>, <span class=\"hljs-string\">&quot;projects&quot;</span>); \n<span class=\"hljs-comment\">//代码 2 </span>\n<span class=\"hljs-type\">Path</span> <span class=\"hljs-variable\">file</span> <span class=\"hljs-operator\">=</span> Paths.get(<span class=\"hljs-string\">&quot;d:\\\\atguigu&quot;</span>, <span class=\"hljs-string\">&quot;projects\\\\002.txt&quot;</span>);\n</code></div></pre>\n<p>代码 1 创建了一个 Java Path 的实例，指向路径(目录):d:\\atguigu\\projects<br />\n代码 2 创建了一个 Path 的实例，指向路径(文件):d:\\atguigu\\projects\\002.txt</p>\n<h4><a id=\"15_Pathnormalize_56\"></a>1.5 Path.normalize()</h4>\n<p>Path 接口的 normalize()方法可以使路径标准化。标准化意味着它将移除所有在路径 字符串的中间的.和…代码，并解析路径字符串所引用的路径。</p>\n<p>Path.normalize()示例:</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">originalPath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;d:\\\\atguigu\\\\projects\\\\..\\\\yygh-project&quot;</span>; \n<span class=\"hljs-type\">Path</span> <span class=\"hljs-variable\">path1</span> <span class=\"hljs-operator\">=</span> Paths.get(originalPath); \nSystem.out.println(<span class=\"hljs-string\">&quot;path1 = &quot;</span> + path1); \n<span class=\"hljs-type\">Path</span> <span class=\"hljs-variable\">path2</span> <span class=\"hljs-operator\">=</span> path1.normalize(); \nSystem.out.println(<span class=\"hljs-string\">&quot;path2 = &quot;</span> + path2);\n</code></div></pre>\n<p>输出结果：标准化的路径不包含 projects…部分</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/99340617865d41659cbde12e476c8b64.png\" alt=\"image.png\" /></p>\n</div>\n');
INSERT INTO `article_content` VALUES ('7d9a6f525ea2d6778e3b2a58a2d985a7', '# 一、使用SDK\n在OSS的概览页右下角找到“Bucket管理”，点击“OSS学习路径”\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/18402bdab80543b5b73a7185e0e95f07.png)\n点击“Java SDK”进入SDK开发文档\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d629efc794464f7f9b4684e87b7e3248.png)\n# 二、创建测试项目\n## 1、创建Maven项目\ncom.jzj\naliyun-oss\n## 2、配置pom\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/f88271f5e6e5490e86323f6065d01995.png)\n```java\n<dependencies>\n    <!--aliyunOSS-->\n    <dependency>\n        <groupId>com.aliyun.oss</groupId>\n        <artifactId>aliyun-sdk-oss</artifactId>\n        <version>3.10.2</version>\n    </dependency>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n</dependencies>\n```\n# 三、测试用例\n## 1、创建Bucket\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4f8eb2f9256b4e369aaf5d60ecfca784.png)\n```java\npackage com.atguigu.aliyunoss;\npublic class OSSTest {\n    // Endpoint以杭州为例，其它Region请按实际情况填写。\n    String endpoint = \"your endpoint\";\n    // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。\n    String accessKeyId = \"your accessKeyId\";\n    String accessKeySecret = \"your accessKeySecret\";\n    String bucketName = \"srb-file\";\n    @Test\n    public void testCreateBucket() {\n        \n        // 创建OSSClient实例。\n        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\n        // 创建存储空间。\n        ossClient.createBucket(bucketName);\n        // 关闭OSSClient。\n        ossClient.shutdown();\n    }\n}\n```\n## 2、判断bucket是否存在\n```java\n@Test\npublic void testExist() {\n    // 创建OSSClient实例。\n    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\n    boolean exists = ossClient.doesBucketExist(bucketName);\n    System.out.println(exists);\n    // 关闭OSSClient。\n    ossClient.shutdown();\n}\n```\n## 3、设置bucket访问权限\n```java\n@Test\npublic void testAccessControl() {\n    // 创建OSSClient实例。\n    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\n    // 设置存储空间的访问权限为：公共读。\n    ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead);\n    // 关闭OSSClient。\n    ossClient.shutdown();\n}\n```\n\n', '2022-09-26 09:21:55', '2022-09-26 10:07:00', '<h1><a id=\"SDK_0\"></a>一、使用SDK</h1>\n<p>在OSS的概览页右下角找到“Bucket管理”，点击“OSS学习路径”<br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/18402bdab80543b5b73a7185e0e95f07.png\" alt=\"image.png\" /><br />\n点击“Java SDK”进入SDK开发文档<br />\n<img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d629efc794464f7f9b4684e87b7e3248.png\" alt=\"image.png\" /></p>\n<h1><a id=\"_5\"></a>二、创建测试项目</h1>\n<h2><a id=\"1Maven_6\"></a>1、创建Maven项目</h2>\n<p>com.jzj<br />\naliyun-oss</p>\n<h2><a id=\"2pom_9\"></a>2、配置pom</h2>\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/f88271f5e6e5490e86323f6065d01995.png\" alt=\"image.png\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">&lt;dependencies&gt;\n    &lt;!--aliyunOSS--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;\n        &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;\n        &lt;version&gt;<span class=\"hljs-number\">3.10</span><span class=\"hljs-number\">.2</span>&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;/groupId&gt;\n        &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;version&gt;<span class=\"hljs-number\">4.12</span>&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></div></pre>\n<h1><a id=\"_26\"></a>三、测试用例</h1>\n<h2><a id=\"1Bucket_27\"></a>1、创建Bucket</h2>\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4f8eb2f9256b4e369aaf5d60ecfca784.png\" alt=\"image.png\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.atguigu.aliyunoss;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OSSTest</span> {\n    <span class=\"hljs-comment\">// Endpoint以杭州为例，其它Region请按实际情况填写。</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">endpoint</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;your endpoint&quot;</span>;\n    <span class=\"hljs-comment\">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">accessKeyId</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;your accessKeyId&quot;</span>;\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">accessKeySecret</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;your accessKeySecret&quot;</span>;\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">bucketName</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;srb-file&quot;</span>;\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testCreateBucket</span><span class=\"hljs-params\">()</span> {\n        \n        <span class=\"hljs-comment\">// 创建OSSClient实例。</span>\n        <span class=\"hljs-type\">OSS</span> <span class=\"hljs-variable\">ossClient</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);\n        <span class=\"hljs-comment\">// 创建存储空间。</span>\n        ossClient.createBucket(bucketName);\n        <span class=\"hljs-comment\">// 关闭OSSClient。</span>\n        ossClient.shutdown();\n    }\n}\n</code></div></pre>\n<h2><a id=\"2bucket_50\"></a>2、判断bucket是否存在</h2>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testExist</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-comment\">// 创建OSSClient实例。</span>\n    <span class=\"hljs-type\">OSS</span> <span class=\"hljs-variable\">ossClient</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);\n    <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">exists</span> <span class=\"hljs-operator\">=</span> ossClient.doesBucketExist(bucketName);\n    System.out.println(exists);\n    <span class=\"hljs-comment\">// 关闭OSSClient。</span>\n    ossClient.shutdown();\n}\n</code></div></pre>\n<h2><a id=\"3bucket_62\"></a>3、设置bucket访问权限</h2>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testAccessControl</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-comment\">// 创建OSSClient实例。</span>\n    <span class=\"hljs-type\">OSS</span> <span class=\"hljs-variable\">ossClient</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);\n    <span class=\"hljs-comment\">// 设置存储空间的访问权限为：公共读。</span>\n    ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead);\n    <span class=\"hljs-comment\">// 关闭OSSClient。</span>\n    ossClient.shutdown();\n}\n</code></div></pre>\n');
INSERT INTO `article_content` VALUES ('8556d1aadfebf82abaa7e2159d499d8b', '### 1 Buffer 简介\nJava NIO 中的 Buffer 用于和 NIO 通道进行交互。数据是从通道读入缓冲区，从缓冲 区写入到通道中的。\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/ff63cf22b4fb456fa17b1bd67c58204d.png)\n\n:::\n\n缓冲区 ==本质上是一块可以写入数据，然后可以从中读取数据的内存== 。这块内存被包装 成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。缓冲区实际上是 一个容器对象，更直接的说，其实就是一个数组，==在 NIO 库中，所有数据都是用缓冲 区处理的== 。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到 缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流 I/O 系统中，所有数据都是直接写入或者直接将数据读取到 Stream 对象中。 在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer，最常用的就是 ByteBuffer， 对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应，它们之间的继 承关系如下图所示：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/e77b8d6b861b430c9dec09ed3d4b54e3.png)\n\n:::\n\n### 2 Buffer 的基本用法\n\n使用 Buffer 读写数据，一般遵循以下四个步骤：\n- 写入数据到 Buffer\n- 调用 flip()方法\n- 从 Buffer 中读取数据\n- 调用 clear()方法或者 compact()方法\n\n\n当向 buffer 写入数据时，buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip()方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 buffer 的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有 两种方式能清空缓冲区：调用 clear()或 compact()方法。clear()方法会清空整个缓冲 区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起 始处，新写入的数据将放到缓冲区未读数据的后面。\n\n使用 Buffer 的例子：\n```java\npublic class BufferDemo01 {\n    @Test\n    public void buffer01() throws Exception {\n        //FileChannel\n        RandomAccessFile aFile = new RandomAccessFile(\"d:\\\\111.txt\",\"rw\");\n        FileChannel channel = aFile.getChannel();\n        //创建buffer,大小\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        //读\n        int bytesRead = channel.read(buffer);\n        while (bytesRead != -1){\n            //read模式\n            buffer.flip();\n            while (buffer.hasRemaining()){\n                System.out.println((char)buffer.get());\n            }\n            buffer.clear();\n            bytesRead = channel.read(buffer);\n        }\n        aFile.close();\n    }\n\n    @Test\n    public void buffer02() throws Exception{\n        //创建buffer\n        IntBuffer buffer = IntBuffer.allocate(8);\n        //buffer 放\n        for (int i = 0; i < buffer.capacity(); i++) {\n            int j =2*(i+1);\n            buffer.put(j);\n        }\n        //重置缓冲区\n        buffer.flip();\n        //获取\n        while (buffer.hasRemaining()){\n            int i = buffer.get();\n            System.out.println(i+\" \");\n        }\n    }\n}\n```\n### 3 Buffer 的 capacity、position 和 limit\n为了理解 Buffer 的工作原理，需要熟悉它的三个属性：\n- Capacity\n- Position\n- limit\n\nposition 和 limit 的含义取决于 Buffer 处在读模式还是写模式。不管 Buffer 处在什么 模式，capacity 的含义总是一样的。\n这里有一个关于 capacity，position 和 limit 在读写模式中的说明\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/1d35274b372541158b8b959ff27ddeb1.png)\n\n:::\n\n- capacity\n作为一个内存块，Buffer 有一个固定的大小值，也叫“capacity”.你只能往里写 capacity 个 byte、long，char 等类型。一旦 Buffer 满了，需要将其清空（通过读数 据或者清除数据）才能继续写数据往里写数据。\n- position\n1）写数据到 Buffer 中时，position 表示写入数据的当前位置，position 的初始值为 0。当一个 byte、long 等数据写到 Buffer 后， position 会向下移动到下一个可插入 数据的 Buffer 单元。position 最大可为 capacity – 1（因为 position 的初始值为 0）。\n2）读数据到 Buffer 中时，position 表示读入数据的当前位置，如 position=2 时表 示已开始读入了 3 个 byte，或从第 3 个 byte 开始读取。通过 ByteBuffer.flip()切换到 读模式时 position 会被重置为 0，当 Buffer 从 position 读入数据后，position 会下 移到下一个可读入的数据 Buffer 单元。\n\n- limit\n1）写数据时，limit 表示可对 Buffer 最多写入多少个数据。写模式下，limit 等于 Buffer 的 capacity。\n2）读数据时，limit 表示 Buffer 里有多少可读数据（not null 的数据），因此能读到 之前写入的所有数据（limit 被设置成已写数据的数量，这个值在写模式下就是 position）。\n\n### 4 Buffer 的类型\nJava NIO 有以下 Buffer 类型\n- ByteBuffer\n- MappedByteBuffer\n- CharBuffer\n- DoubleBuffer\n- FloatBuffer\n- IntBuffer\n- LongBuffer\n- ShortBuffer\n\n\n这些 Buffer 类型代表了不同的数据类型。换句话说，就是可以通过 char，short，int， long，float 或 double 类型来操作缓冲区中的字节。\n\n### 5 Buffer 分配和写数据\n#### 5.1 Buffer 分配\n要想获得一个 Buffer 对象首先要进行分配。 每一个 Buffer 类都有一个 allocate 方法。 下面是一个分配 48 字节 capacity 的 ByteBuffer 的例子。\n```java\nByteBuffer buf = ByteBuffer.allocate(48);\n```\n这是分配一个可存储 1024 个字符的 CharBuffer：\n```java\nCharBuffer buf = CharBuffer.allocate(1024);\n```\n#### 5.2 向 Buffer 中写数据\n写数据到 Buffer 有两种方式：\n（1）从 Channel 写到 Buffer。\n（2）通过 Buffer 的 put()方法写到 Buffer 里。\n从 Channel 写到 Buffer 的例子\n```java\nint bytesRead = inChannel.read(buf); //read into buffer\n```\n通过 put 方法写 Buffer 的例子：\n```java\nbuf.put(127);\n```\nput 方法有很多版本，允许你以不同的方式把数据写入到 Buffer 中。例如， 写到一个 指定的位置，或者把一个字节数组写入到 Buffer\n#### 5.3 flip()方法\nflip 方法将 Buffer 从写模式切换到读模式。调用 flip()方法会将 position 设回 0，并 将 limit 设置成之前 position 的值。换句话说，position 现在用于标记读的位置， limit 表示之前写进了多少个 byte、char 等 （现在能读取多少个 byte、char 等）。\n\n### 6 从 Buffer 中读取数据\n从 Buffer 中读取数据有两种方式：\n（1）从 Buffer 读取数据到 Channel。 \n（2）使用 get()方法从 Buffer 中读取数据。\n从 Buffer 读取数据到 Channel 的例子：\n```java\n//read from buffer into channel. \nint bytesWritten = inChannel.write(buf);\n```\n使用 get()方法从 Buffer 中读取数据的例子\n```java\nbyte aByte = buf.get();\n```\nget 方法有很多版本，允许你以不同的方式从 Buffer 中读取数据。例如，从指定 position 读取，或者从 Buffer 中读取数据到字节数组。\n\n### 7 Buffer 几个方法\n#### 7.1 rewind()方法\nBuffer.rewind()将 position 设回 0，所以你可以重读 Buffer 中的所有数据。limit 保 持不变，仍然表示能从 Buffer 中读取多少个元素（byte、char 等）。\n\n#### 7.2 clear()与 compact()方法\n一旦读完 Buffer 中的数据，需要让 Buffer 准备好再次被写入。可以通过 clear()或 compact()方法来完成。\n\n如果调用的是 clear()方法，position 将被设回 0，limit 被设置成 capacity 的值。换 句话说，Buffer 被清空了。Buffer 中的数据并未清除，只是这些标记告诉我们可以从 哪里开始往 Buffer 里写数据。\n\n如果 Buffer 中有一些未读的数据，调用 clear()方法，数据将“被遗忘”，意味着不再 有任何标记会告诉你哪些数据被读过，哪些还没有。\n\n如果 Buffer 中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据， 那么使用 compact()方法。\n\ncompact()方法将所有未读的数据拷贝到 Buffer 起始处。然后将 position 设到最后一 个未读元素正后面。limit 属性依然像 clear()方法一样，设置成 capacity。现在 Buffer 准备好写数据了，但是不会覆盖未读的数据。\n\n#### 7.3 mark()与 reset()方法\n通过调用 Buffer.mark()方法，可以标记 Buffer 中的一个特定 position。之后可以通 过调用 Buffer.reset()方法恢复到这个 position。例如：\n```java\nbuffer.mark(); \n//call buffer.get() a couple of times, e.g. during parsing. buffer.reset();\n//set position back to mark.\n```\n### 8 缓冲区操作\n#### 8.1 缓冲区分片\n在 NIO 中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象 来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的 缓冲区与创建的子缓冲区在底层数组层面上是数据共享的，也就是说，子缓冲区相当 于是现有缓冲区的一个视图窗口。调用 slice()方法可以创建一个子缓冲区。\n\n```java\n//缓冲区分片\n    @Test\n    public void test01(){\n        ByteBuffer buffer = ByteBuffer.allocate(10);\n        for (int i = 0; i < buffer.capacity(); i++) {\n            buffer.put((byte)i);\n        }\n        //创建子缓冲区\n        buffer.position(3);\n        buffer.limit(7);\n        ByteBuffer slice = buffer.slice();\n\n        //改变子缓冲区内容\n        for (int i = 0; i < slice.capacity(); i++) {\n            byte b = slice.get(i);\n            b*=10;\n            slice.put(i,b);\n        }\n        buffer.position(0);\n        buffer.limit(buffer.capacity());\n        while (buffer.remaining()>0){\n            System.out.println(buffer.get());\n        }\n    }\n```\n\n#### 8.2 只读缓冲区\n\n只读缓冲区非常简单，可以读取它们，但是不能向它们写入数据。可以通过调用缓冲 区的 asReadOnlyBuffer()方法，将任何常规缓冲区转 换为只读缓冲区，这个方法返回 一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如 果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：\n\n```java\n//只读缓冲区\n    @Test\n    public void test02(){\n        ByteBuffer buffer = ByteBuffer.allocate(10);\n        for (int i = 0; i < buffer.capacity(); i++) {\n            buffer.put((byte)i);\n        }\n        //创建只读缓冲区\n        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();\n\n        for (int i = 0; i < buffer.capacity(); i++) {\n            byte b = buffer.get(i);\n            b*=10;\n            buffer.put(i,b);\n        }\n        readOnlyBuffer.position(0);\n        readOnlyBuffer.limit(buffer.capacity());\n        while (readOnlyBuffer.remaining()>0){\n            System.out.println(readOnlyBuffer.get());\n        }\n    }\n```\n如果尝试修改只读缓冲区的内容，则会报 ReadOnlyBufferException 异常。只读缓冲 区对于保护数据很有用。在将缓冲区传递给某个 对象的方法时，无法知道这个方法是 否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只 可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区。\n\n#### 8.3 直接缓冲区\n直接缓冲区是为加快 I/O 速度，使用一种特殊方式为其分配内存的缓冲区，JDK 文档 中的描述为：给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)， 尝试避免将缓冲区的内容拷贝到一个中间缓冲区中 或者从一个中间缓冲区中拷贝数据。 要分配直接缓冲区，需要调用 allocateDirect()方法，而不是 allocate()方法，使用方 式与普通缓冲区并无区别。\n拷贝文件示例：\n```java\n//直接缓冲区\n    @Test\n    public void test03() throws Exception {\n        String infile = \"D:\\\\111.txt\";\n        FileInputStream fin = new FileInputStream(infile);\n        FileChannel finChannel = fin.getChannel();\n\n        String outfile = \"D:\\\\222.txt\";\n        FileOutputStream fout = new FileOutputStream(outfile);\n        FileChannel foutChannel = fout.getChannel();\n\n        //创建直接缓冲区\n        ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n        while (true){\n            buffer.clear();\n            int r = finChannel.read(buffer);\n            if(r==-1){\n                break;\n            }\n            buffer.flip();\n            foutChannel.write(buffer);\n        }\n    }\n```\n\n#### 8.4 内存映射文件 I/O\n内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通 道的 I/O 快的多。内存映射文件 I/O 是通过使文件中的数据出现为 内存数组的内容来 完成的，这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。 一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。 示例代码：\n\n```java\nstatic private final int start = 0; \nstatic private final int size = 1024;\n\n//内存映射文件\n    @Test\n    public void test04() throws Exception{\n        RandomAccessFile raf = new RandomAccessFile(\"d:\\\\111.txt\", \"rw\");\n        FileChannel fc = raf.getChannel();\n        MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, start, size);\n        mbb.put(0, (byte) 97);\n        mbb.put(1023, (byte) 122);\n        raf.close();\n    }\n```\n', '2022-10-08 16:37:01', '2022-10-09 10:48:29', '<h3><a id=\"1_Buffer__0\"></a>1 Buffer 简介</h3>\n<p>Java NIO 中的 Buffer 用于和 NIO 通道进行交互。数据是从通道读入缓冲区，从缓冲 区写入到通道中的。</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/ff63cf22b4fb456fa17b1bd67c58204d.png\" alt=\"image.png\" /></p>\n</div>\n<p>缓冲区 <mark>本质上是一块可以写入数据，然后可以从中读取数据的内存</mark> 。这块内存被包装 成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。缓冲区实际上是 一个容器对象，更直接的说，其实就是一个数组，<mark>在 NIO 库中，所有数据都是用缓冲 区处理的</mark> 。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到 缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流 I/O 系统中，所有数据都是直接写入或者直接将数据读取到 Stream 对象中。 在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer，最常用的就是 ByteBuffer， 对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应，它们之间的继 承关系如下图所示：</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/e77b8d6b861b430c9dec09ed3d4b54e3.png\" alt=\"image.png\" /></p>\n</div>\n<h3><a id=\"2_Buffer__15\"></a>2 Buffer 的基本用法</h3>\n<p>使用 Buffer 读写数据，一般遵循以下四个步骤：</p>\n<ul>\n<li>写入数据到 Buffer</li>\n<li>调用 flip()方法</li>\n<li>从 Buffer 中读取数据</li>\n<li>调用 clear()方法或者 compact()方法</li>\n</ul>\n<p>当向 buffer 写入数据时，buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip()方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 buffer 的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有 两种方式能清空缓冲区：调用 clear()或 compact()方法。clear()方法会清空整个缓冲 区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起 始处，新写入的数据将放到缓冲区未读数据的后面。</p>\n<p>使用 Buffer 的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BufferDemo01</span> {\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">buffer01</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">//FileChannel</span>\n        <span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">aFile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\111.txt&quot;</span>,<span class=\"hljs-string\">&quot;rw&quot;</span>);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> aFile.getChannel();\n        <span class=\"hljs-comment\">//创建buffer,大小</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n        <span class=\"hljs-comment\">//读</span>\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bytesRead</span> <span class=\"hljs-operator\">=</span> channel.read(buffer);\n        <span class=\"hljs-keyword\">while</span> (bytesRead != -<span class=\"hljs-number\">1</span>){\n            <span class=\"hljs-comment\">//read模式</span>\n            buffer.flip();\n            <span class=\"hljs-keyword\">while</span> (buffer.hasRemaining()){\n                System.out.println((<span class=\"hljs-type\">char</span>)buffer.get());\n            }\n            buffer.clear();\n            bytesRead = channel.read(buffer);\n        }\n        aFile.close();\n    }\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">buffer02</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception{\n        <span class=\"hljs-comment\">//创建buffer</span>\n        <span class=\"hljs-type\">IntBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> IntBuffer.allocate(<span class=\"hljs-number\">8</span>);\n        <span class=\"hljs-comment\">//buffer 放</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; buffer.capacity(); i++) {\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span><span class=\"hljs-number\">2</span>*(i+<span class=\"hljs-number\">1</span>);\n            buffer.put(j);\n        }\n        <span class=\"hljs-comment\">//重置缓冲区</span>\n        buffer.flip();\n        <span class=\"hljs-comment\">//获取</span>\n        <span class=\"hljs-keyword\">while</span> (buffer.hasRemaining()){\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> buffer.get();\n            System.out.println(i+<span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n    }\n}\n</code></div></pre>\n<h3><a id=\"3_Buffer__capacityposition__limit_69\"></a>3 Buffer 的 capacity、position 和 limit</h3>\n<p>为了理解 Buffer 的工作原理，需要熟悉它的三个属性：</p>\n<ul>\n<li>Capacity</li>\n<li>Position</li>\n<li>limit</li>\n</ul>\n<p>position 和 limit 的含义取决于 Buffer 处在读模式还是写模式。不管 Buffer 处在什么 模式，capacity 的含义总是一样的。<br />\n这里有一个关于 capacity，position 和 limit 在读写模式中的说明</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/1d35274b372541158b8b959ff27ddeb1.png\" alt=\"image.png\" /></p>\n</div>\n<ul>\n<li>\n<p>capacity<br />\n作为一个内存块，Buffer 有一个固定的大小值，也叫“capacity”.你只能往里写 capacity 个 byte、long，char 等类型。一旦 Buffer 满了，需要将其清空（通过读数 据或者清除数据）才能继续写数据往里写数据。</p>\n</li>\n<li>\n<p>position<br />\n1）写数据到 Buffer 中时，position 表示写入数据的当前位置，position 的初始值为 0。当一个 byte、long 等数据写到 Buffer 后， position 会向下移动到下一个可插入 数据的 Buffer 单元。position 最大可为 capacity – 1（因为 position 的初始值为 0）。<br />\n2）读数据到 Buffer 中时，position 表示读入数据的当前位置，如 position=2 时表 示已开始读入了 3 个 byte，或从第 3 个 byte 开始读取。通过 ByteBuffer.flip()切换到 读模式时 position 会被重置为 0，当 Buffer 从 position 读入数据后，position 会下 移到下一个可读入的数据 Buffer 单元。</p>\n</li>\n<li>\n<p>limit<br />\n1）写数据时，limit 表示可对 Buffer 最多写入多少个数据。写模式下，limit 等于 Buffer 的 capacity。<br />\n2）读数据时，limit 表示 Buffer 里有多少可读数据（not null 的数据），因此能读到 之前写入的所有数据（limit 被设置成已写数据的数量，这个值在写模式下就是 position）。</p>\n</li>\n</ul>\n<h3><a id=\"4_Buffer__93\"></a>4 Buffer 的类型</h3>\n<p>Java NIO 有以下 Buffer 类型</p>\n<ul>\n<li>ByteBuffer</li>\n<li>MappedByteBuffer</li>\n<li>CharBuffer</li>\n<li>DoubleBuffer</li>\n<li>FloatBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>ShortBuffer</li>\n</ul>\n<p>这些 Buffer 类型代表了不同的数据类型。换句话说，就是可以通过 char，short，int， long，float 或 double 类型来操作缓冲区中的字节。</p>\n<h3><a id=\"5_Buffer__107\"></a>5 Buffer 分配和写数据</h3>\n<h4><a id=\"51_Buffer__108\"></a>5.1 Buffer 分配</h4>\n<p>要想获得一个 Buffer 对象首先要进行分配。 每一个 Buffer 类都有一个 allocate 方法。 下面是一个分配 48 字节 capacity 的 ByteBuffer 的例子。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buf</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">48</span>);\n</code></div></pre>\n<p>这是分配一个可存储 1024 个字符的 CharBuffer：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">CharBuffer</span> <span class=\"hljs-variable\">buf</span> <span class=\"hljs-operator\">=</span> CharBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n</code></div></pre>\n<h4><a id=\"52__Buffer__117\"></a>5.2 向 Buffer 中写数据</h4>\n<p>写数据到 Buffer 有两种方式：<br />\n（1）从 Channel 写到 Buffer。<br />\n（2）通过 Buffer 的 put()方法写到 Buffer 里。<br />\n从 Channel 写到 Buffer 的例子</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bytesRead</span> <span class=\"hljs-operator\">=</span> inChannel.read(buf); <span class=\"hljs-comment\">//read into buffer</span>\n</code></div></pre>\n<p>通过 put 方法写 Buffer 的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">buf.put(<span class=\"hljs-number\">127</span>);\n</code></div></pre>\n<p>put 方法有很多版本，允许你以不同的方式把数据写入到 Buffer 中。例如， 写到一个 指定的位置，或者把一个字节数组写入到 Buffer</p>\n<h4><a id=\"53_flip_130\"></a>5.3 flip()方法</h4>\n<p>flip 方法将 Buffer 从写模式切换到读模式。调用 flip()方法会将 position 设回 0，并 将 limit 设置成之前 position 的值。换句话说，position 现在用于标记读的位置， limit 表示之前写进了多少个 byte、char 等 （现在能读取多少个 byte、char 等）。</p>\n<h3><a id=\"6__Buffer__133\"></a>6 从 Buffer 中读取数据</h3>\n<p>从 Buffer 中读取数据有两种方式：<br />\n（1）从 Buffer 读取数据到 Channel。<br />\n（2）使用 get()方法从 Buffer 中读取数据。<br />\n从 Buffer 读取数据到 Channel 的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//read from buffer into channel. </span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bytesWritten</span> <span class=\"hljs-operator\">=</span> inChannel.write(buf);\n</code></div></pre>\n<p>使用 get()方法从 Buffer 中读取数据的例子</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">aByte</span> <span class=\"hljs-operator\">=</span> buf.get();\n</code></div></pre>\n<p>get 方法有很多版本，允许你以不同的方式从 Buffer 中读取数据。例如，从指定 position 读取，或者从 Buffer 中读取数据到字节数组。</p>\n<h3><a id=\"7_Buffer__148\"></a>7 Buffer 几个方法</h3>\n<h4><a id=\"71_rewind_149\"></a>7.1 rewind()方法</h4>\n<p>Buffer.rewind()将 position 设回 0，所以你可以重读 Buffer 中的所有数据。limit 保 持不变，仍然表示能从 Buffer 中读取多少个元素（byte、char 等）。</p>\n<h4><a id=\"72_clear_compact_152\"></a>7.2 clear()与 compact()方法</h4>\n<p>一旦读完 Buffer 中的数据，需要让 Buffer 准备好再次被写入。可以通过 clear()或 compact()方法来完成。</p>\n<p>如果调用的是 clear()方法，position 将被设回 0，limit 被设置成 capacity 的值。换 句话说，Buffer 被清空了。Buffer 中的数据并未清除，只是这些标记告诉我们可以从 哪里开始往 Buffer 里写数据。</p>\n<p>如果 Buffer 中有一些未读的数据，调用 clear()方法，数据将“被遗忘”，意味着不再 有任何标记会告诉你哪些数据被读过，哪些还没有。</p>\n<p>如果 Buffer 中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据， 那么使用 compact()方法。</p>\n<p>compact()方法将所有未读的数据拷贝到 Buffer 起始处。然后将 position 设到最后一 个未读元素正后面。limit 属性依然像 clear()方法一样，设置成 capacity。现在 Buffer 准备好写数据了，但是不会覆盖未读的数据。</p>\n<h4><a id=\"73_mark_reset_163\"></a>7.3 mark()与 reset()方法</h4>\n<p>通过调用 Buffer.mark()方法，可以标记 Buffer 中的一个特定 position。之后可以通 过调用 Buffer.reset()方法恢复到这个 position。例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">buffer.mark(); \n<span class=\"hljs-comment\">//call buffer.get() a couple of times, e.g. during parsing. buffer.reset();</span>\n<span class=\"hljs-comment\">//set position back to mark.</span>\n</code></div></pre>\n<h3><a id=\"8__170\"></a>8 缓冲区操作</h3>\n<h4><a id=\"81__171\"></a>8.1 缓冲区分片</h4>\n<p>在 NIO 中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象 来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的 缓冲区与创建的子缓冲区在底层数组层面上是数据共享的，也就是说，子缓冲区相当 于是现有缓冲区的一个视图窗口。调用 slice()方法可以创建一个子缓冲区。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//缓冲区分片</span>\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test01</span><span class=\"hljs-params\">()</span>{\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; buffer.capacity(); i++) {\n            buffer.put((<span class=\"hljs-type\">byte</span>)i);\n        }\n        <span class=\"hljs-comment\">//创建子缓冲区</span>\n        buffer.position(<span class=\"hljs-number\">3</span>);\n        buffer.limit(<span class=\"hljs-number\">7</span>);\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">slice</span> <span class=\"hljs-operator\">=</span> buffer.slice();\n\n        <span class=\"hljs-comment\">//改变子缓冲区内容</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; slice.capacity(); i++) {\n            <span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> slice.get(i);\n            b*=<span class=\"hljs-number\">10</span>;\n            slice.put(i,b);\n        }\n        buffer.position(<span class=\"hljs-number\">0</span>);\n        buffer.limit(buffer.capacity());\n        <span class=\"hljs-keyword\">while</span> (buffer.remaining()&gt;<span class=\"hljs-number\">0</span>){\n            System.out.println(buffer.get());\n        }\n    }\n</code></div></pre>\n<h4><a id=\"82__201\"></a>8.2 只读缓冲区</h4>\n<p>只读缓冲区非常简单，可以读取它们，但是不能向它们写入数据。可以通过调用缓冲 区的 asReadOnlyBuffer()方法，将任何常规缓冲区转 换为只读缓冲区，这个方法返回 一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如 果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//只读缓冲区</span>\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test02</span><span class=\"hljs-params\">()</span>{\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; buffer.capacity(); i++) {\n            buffer.put((<span class=\"hljs-type\">byte</span>)i);\n        }\n        <span class=\"hljs-comment\">//创建只读缓冲区</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">readOnlyBuffer</span> <span class=\"hljs-operator\">=</span> buffer.asReadOnlyBuffer();\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; buffer.capacity(); i++) {\n            <span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> buffer.get(i);\n            b*=<span class=\"hljs-number\">10</span>;\n            buffer.put(i,b);\n        }\n        readOnlyBuffer.position(<span class=\"hljs-number\">0</span>);\n        readOnlyBuffer.limit(buffer.capacity());\n        <span class=\"hljs-keyword\">while</span> (readOnlyBuffer.remaining()&gt;<span class=\"hljs-number\">0</span>){\n            System.out.println(readOnlyBuffer.get());\n        }\n    }\n</code></div></pre>\n<p>如果尝试修改只读缓冲区的内容，则会报 ReadOnlyBufferException 异常。只读缓冲 区对于保护数据很有用。在将缓冲区传递给某个 对象的方法时，无法知道这个方法是 否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只 可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区。</p>\n<h4><a id=\"83__230\"></a>8.3 直接缓冲区</h4>\n<p>直接缓冲区是为加快 I/O 速度，使用一种特殊方式为其分配内存的缓冲区，JDK 文档 中的描述为：给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)， 尝试避免将缓冲区的内容拷贝到一个中间缓冲区中 或者从一个中间缓冲区中拷贝数据。 要分配直接缓冲区，需要调用 allocateDirect()方法，而不是 allocate()方法，使用方 式与普通缓冲区并无区别。<br />\n拷贝文件示例：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//直接缓冲区</span>\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test03</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">infile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;D:\\\\111.txt&quot;</span>;\n        <span class=\"hljs-type\">FileInputStream</span> <span class=\"hljs-variable\">fin</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(infile);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">finChannel</span> <span class=\"hljs-operator\">=</span> fin.getChannel();\n\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">outfile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;D:\\\\222.txt&quot;</span>;\n        <span class=\"hljs-type\">FileOutputStream</span> <span class=\"hljs-variable\">fout</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileOutputStream</span>(outfile);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">foutChannel</span> <span class=\"hljs-operator\">=</span> fout.getChannel();\n\n        <span class=\"hljs-comment\">//创建直接缓冲区</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocateDirect(<span class=\"hljs-number\">1024</span>);\n        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>){\n            buffer.clear();\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> finChannel.read(buffer);\n            <span class=\"hljs-keyword\">if</span>(r==-<span class=\"hljs-number\">1</span>){\n                <span class=\"hljs-keyword\">break</span>;\n            }\n            buffer.flip();\n            foutChannel.write(buffer);\n        }\n    }\n</code></div></pre>\n<h4><a id=\"84__IO_259\"></a>8.4 内存映射文件 I/O</h4>\n<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通 道的 I/O 快的多。内存映射文件 I/O 是通过使文件中的数据出现为 内存数组的内容来 完成的，这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。 一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。 示例代码：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; \n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">size</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1024</span>;\n\n<span class=\"hljs-comment\">//内存映射文件</span>\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test04</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception{\n        <span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">raf</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\111.txt&quot;</span>, <span class=\"hljs-string\">&quot;rw&quot;</span>);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">fc</span> <span class=\"hljs-operator\">=</span> raf.getChannel();\n        <span class=\"hljs-type\">MappedByteBuffer</span> <span class=\"hljs-variable\">mbb</span> <span class=\"hljs-operator\">=</span> fc.map(FileChannel.MapMode.READ_WRITE, start, size);\n        mbb.put(<span class=\"hljs-number\">0</span>, (<span class=\"hljs-type\">byte</span>) <span class=\"hljs-number\">97</span>);\n        mbb.put(<span class=\"hljs-number\">1023</span>, (<span class=\"hljs-type\">byte</span>) <span class=\"hljs-number\">122</span>);\n        raf.close();\n    }\n</code></div></pre>\n');
INSERT INTO `article_content` VALUES ('ace86a2c5d5c94e559bbfe3158d342fc', '### 1 Channel 概述\nJava NIO 的通道类似流，但又有些不同：\n1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n2. 通道可以异步地读写。\n3. 通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。\n\n正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/1e486540ca1647729ae0d8ec82573a98.png)\n\n:::\n\n### 2 Channel 实现\n下面是 Java NIO 中最重要的 Channel 的实现：\n1. FileChannel（从文件中读写数据）\n2. DatagramChannel（能通过 UDP 读写网络中的数据）\n3. SocketChannel（能通过 TCP 读写网络中的数据）\n4. ServerSocketChannel（可以监听新进来的 TCP 连接，像 Web 服务器那样。对 每一个新进来的连接都会创建一个 SocketChannel）\n\n正如你所看到的，这些通道涵盖了 UDP 和 TCP 网络 IO，以及文件 IO\n\n### 3 FileChannel 介绍和示例\nFileChannel 类可以实现常用的 read，write 以及 scatter/gather 操作，同时它也提 供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/04651f0d2f5a4406a16a901e27f75f95.png)\n\n:::\n\n下面是一个使用 FileChannel 读取数据到 Buffer 中的示例：\n```java\npublic class FileChannelDemo01 {\n    //FileChannel读取数据到buffer中\n    public static void main(String[] args) throws Exception {\n        //创建FileChannel\n        RandomAccessFile accessFile = new RandomAccessFile(\"d:\\\\333.txt\", \"rw\");\n        FileChannel channel = accessFile.getChannel();\n        //创建Buffer\n        ByteBuffer  buf = ByteBuffer.allocate(1024);\n        //读取数据到buffer中\n        int bytesRead = channel.read(buf);\n        while (bytesRead !=-1){\n            System.out.println(\"读取了：\"+bytesRead);\n            buf.flip();\n            while (buf.hasRemaining()){\n                System.out.println((char) buf.get());\n            }\n            buf.clear();\n            bytesRead = channel.read(buf);\n        }\n        accessFile.close();\n        System.out.println(\"结束了\");\n    }\n}\n```\n\nBuffer 通常的操作\n1. 将数据写入缓冲区\n2. 调用 buffer.flip() 反转读写模式\n3. 从缓冲区读取数据\n4. 调用 buffer.clear() 或 buffer.compact() 清除缓冲区内容\n\n### 4 FileChannel 操作详解\n\n#### 4.1 打开 FileChannel\n在使用 FileChannel 之前，必须先打开它。但是，我们无法直接打开一个 FileChannel，需要通过使用一个 InputStream、OutputStream 或 RandomAccessFile 来获取一个 FileChannel 实例。下面是通过 RandomAccessFile 打开 FileChannel 的示例：\n```java\nRandomAccessFile accessFile = new RandomAccessFile(\"d:\\\\333.txt\", \"rw\");\nFileChannel channel = accessFile.getChannel();\n```\n#### 4.2 从 FileChannel 读取数据\n调用多个 read()方法之一从 FileChannel 中读取数据。如：\n```java\nByteBuffer  buf = ByteBuffer.allocate(1024);\n//读取数据到buffer中\nint bytesRead = channel.read(buf);\n```\n首先，分配一个 Buffer。从 FileChannel 中读取的数据将被读到 Buffer 中。然后，调 用 FileChannel.read()方法。该方法将数据从 FileChannel 读取到 Buffer 中。read() 方法返回的 int 值表示了有多少字节被读到了 Buffer 中。如果返回-1，表示到了文件 末尾。\n\n####4.3 向 FileChannel 写数据\n使用 FileChannel.write()方法向 FileChannel 写数据，该方法的参数是一个 Buffer。 如：\n```java\npublic class FileChannelDemo02 {\n    public static void main(String[] args) throws Exception {\n        RandomAccessFile accessFile = new RandomAccessFile(\"d:\\\\111.txt\", \"rw\");\n        FileChannel channel = accessFile.getChannel();\n        //创建Buffer对象\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        String newData = \"hello word\";\n        buffer.clear();\n        //写入内容\n        buffer.put(newData.getBytes(StandardCharsets.UTF_8));\n        buffer.flip();\n        //FileChannel完成最终实现\n        while (buffer.hasRemaining()){\n            channel.write(buffer);\n        }\n        channel.close();\n    }\n}\n```\n#### 4.4 关闭 FileChannel\n用完 FileChannel 后必须将其关闭。如：\n```java\nchannel.close();\n```\n\n#### 4.5 FileChannel 的 position 方法\n有时可能需要在 FileChannel 的某个特定位置进行数据的读/写操作。可以通过调用 position()方法获取 FileChannel 的当前位置。也可以通过调用 position(long pos)方 法设置 FileChannel 的当前位置。\n\n这里有两个例子:\n```java\nlong pos = channel.position(); \nchannel.position(pos +123);\n```\n如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回- 1 （文件结束标志）。\n如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并 写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。\n\n#### 4.6 FileChannel 的 size 方法\nFileChannel 实例的 size()方法将返回该实例所关联文件的大小。如:\n\n```java\nlong fileSize = channel.size();\n```\n#### 4.7 FileChannel 的 truncate 方法\n可以使用 FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度 后面的部分将被删除。如：\n\n```java\nchannel.truncate(1024);\n```\n这个例子截取文件的前 1024 个字节。\n\n#### 4.8 FileChannel 的 force 方法\n\nFileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方 面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到 FileChannel 里的 数据一定会即时写到磁盘上。要保证这一点，需要调用 force()方法。\n\nforce()方法有一个 boolean 类型的参数，指明是否同时将文件元数据（权限信息等） 写到磁盘上。\n\n#### 4.9 FileChannel 的 transferTo 和 transferFrom 方法\n通道之间的数据传输：\n如果两个通道中有一个是 FileChannel，那你可以直接将数据从一个 channel 传输到 另外一个 channel\n- transferFrom()方法\nFileChannel 的 transferFrom()方法可以将数据从源通道传输到 FileChannel 中（译 者注：这个方法在 JDK 文档中的解释为将字节从给定的可读取字节通道传输到此通道 的文件中）。下面是一个 FileChannel 完成文件间的复制的例子：\n```java\npublic class FileChannelDemo03 {\n    public static void main(String[] args)  throws Exception{\n        //创建两个通道\n        RandomAccessFile aFile = new RandomAccessFile(\"d:\\\\111.txt\", \"rw\");\n        FileChannel fromChannel = aFile.getChannel();\n\n        RandomAccessFile bFile = new RandomAccessFile(\"d:\\\\02.txt\", \"rw\");\n        FileChannel toChannel = bFile.getChannel();\n        //fromChannel 传输到 toChannel\n        long position = 0;\n        long size = fromChannel.size();\n        toChannel.transferFrom(fromChannel,position,size);\n\n        aFile.close();\n        bFile.close();\n        System.out.println(\"over!\");\n    }\n}\n```\n\n方法的输入参数 position 表示从 position 处开始向目标文件写入数据，count 表示最 多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小 于请求的字节数。此外要注意，在 SoketChannel 的实现中，SocketChannel 只会传 输此刻准备好的数据（可能不足 count 字节）。因此，SocketChannel 可能不会将请 求的所有数据(count 个字节)全部传输到 FileChannel 中。\n\n- transferTo()方法\n\ntransferTo()方法将数据从 FileChannel 传输到其他的 channel 中。\n下面是一个 transferTo()方法的例子：\n```java\npublic class FileChannelDemo04 {\n    public static void main(String[] args) throws Exception {\n        //创建两个通道\n        RandomAccessFile aFile = new RandomAccessFile(\"d:\\\\111.txt\", \"rw\");\n        FileChannel fromChannel = aFile.getChannel();\n        RandomAccessFile bFile = new RandomAccessFile(\"d:\\\\03.txt\", \"rw\");\n        FileChannel toChannel = bFile.getChannel();\n        long position = 0;\n        long count = fromChannel.size();\n        fromChannel.transferTo(position, count, toChannel);\n        aFile.close();\n        bFile.close();\n        System.out.println(\"over!\");\n    }\n}\n```\n### 5 Scatter/Gather\nJava NIO 开始支持 scatter/gather，scatter/gather 用于描述从 Channel 中读取或 者写入到 Channel 的操作。\n\n==分散==（scatter）从 Channel 中读取是指在读操作时将读取的数据写入多个 buffer 中。 因此，Channel 将从 Channel 中读取的数据“分散（scatter）”到多个 Buffer 中。\n\n==聚集==（gather）写入 Channel 是指在写操作时将多个 buffer 的数据写入同一个 Channel，因此，Channel 将多个 Buffer 中的数据“聚集（gather）”后发送到 Channel。\n\nscatter / gather 经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头 和消息体组成的消息，你可能会将消息体和消息头分散到不同的 buffer 中，这样你可 以方便的处理消息头和消息体。\n\n#### 5.1 Scattering Reads\nScattering Reads 是指数据从一个 channel 读取到多个 buffer 中。如下图描述：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/3020d19255734776aea5f650ebd4946b.png)\n\n:::\n\n```java\nByteBuffer header = ByteBuffer.allocate(128); \nByteBuffer body = ByteBuffer.allocate(1024);\nByteBuffer[] bufferArray = { header, body }; \nchannel.read(bufferArray);\n```\n注意 buffer 首先被插入到数组，然后再将数组作为 channel.read() 的输入参数。 read()方法按照 buffer 在数组中的顺序将从 channel 中读取的数据写入到 buffer，当 一个 buffer 被写满后，channel 紧接着向另一个 buffer 中写。\n\nScattering Reads 在移动下一个 buffer 前，必须填满当前的 buffer，这也意味着它 不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体， 消息头必须完成填充（例如 128byte），Scattering Reads 才能正常工作。\n\n#### 5.2 Gathering Writes\nGathering Writes 是指数据从多个 buffer 写入到同一个 channel。如下图描述：\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/175b692f36164285b91181519562fc1f.png)\n\n:::\n\n```java\nByteBuffer header = ByteBuffer.allocate(128); \nByteBuffer body = ByteBuffer.allocate(1024); \n//write data into buffers \nByteBuffer[] bufferArray = { header, body }; \nchannel.write(bufferArray);\n```\n\nbuffers 数组是 write()方法的入参，write()方法会按照 buffer 在数组中的顺序，将数 据写入到 channel，注意只有 position 和 limit 之间的数据才会被写入。因此，如果 一个 buffer 的容量为 128byte，但是仅仅包含 58byte 的数据，那么这 58byte 的数 据将被写入到 channel 中。因此与 Scattering Reads 相反，Gathering Writes 能较 好的处理动态消息。', '2022-09-30 15:13:36', '2022-10-08 16:25:20', '<h3><a id=\"1_Channel__0\"></a>1 Channel 概述</h3>\n<p>Java NIO 的通道类似流，但又有些不同：</p>\n<ol>\n<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>\n<li>通道可以异步地读写。</li>\n<li>通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。</li>\n</ol>\n<p>正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/1e486540ca1647729ae0d8ec82573a98.png\" alt=\"image.png\" /></p>\n</div>\n<h3><a id=\"2_Channel__13\"></a>2 Channel 实现</h3>\n<p>下面是 Java NIO 中最重要的 Channel 的实现：</p>\n<ol>\n<li>FileChannel（从文件中读写数据）</li>\n<li>DatagramChannel（能通过 UDP 读写网络中的数据）</li>\n<li>SocketChannel（能通过 TCP 读写网络中的数据）</li>\n<li>ServerSocketChannel（可以监听新进来的 TCP 连接，像 Web 服务器那样。对 每一个新进来的连接都会创建一个 SocketChannel）</li>\n</ol>\n<p>正如你所看到的，这些通道涵盖了 UDP 和 TCP 网络 IO，以及文件 IO</p>\n<h3><a id=\"3_FileChannel__22\"></a>3 FileChannel 介绍和示例</h3>\n<p>FileChannel 类可以实现常用的 read，write 以及 scatter/gather 操作，同时它也提 供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/04651f0d2f5a4406a16a901e27f75f95.png\" alt=\"image.png\" /></p>\n</div>\n<p>下面是一个使用 FileChannel 读取数据到 Buffer 中的示例：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FileChannelDemo01</span> {\n    <span class=\"hljs-comment\">//FileChannel读取数据到buffer中</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">//创建FileChannel</span>\n        <span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">accessFile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\333.txt&quot;</span>, <span class=\"hljs-string\">&quot;rw&quot;</span>);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> accessFile.getChannel();\n        <span class=\"hljs-comment\">//创建Buffer</span>\n        <span class=\"hljs-type\">ByteBuffer</span>  <span class=\"hljs-variable\">buf</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n        <span class=\"hljs-comment\">//读取数据到buffer中</span>\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bytesRead</span> <span class=\"hljs-operator\">=</span> channel.read(buf);\n        <span class=\"hljs-keyword\">while</span> (bytesRead !=-<span class=\"hljs-number\">1</span>){\n            System.out.println(<span class=\"hljs-string\">&quot;读取了：&quot;</span>+bytesRead);\n            buf.flip();\n            <span class=\"hljs-keyword\">while</span> (buf.hasRemaining()){\n                System.out.println((<span class=\"hljs-type\">char</span>) buf.get());\n            }\n            buf.clear();\n            bytesRead = channel.read(buf);\n        }\n        accessFile.close();\n        System.out.println(<span class=\"hljs-string\">&quot;结束了&quot;</span>);\n    }\n}\n</code></div></pre>\n<p>Buffer 通常的操作</p>\n<ol>\n<li>将数据写入缓冲区</li>\n<li>调用 buffer.flip() 反转读写模式</li>\n<li>从缓冲区读取数据</li>\n<li>调用 buffer.clear() 或 buffer.compact() 清除缓冲区内容</li>\n</ol>\n<h3><a id=\"4_FileChannel__63\"></a>4 FileChannel 操作详解</h3>\n<h4><a id=\"41__FileChannel_65\"></a>4.1 打开 FileChannel</h4>\n<p>在使用 FileChannel 之前，必须先打开它。但是，我们无法直接打开一个 FileChannel，需要通过使用一个 InputStream、OutputStream 或 RandomAccessFile 来获取一个 FileChannel 实例。下面是通过 RandomAccessFile 打开 FileChannel 的示例：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">accessFile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\333.txt&quot;</span>, <span class=\"hljs-string\">&quot;rw&quot;</span>);\n<span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> accessFile.getChannel();\n</code></div></pre>\n<h4><a id=\"42__FileChannel__71\"></a>4.2 从 FileChannel 读取数据</h4>\n<p>调用多个 read()方法之一从 FileChannel 中读取数据。如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">ByteBuffer</span>  <span class=\"hljs-variable\">buf</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n<span class=\"hljs-comment\">//读取数据到buffer中</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bytesRead</span> <span class=\"hljs-operator\">=</span> channel.read(buf);\n</code></div></pre>\n<p>首先，分配一个 Buffer。从 FileChannel 中读取的数据将被读到 Buffer 中。然后，调 用 FileChannel.read()方法。该方法将数据从 FileChannel 读取到 Buffer 中。read() 方法返回的 int 值表示了有多少字节被读到了 Buffer 中。如果返回-1，表示到了文件 末尾。</p>\n<p>####4.3 向 FileChannel 写数据<br />\n使用 FileChannel.write()方法向 FileChannel 写数据，该方法的参数是一个 Buffer。 如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FileChannelDemo02</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">accessFile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\111.txt&quot;</span>, <span class=\"hljs-string\">&quot;rw&quot;</span>);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> accessFile.getChannel();\n        <span class=\"hljs-comment\">//创建Buffer对象</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">newData</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello word&quot;</span>;\n        buffer.clear();\n        <span class=\"hljs-comment\">//写入内容</span>\n        buffer.put(newData.getBytes(StandardCharsets.UTF_8));\n        buffer.flip();\n        <span class=\"hljs-comment\">//FileChannel完成最终实现</span>\n        <span class=\"hljs-keyword\">while</span> (buffer.hasRemaining()){\n            channel.write(buffer);\n        }\n        channel.close();\n    }\n}\n</code></div></pre>\n<h4><a id=\"44__FileChannel_102\"></a>4.4 关闭 FileChannel</h4>\n<p>用完 FileChannel 后必须将其关闭。如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">channel.close();\n</code></div></pre>\n<h4><a id=\"45_FileChannel__position__108\"></a>4.5 FileChannel 的 position 方法</h4>\n<p>有时可能需要在 FileChannel 的某个特定位置进行数据的读/写操作。可以通过调用 position()方法获取 FileChannel 的当前位置。也可以通过调用 position(long pos)方 法设置 FileChannel 的当前位置。</p>\n<p>这里有两个例子:</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">pos</span> <span class=\"hljs-operator\">=</span> channel.position(); \nchannel.position(pos +<span class=\"hljs-number\">123</span>);\n</code></div></pre>\n<p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回- 1 （文件结束标志）。<br />\n如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并 写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p>\n<h4><a id=\"46_FileChannel__size__119\"></a>4.6 FileChannel 的 size 方法</h4>\n<p>FileChannel 实例的 size()方法将返回该实例所关联文件的大小。如:</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">fileSize</span> <span class=\"hljs-operator\">=</span> channel.size();\n</code></div></pre>\n<h4><a id=\"47_FileChannel__truncate__125\"></a>4.7 FileChannel 的 truncate 方法</h4>\n<p>可以使用 FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度 后面的部分将被删除。如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">channel.truncate(<span class=\"hljs-number\">1024</span>);\n</code></div></pre>\n<p>这个例子截取文件的前 1024 个字节。</p>\n<h4><a id=\"48_FileChannel__force__133\"></a>4.8 FileChannel 的 force 方法</h4>\n<p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方 面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到 FileChannel 里的 数据一定会即时写到磁盘上。要保证这一点，需要调用 force()方法。</p>\n<p>force()方法有一个 boolean 类型的参数，指明是否同时将文件元数据（权限信息等） 写到磁盘上。</p>\n<h4><a id=\"49_FileChannel__transferTo__transferFrom__139\"></a>4.9 FileChannel 的 transferTo 和 transferFrom 方法</h4>\n<p>通道之间的数据传输：<br />\n如果两个通道中有一个是 FileChannel，那你可以直接将数据从一个 channel 传输到 另外一个 channel</p>\n<ul>\n<li>transferFrom()方法<br />\nFileChannel 的 transferFrom()方法可以将数据从源通道传输到 FileChannel 中（译 者注：这个方法在 JDK 文档中的解释为将字节从给定的可读取字节通道传输到此通道 的文件中）。下面是一个 FileChannel 完成文件间的复制的例子：</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FileChannelDemo03</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>  <span class=\"hljs-keyword\">throws</span> Exception{\n        <span class=\"hljs-comment\">//创建两个通道</span>\n        <span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">aFile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\111.txt&quot;</span>, <span class=\"hljs-string\">&quot;rw&quot;</span>);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">fromChannel</span> <span class=\"hljs-operator\">=</span> aFile.getChannel();\n\n        <span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">bFile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\02.txt&quot;</span>, <span class=\"hljs-string\">&quot;rw&quot;</span>);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">toChannel</span> <span class=\"hljs-operator\">=</span> bFile.getChannel();\n        <span class=\"hljs-comment\">//fromChannel 传输到 toChannel</span>\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">position</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">size</span> <span class=\"hljs-operator\">=</span> fromChannel.size();\n        toChannel.transferFrom(fromChannel,position,size);\n\n        aFile.close();\n        bFile.close();\n        System.out.println(<span class=\"hljs-string\">&quot;over!&quot;</span>);\n    }\n}\n</code></div></pre>\n<p>方法的输入参数 position 表示从 position 处开始向目标文件写入数据，count 表示最 多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小 于请求的字节数。此外要注意，在 SoketChannel 的实现中，SocketChannel 只会传 输此刻准备好的数据（可能不足 count 字节）。因此，SocketChannel 可能不会将请 求的所有数据(count 个字节)全部传输到 FileChannel 中。</p>\n<ul>\n<li>transferTo()方法</li>\n</ul>\n<p>transferTo()方法将数据从 FileChannel 传输到其他的 channel 中。<br />\n下面是一个 transferTo()方法的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FileChannelDemo04</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">//创建两个通道</span>\n        <span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">aFile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\111.txt&quot;</span>, <span class=\"hljs-string\">&quot;rw&quot;</span>);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">fromChannel</span> <span class=\"hljs-operator\">=</span> aFile.getChannel();\n        <span class=\"hljs-type\">RandomAccessFile</span> <span class=\"hljs-variable\">bFile</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomAccessFile</span>(<span class=\"hljs-string\">&quot;d:\\\\03.txt&quot;</span>, <span class=\"hljs-string\">&quot;rw&quot;</span>);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">toChannel</span> <span class=\"hljs-operator\">=</span> bFile.getChannel();\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">position</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> fromChannel.size();\n        fromChannel.transferTo(position, count, toChannel);\n        aFile.close();\n        bFile.close();\n        System.out.println(<span class=\"hljs-string\">&quot;over!&quot;</span>);\n    }\n}\n</code></div></pre>\n<h3><a id=\"5_ScatterGather_188\"></a>5 Scatter/Gather</h3>\n<p>Java NIO 开始支持 scatter/gather，scatter/gather 用于描述从 Channel 中读取或 者写入到 Channel 的操作。</p>\n<p><mark>分散</mark>（scatter）从 Channel 中读取是指在读操作时将读取的数据写入多个 buffer 中。 因此，Channel 将从 Channel 中读取的数据“分散（scatter）”到多个 Buffer 中。</p>\n<p><mark>聚集</mark>（gather）写入 Channel 是指在写操作时将多个 buffer 的数据写入同一个 Channel，因此，Channel 将多个 Buffer 中的数据“聚集（gather）”后发送到 Channel。</p>\n<p>scatter / gather 经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头 和消息体组成的消息，你可能会将消息体和消息头分散到不同的 buffer 中，这样你可 以方便的处理消息头和消息体。</p>\n<h4><a id=\"51_Scattering_Reads_197\"></a>5.1 Scattering Reads</h4>\n<p>Scattering Reads 是指数据从一个 channel 读取到多个 buffer 中。如下图描述：</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/3020d19255734776aea5f650ebd4946b.png\" alt=\"image.png\" /></p>\n</div>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">header</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">128</span>); \n<span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">body</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\nByteBuffer[] bufferArray = { header, body }; \nchannel.read(bufferArray);\n</code></div></pre>\n<p>注意 buffer 首先被插入到数组，然后再将数组作为 channel.read() 的输入参数。 read()方法按照 buffer 在数组中的顺序将从 channel 中读取的数据写入到 buffer，当 一个 buffer 被写满后，channel 紧接着向另一个 buffer 中写。</p>\n<p>Scattering Reads 在移动下一个 buffer 前，必须填满当前的 buffer，这也意味着它 不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体， 消息头必须完成填充（例如 128byte），Scattering Reads 才能正常工作。</p>\n<h4><a id=\"52_Gathering_Writes_215\"></a>5.2 Gathering Writes</h4>\n<p>Gathering Writes 是指数据从多个 buffer 写入到同一个 channel。如下图描述：</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/175b692f36164285b91181519562fc1f.png\" alt=\"image.png\" /></p>\n</div>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">header</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">128</span>); \n<span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">body</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>); \n<span class=\"hljs-comment\">//write data into buffers </span>\nByteBuffer[] bufferArray = { header, body }; \nchannel.write(bufferArray);\n</code></div></pre>\n<p>buffers 数组是 write()方法的入参，write()方法会按照 buffer 在数组中的顺序，将数 据写入到 channel，注意只有 position 和 limit 之间的数据才会被写入。因此，如果 一个 buffer 的容量为 128byte，但是仅仅包含 58byte 的数据，那么这 58byte 的数 据将被写入到 channel 中。因此与 Scattering Reads 相反，Gathering Writes 能较 好的处理动态消息。</p>\n');
INSERT INTO `article_content` VALUES ('c2317a9079991be3273a65254f263441', '\n\n### 前言\n\n> 闲来无事，想自己开发一个简单的Vue懒加载插件，能力的提升我觉得是可以通过编写插件实现，研究了一下官网的[Vue插件](https://cn.vuejs.org/v2/guide/plugins.html)编写。马上自己独立开始编写懒加载插件。\n\n### 一、写在前面\n\n在这阐述一下本人的观念，我一直推崇一些高度定制化的插件，一些小Demo，是需要自己写的，不能崇尚“拿来主义”。有些插件网上都有，但是你用了会发现谁都会用，而且有时候对于自己的需求又不够贴合。\n\n等到自己需要写一个插件的时候，却无从下手。但是如果你练习了插件编写后，收获往小了讲，就是可以自己写一个小插件，往大了讲，你能力到达一定地步你是可以写一个框架的。\n\n所以，练习写插件和小框架能力非常重要！也就基本注定了你的代码生涯。\n\n### 二、前期准备\n\n#### 2.1 选择合适的打包工具\n\n合适的打包工具可以达到事半功倍的效果。一开始我的首选有两个，一个是webpack，一个是rollup。下面简单介绍一下我为什么选择了rollup。\n\n众所周知，webpack是一个几乎囊括了所有**静态资源**，可以**动态按需加载**的一个包工具。而rollup也是一个模块打包器，可以把一个大块复杂的代码拆分成各个小模块。\n\n深思熟虑后，我觉得webpack也可以打包，但是首先，有点“杀鸡焉用牛刀”的感觉。而我的这个懒加载插件则需要提供给别人使用，同时又要保证整个插件的“轻量性”（打包完大概6KB，而webpack则比较大），不喜欢像webpack那样在这插件上臃肿的表现。\n\n对于非应用级的程序，我比较倾向于使用rollup.js。\n\n#### 2.2 确认项目结构\n\n```json\n|——package.json\n|——config\n|	|——rollup.config.js\n|——dist\n|	|——bundle.js\n|——src\n|	|——index.js\n|	|——directive.js\n|	|——mixin.js\n|	|——utils\n|	|	|——utils.js\n|	|——cores\n|		|——lazyload.js\n|		|——imagebox.js\n```\n\nconfig文件夹下放置rollup的配置文件。src为源文件夹，cores下面的文件夹为主要的模块，utils为工具类，主要是一些可以通用的模块方法。大概的结构就是这样。\n\n#### 2.3 编写思路\n\n懒加载的实现过程，我们这里先精简化。具体思路如下：\n\n=》**把所有用指令绑定的元素添加数组初始化** \n\n=》**监听滚动条滚动**	\n\n=》**判断元素是否进入可视范围** \n\n=》**如果进入可视范围，进行src预加载（存入缓存数组）** \n\n=》**对于pending的图片，进行正在加载赋值，对于finsh完的图片，加载预加载src里面的值，对于error的图片，进行错误图片src赋值**\n\n### 三、主要代码的编写\n\n#### 3.1 确认入口文件\n\n[Vue](https://cn.vuejs.org/v2/guide/plugins.html)插件里面介绍是这样的\n\n```javascript\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或属性\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive(\'my-directive\', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n```\n\n在外面暴露的方法就是install,使用的时候直接Vue.use(\"插件名称\")直接可以使用。我们在install方法里面填写关于指令（directive）和[混合](https://cn.vuejs.org/v2/guide/mixins.html)（mixin），然后对外公开这个方法，option没填写的话就是默认空对象。\n\n```javascript\nimport directive from \'./cores/directive\';\nimport mixin from \'./cores/mixin\';\n\nconst install = ( Vue,options = {} )=>{\n	Vue.mixin(mixin);\n	\n	Vue.directive(\'lazy\',directive);\n\n}\n\nexport default {\n	install\n};\n```\n\n混合主要是为了混入vue内部属性，是除了以上全局方法后又可以在**全局使用**的一种方式。\n\n#### 3.2 编写配置文件\n\nrollup.config.js\n\n```javascript\nimport buble from \'rollup-plugin-buble\';\nimport babel from \'rollup-plugin-babel\';\nimport resolve from \'rollup-plugin-node-resolve\';\nimport commonjs from \'rollup-plugin-commonjs\';\n\nexport default {\n  input: \'src/index.js\',//入口\n  output: {\n    file: \'dist/bundle.js\',//输出的出口\n    format: \'umd\',//格式：表示通用格式\n  },\n  moduleName: \'LazyLoad\',//打包的模块名称，可以再Vue.use()方法使用\n  plugins:[\n  	resolve(),\n  	commonjs(),//支持commonJS\n  	buble(),\n  	babel({//关于ES6\n  		exclude: \'src/**\' // 只编译我们的源代码\n  	})\n  ]\n};\n```\n\npackage.json\n\n```javascript\n{\n  \"name\": \"lazyload\",\n  \"version\": \"1.0.0\",\n  \"description\": \"vue懒加载插件\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"main\": \"rollup -c config/rollup.config.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"TangHy\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"path\": \"^0.12.7\",\n    \"rollup\": \"^0.57.1\"\n  },\n  \"devDependencies\": {\n    \"babel-core\": \"^6.26.0\",\n    \"babel-loader\": \"^7.1.4\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"babel-preset-react\": \"^6.24.1\",\n    \"rollup-plugin-babel\": \"^3.0.3\",\n    \"rollup-plugin-buble\": \"^0.19.2\",\n    \"rollup-plugin-commonjs\": \"^9.1.0\",\n    \"rollup-plugin-node-resolve\": \"^3.3.0\"\n  }\n}\n\n```\n\n注意其中的命令：\n\n```javascript\nrollup -c config/rollup.config.js\n```\n\n后面的config/...是路径，这里注意一下，我们只需要运行\n\n```javascript\nnpm run main\n```\n\n就可以进行打包了。\n\n#### 3.3 编写主程序代码\n\n##### 3.3.1 directive.js\n\n```javascript\nimport eventlistener from \'./cores/eventlistener\'\n\nexport default {\n	inserted: function (el,binding, vnode, oldVnode) {\n		var EventListener = new eventlistener(el,binding, vnode);\n		EventListener.init();\n		EventListener.startListen();\n  },\n	update: function(){\n		\n	},\n	unbind: function(){\n		\n	}\n}\n```\n\n先写生命周期中inserted的时候绑定监听。加入的时候new一个监听对象保存所有包括所有dom的，关于监听的函数如下：\n\n##### 3.3.2 eventlistener.js\n\n```javascript\nimport {isSeen} from \'../utils/utils\'//引入工具类的里面的是否看得见元素这个方法判断\n\nexport default class EventListener {\n  constructor(el,binding,vnode) {\n    this.el = el;//初始化各种需要的属性\n    this.binding = binding;\n    this.vnode = vnode;\n    this.imagebox = null;\n    this.$vm = vnode.context;\n    this.$lazyload = vnode.context.$lazyload//混合mixin进去的选项\n  }\n\n  init(){\n  	this.imagebox = this.vnode.context.imagebox;\n      this.imagebox.add(this.el,this.binding.value);//这里每次一个insert加入一个item\n  }\n\n  startListen(){\n  	const _self = this;\n  	document.addEventListener(\'scroll\',(e)=>{\n	  	_self.listenProcess(e);//这里开始操作\n  	})\n  }\n}\n```\n\n上面主要初始化了很多属性，包括vue的虚拟dom和各种包括el元素dom，binding指令传过来的值等等初始化。\n\n此文件主要为了处理监听页面滚动的，监听**是否图片进入到可视范围内**，然后进行一系列下方的各种操作。\n\n其次加入process的函数`listenProcess`：\n\n```javascript\nconst _self = this;\n  	this.imagebox.item.forEach((item)=>{\n        if(isSeen(item)){//这里判断元素是否看得见\n            var image = new Image();//这里在赋值src前new一个image对象进行缓存，缓冲一下，可以做后续的加载或失败的函数处理\n            image.src = item.src;\n            _self._imageStyle(item);//改变item的样式\n\n            _self.imagebox.addPending(item.ele,item.src);//在对象imagebox中加入了正在pending请求的item(后续会介绍imagebox类)\n\n            image.onload = function(){//加载成功的处理\n                if(image.complete){\n                    _self.imageOnload(item);\n                }\n            }\n\n            image.onerror = function(){//加载失败的处理\n                _self.imageOnerror(item);\n            }\n        }\n    })\n```\n\n还有其余的一些方法：\n\n```javascript\nimageOnload(item){//图片加载完的操作\n  	this._removeImageStyle(item.ele);\n    this.imagebox.addAlready(item.ele,item.src);//添加到已经加载完的item数组里面\n    this._imageSet(item.ele,item.src)\n  }\n\n  imageOnerror(item){//出现错误的时候\n  	this._removeImageStyle(item.ele);\n    this.imagebox.addFailed(item.ele,item.src);//添加到出现错误item数组里面\n    this._imageSet(item.ele,this.$lazyload.options.errorUrl)//把配置中的错误图片url填入\n  }\n\n  _imageStyle(item){\n    this._imageSet(item.ele,this.$lazyload.options.loadUrl)//正在加载的url图片\n    item.ele.style.padding = \'80px\';\n    item.ele.style.boxSizing = \'border-box\';\n  }\n\n  _removeImageStyle(ele){\n  	ele.style = \'\';\n  }\n\n  _imageSet(ele,value){//关于图片赋值src的操作\n    ele.src = value;\n  }\n```\n\n所有的解释都已经写在上面的代码块里面了。\n\n##### 3.3.3 mixin.js\n\n```javascript\nimport imagebox from \'./imagebox\'\n\nconst mixin = {\n	data () {\n      return {\n          imagebox: new imagebox()//这里声明一个new对象，存在全局的变量中，混入vue内部，可以全局使用\n      }\n  }\n}\n\nexport default mixin;\n```\n\n#### 3.4 核心代码\n\n##### 3.4.1 imagebox.js类\n\n```javascript\nexport default class ImageBox {\n  constructor() {\n    this.item = [];\n    this.itemAlready = [];\n    this.itemPending = [];\n    this.itemFailed = [];\n  }\n\n  add(ele,src) {//insert插入的时候把所有的dom加入到数组中去初始化\n  	const index = this.itemAlready.findIndex((_item)=>{\n  		return _item.ele === ele;\n  	})\n  	if(index === -1){\n  		this.item.push({\n	    	ele:ele,\n	    	src:src\n	    })\n  	}\n  }\n\n  addFailed(ele,src){//失败的时候添加到数组\n  	this._addFailed(ele,src);\n  	this._removeFromPending(ele);\n  }\n\n  addPending(ele,src){//正在加载的时候添加到数组\n  	\n  }\n\n  addAlready(ele,src){//加载完的图片dom添加到数组\n  	\n  }\n\n  _addAlready(ele,src) {//私有方法（仅在名称上），添加到数组，下面同理\n  	const index = this.itemAlready.findIndex((_item)=>{\n  		return _item.ele === ele;\n  	})\n  	if(index === -1){\n  		this.itemAlready.push({\n	    	ele:ele,\n	    	src:src\n	    })\n  	}\n  }\n\n  _addPending(ele,src) {\n  	\n  }\n\n  _addFailed(ele,src) {\n  	\n  }\n\n  _remove(ele) {//移除某个dom\n  	\n  }\n\n  _removeFromPending(ele) {\n  	\n  }\n}\n\n```\n\n上述是一个图片的box，用于存取页面加载时候，image图片对象的box存取。主要思路是分了三个数组，**一个存储所有的图片**，**一个存储正在加载的图片**，**一个存储加载失败的图片**，然后最重要的是！！！\n\n**把这个imagebox要混入到全局，使其可以当做全局变量在全局使用。**\n\n##### 3.4.2 lazyload.js\n\n```javascript\nconst DEFAULT_ERROR_URL = \'./404.svg\';\nconst DEFAULT_LOAD_URL = \'./loading-spin.svg\';\n\nexport default class LazyLoad {\n	constructor() {\n    this.options = {\n    	loadUrl: DEFAULT_LOAD_URL,\n    	errorUrl: DEFAULT_ERROR_URL\n    };\n  }\n\n  register(options){\n  	Object.assign(this.options, options);\n  }\n} \n```\n\n此类暂时用来存**储各种配置**和lazy的预定默认值，options里面存加载的时候的图片地址和错误加载的时候的图片地址。\n\n默认值是最上面两个值，是不传数据默认的配置。\n\n### 四、2018年6月17号更新\n\n#### 4.1 指令的更新（update）生命周期\n\n之前编写的代码有很多瑕疵，比如insert之后，如果图片的源值改变后，你会发现无法改变视图，因为update里面没有写相关程序。\n\n思路很简单，就是如果你指令的值改变了后，就进行一个数组遍历，遍历所有insert进去的元素，一个个对比，如果值改变了，只需要把他们加到item(总item数组)就可以了。\n\n因为之前的思路是遍历item的数组进行请求，所以只要item里面有值，就会去进行请求。改变后代码如下：\n\ndirective.js\n\n```javascript\nimport eventlistener from \'./cores/eventlistener\'\n\nvar listener = null;\n\nexport default {\n\n	inserted: function (el,binding, vnode, oldVnode) {\n		var EventListener = new eventlistener(el,binding, vnode);\n		listener = EventListener;\n		EventListener.init();\n		EventListener.startListen();\n  },\n	update: function(el,{name,value,oldValue,expression}, vnode, oldVnode){\n		if(value === oldValue){\n			return;\n		}\n		listener.update(el,value);\n	},\n	unbind: function(){\n		listener.removeListen();\n	}\n}\n```\n\nimagebox.js\n\n```javascript\nexport default class ImageBox {\n  constructor() {\n    this.eleAll = [];\n    this.item = [];\n    this.itemAlready = [];\n    this.itemPending = [];\n    this.itemFailed = [];\n  }\n\n  add(ele,src) {\n  	const index = this.itemAlready.findIndex((_item)=>{\n  		return _item.ele === ele;\n  	})\n  	if(index === -1){\n  		this.item.push({\n	    	ele:ele,\n	    	src:src\n	    })\n  	}\n  }\n\n  update(ele,src){\n    let index = this.itemAlready.findIndex(item=>{\n      return item.ele === ele;\n    });\n\n    if(index != -1){\n      this.itemAlready.splice(index,1);\n      this.add(ele,src);\n      return;\n    };\n\n    let _index = this.itemFailed.findIndex(item=>{\n      return item.ele === ele;\n    });\n\n    if(_index !=-1){\n      this.itemFailed.splice(_index,1);\n      this.add(ele,src);\n      return;\n    };\n\n  }\n\n  addFailed(ele,src){\n  	this._addFailed(ele,src);\n  	this._removeFromPending(ele);\n  }\n\n  addPending(ele,src){\n  	this._addPending(ele,src);\n  	this._remove(ele);\n  }\n\n  addAlready(ele,src){\n  	this._addAlready(ele,src);\n  	this._removeFromPending(ele);\n  }\n\n  _addAlready(ele,src) {\n  	const index = this.itemAlready.findIndex((_item)=>{\n  		return _item.ele === ele;\n  	})\n  	if(index === -1){\n  		this.itemAlready.push({\n	    	ele:ele,\n	    	src:src\n	    })\n  	}\n  }\n\n  _addPending(ele,src) {\n  	const index = this.itemPending.findIndex((_item)=>{\n  		return _item.ele === ele;\n  	})\n  	if(index === -1){\n  		this.itemPending.push({\n	    	ele:ele,\n	    	src:src\n	    })\n  	}\n  }\n\n  _addFailed(ele,src) {\n  	const index = this.itemFailed.findIndex((_item)=>{\n  		return _item.ele === ele;\n  	})\n  	if(index === -1){\n  		this.itemFailed.push({\n	    	ele:ele,\n	    	src:src\n	    })\n  	}\n  }\n\n  _remove(ele) {\n  	const index = this.item.findIndex((_item)=>{\n  		return _item.ele === ele;\n  	});\n  	if(index!=-1){\n  		this.item.splice(index,1);\n  	}\n  }\n\n  _removeFromPending(ele) {\n  	const index = this.itemPending.findIndex((_item)=>{\n  		return _item.ele === ele;\n  	});\n  	if(index!=-1){\n  		this.itemPending.splice(index,1);\n  	}\n  }\n}\n\n```\n\neventlistener.js\n\n```javascript\nimport {isSeen} from \'../utils/utils\'\n\nexport default class EventListener {\n  constructor(el,binding,vnode) {\n    this.el = el;\n    this.binding = binding;\n    this.vnode = vnode;\n    this.imagebox = null;\n    this.$vm = vnode.context;\n    this.$lazyload = vnode.context.$lazyload\n  }\n\n  init(){\n  	this.imagebox = this.vnode.context.imagebox;\n		this.imagebox.add(this.el,this.binding.value);\n    this.listenProcess();\n  }\n\n  startListen(){\n    var listenProcess = this.listenProcess;\n  	window.addEventListener(\'scroll\',listenProcess.bind(this),false);\n  }\n\n  removeListen(){\n    var listenProcess = this.listenProcess;\n    window.removeEventListener(\'scroll\',listenProcess.bind(this),false);\n  }\n\n  listenProcess(){\n  	const _self = this;\n    if(this.imagebox.item.length == 0){\n      return;\n    }\n\n  	this.imagebox.item.forEach((item)=>{\n			if(isSeen(item)){\n\n				var image = new Image();\n	      image.src = item.src;\n	      _self._imageStyle(item);\n	      \n	      _self.imagebox.addPending(item.ele,item.src);\n\n	      image.onload = function(){\n	        if(image.complete){\n	        	_self.imageOnload(item);\n	        }\n	      }\n\n	      image.onerror = function(){\n	        _self.imageOnerror(item);\n	      }\n			}\n		})\n  }\n\n  update(ele,src){\n    this.imagebox.update(ele,src);\n    this.listenProcess();\n  }\n\n  imageOnload(item){\n  	this._removeImageStyle(item.ele);\n    this.imagebox.addAlready(item.ele,item.src);\n    this._imageSet(item.ele,item.src)\n  }\n\n  imageOnerror(item){\n  	this._removeImageStyle(item.ele);\n    this.imagebox.addFailed(item.ele,item.src);\n    this._imageSet(item.ele,this.$lazyload.options.errorUrl)\n  }\n\n  _imageStyle(item){\n    // this._imageSet(item.ele,this.$lazyload.options.loadUrl);\n    item.ele.style.background = `url(${this.$lazyload.options.loadUrl}) no-repeat center`;\n  }\n\n  _removeImageStyle(ele){\n  	ele.style.background = \'\';\n  }\n\n  _imageSet(ele,value){\n    ele.src = value;\n  }\n}\n\n```\n\nutils.js\n\n```javascript\nconst isSeen = function(item,imagebox){\n  var ele = item.ele;\n  var src = item.src;\n  //图片距离页面顶部的距离\n  var top = ele.getBoundingClientRect().top;\n  //页面可视区域的高度\n  var windowHeight = document.documentElement.clientHeight || document.body.clientHeight;\n  //top + 10 已经进入了可视区域10像素\n  if(top + 10 < windowHeight){\n      return true;\n  }else{\n      return false;\n  }\n}\n\nexport {\n  isSeen\n};\n```\n\n\n\n### 五、打包成.js可以外部直接引用\n\n打包后的代码：**[lazyload.js](http://www.tangyida.top/static/study/lazyload.js)**\n\n#### 使用方法\n\n```javascript\nVue.use(LazyLoad,{\n    loadUrl:\'./loading-spin.svg\',//这里写你的加载时候的图片配置\n    errorUrl:\'./404.svg\'//错误加载的图片配置\n});\n```\n\n#### 元素中使用指令\n\n```javascript\n<img v-lazy=\"item\" v-for=\"(item,$key) in imageArr\">\n```\n\n#### imageArr测试数据\n\n```javascript\nimageArr:[\n	\'http://covteam.u.qiniudn.com/test16.jpg?imageView2/2/format/webp\',\n	\'http://covteam.u.qiniudn.com/test14.jpg?imageView2/2/format/webp\',\n	\'http://covteam.u.qiniudn.com/test15.jpg?imageView2/2/format/webp\',\n	\'http://covteam.u.qiniudn.com/test17.jpg?imageView2/2/format/webp\',\n	\'http://hilongjw.github.io/vue-lazyload/dist/test9.jpg\',\n	\'http://hilongjw.github.io/vue-lazyload/dist/test10.jpg\',\n	\'http://hilongjw.github.io/vue-lazyload/dist/test14.jpg\'\n]\n```\n\n测试地址：[戳我戳我](http://www.tangyida.top/static/study/lazyload/test.html)\n\n### 五、后记\n\n其实这些代码的编写还是比较简单的，写完过后进行总结，你会发现，其中最难的是：\n\n**整个项目的结构，和代码模块之间的逻辑关系**。\n\n这个才是最难掌握的，如果涉及到大一点的项目，好一点的项目结构能让整个项目进度等等因素发生巨大的变化，提升巨大的效率。而写插件最难的就是在这。\n\n**如何有效地拆分代码？如何有效地进行项目结构的构造?** 这才是整个插件编写的核心。\n\n之前写过一个vue关于表单验证的插件，也是被项目结构搞得焦头烂额。还有写过一个cordova的插件，遵循它的插件规范。\n\n所以我深知写插件的时候，它结构和模块化的重要性。而结构和模块化的优秀，会让你事半功倍。当你经验积累到一定程度的时候，你会发现，你也可以写框架了。', '2022-09-26 15:03:36', '2022-09-27 14:51:02', '<h3><a id=\"_2\"></a>前言</h3>\n<blockquote>\n<p>闲来无事，想自己开发一个简单的Vue懒加载插件，能力的提升我觉得是可以通过编写插件实现，研究了一下官网的<a href=\"https://cn.vuejs.org/v2/guide/plugins.html\" target=\"_blank\">Vue插件</a>编写。马上自己独立开始编写懒加载插件。</p>\n</blockquote>\n<h3><a id=\"_6\"></a>一、写在前面</h3>\n<p>在这阐述一下本人的观念，我一直推崇一些高度定制化的插件，一些小Demo，是需要自己写的，不能崇尚“拿来主义”。有些插件网上都有，但是你用了会发现谁都会用，而且有时候对于自己的需求又不够贴合。</p>\n<p>等到自己需要写一个插件的时候，却无从下手。但是如果你练习了插件编写后，收获往小了讲，就是可以自己写一个小插件，往大了讲，你能力到达一定地步你是可以写一个框架的。</p>\n<p>所以，练习写插件和小框架能力非常重要！也就基本注定了你的代码生涯。</p>\n<h3><a id=\"_14\"></a>二、前期准备</h3>\n<h4><a id=\"21__16\"></a>2.1 选择合适的打包工具</h4>\n<p>合适的打包工具可以达到事半功倍的效果。一开始我的首选有两个，一个是webpack，一个是rollup。下面简单介绍一下我为什么选择了rollup。</p>\n<p>众所周知，webpack是一个几乎囊括了所有<strong>静态资源</strong>，可以<strong>动态按需加载</strong>的一个包工具。而rollup也是一个模块打包器，可以把一个大块复杂的代码拆分成各个小模块。</p>\n<p>深思熟虑后，我觉得webpack也可以打包，但是首先，有点“杀鸡焉用牛刀”的感觉。而我的这个懒加载插件则需要提供给别人使用，同时又要保证整个插件的“轻量性”（打包完大概6KB，而webpack则比较大），不喜欢像webpack那样在这插件上臃肿的表现。</p>\n<p>对于非应用级的程序，我比较倾向于使用rollup.js。</p>\n<h4><a id=\"22__26\"></a>2.2 确认项目结构</h4>\n<pre><div class=\"hljs\"><code class=\"lang-json\">|——package.json\n|——config\n|	|——rollup.config.js\n|——dist\n|	|——bundle.js\n|——src\n|	|——index.js\n|	|——directive.js\n|	|——mixin.js\n|	|——utils\n|	|	|——utils.js\n|	|——cores\n|		|——lazyload.js\n|		|——imagebox.js\n</code></div></pre>\n<p>config文件夹下放置rollup的配置文件。src为源文件夹，cores下面的文件夹为主要的模块，utils为工具类，主要是一些可以通用的模块方法。大概的结构就是这样。</p>\n<h4><a id=\"23__47\"></a>2.3 编写思路</h4>\n<p>懒加载的实现过程，我们这里先精简化。具体思路如下：</p>\n<p>=》<strong>把所有用指令绑定的元素添加数组初始化</strong></p>\n<p>=》<strong>监听滚动条滚动</strong></p>\n<p>=》<strong>判断元素是否进入可视范围</strong></p>\n<p>=》<strong>如果进入可视范围，进行src预加载（存入缓存数组）</strong></p>\n<p>=》<strong>对于pending的图片，进行正在加载赋值，对于finsh完的图片，加载预加载src里面的值，对于error的图片，进行错误图片src赋值</strong></p>\n<h3><a id=\"_61\"></a>三、主要代码的编写</h3>\n<h4><a id=\"31__63\"></a>3.1 确认入口文件</h4>\n<p><a href=\"https://cn.vuejs.org/v2/guide/plugins.html\" target=\"_blank\">Vue</a>插件里面介绍是这样的</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-title class_\">MyPlugin</span>.<span class=\"hljs-property\">install</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Vue, options</span>) {\n  <span class=\"hljs-comment\">// 1. 添加全局方法或属性</span>\n  <span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-property\">myGlobalMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 逻辑...</span>\n  }\n\n  <span class=\"hljs-comment\">// 2. 添加全局资源</span>\n  <span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">directive</span>(<span class=\"hljs-string\">&#x27;my-directive&#x27;</span>, {\n    bind (el, binding, vnode, oldVnode) {\n      <span class=\"hljs-comment\">// 逻辑...</span>\n    }\n    ...\n  })\n\n  <span class=\"hljs-comment\">// 3. 注入组件</span>\n  <span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">mixin</span>({\n    <span class=\"hljs-attr\">created</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// 逻辑...</span>\n    }\n    ...\n  })\n\n  <span class=\"hljs-comment\">// 4. 添加实例方法</span>\n  <span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">$myMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">methodOptions</span>) {\n    <span class=\"hljs-comment\">// 逻辑...</span>\n  }\n}\n</code></div></pre>\n<p>在外面暴露的方法就是install,使用的时候直接Vue.use(“插件名称”)直接可以使用。我们在install方法里面填写关于指令（directive）和<a href=\"https://cn.vuejs.org/v2/guide/mixins.html\" target=\"_blank\">混合</a>（mixin），然后对外公开这个方法，option没填写的话就是默认空对象。</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> directive <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./cores/directive&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> mixin <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./cores/mixin&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">install</span> = (<span class=\"hljs-params\"> Vue,options = {} </span>)=&gt;{\n	<span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">mixin</span>(mixin);\n	\n	<span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">directive</span>(<span class=\"hljs-string\">&#x27;lazy&#x27;</span>,directive);\n\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n	install\n};\n</code></div></pre>\n<p>混合主要是为了混入vue内部属性，是除了以上全局方法后又可以在<strong>全局使用</strong>的一种方式。</p>\n<h4><a id=\"32__117\"></a>3.2 编写配置文件</h4>\n<p>rollup.config.js</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> buble <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rollup-plugin-buble&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> babel <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rollup-plugin-babel&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> resolve <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rollup-plugin-node-resolve&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> commonjs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rollup-plugin-commonjs&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;src/index.js&#x27;</span>,<span class=\"hljs-comment\">//入口</span>\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">&#x27;dist/bundle.js&#x27;</span>,<span class=\"hljs-comment\">//输出的出口</span>\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">&#x27;umd&#x27;</span>,<span class=\"hljs-comment\">//格式：表示通用格式</span>\n  },\n  <span class=\"hljs-attr\">moduleName</span>: <span class=\"hljs-string\">&#x27;LazyLoad&#x27;</span>,<span class=\"hljs-comment\">//打包的模块名称，可以再Vue.use()方法使用</span>\n  <span class=\"hljs-attr\">plugins</span>:[\n  	<span class=\"hljs-title function_\">resolve</span>(),\n  	<span class=\"hljs-title function_\">commonjs</span>(),<span class=\"hljs-comment\">//支持commonJS</span>\n  	<span class=\"hljs-title function_\">buble</span>(),\n  	<span class=\"hljs-title function_\">babel</span>({<span class=\"hljs-comment\">//关于ES6</span>\n  		<span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-string\">&#x27;src/**&#x27;</span> <span class=\"hljs-comment\">// 只编译我们的源代码</span>\n  	})\n  ]\n};\n</code></div></pre>\n<p>package.json</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">{\n  <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;lazyload&quot;</span>,\n  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,\n  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;vue懒加载插件&quot;</span>,\n  <span class=\"hljs-string\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;index.js&quot;</span>,\n  <span class=\"hljs-string\">&quot;scripts&quot;</span>: {\n    <span class=\"hljs-string\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;rollup -c config/rollup.config.js&quot;</span>,\n    <span class=\"hljs-string\">&quot;test&quot;</span>: <span class=\"hljs-string\">&quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span>\n  },\n  <span class=\"hljs-string\">&quot;author&quot;</span>: <span class=\"hljs-string\">&quot;TangHy&quot;</span>,\n  <span class=\"hljs-string\">&quot;license&quot;</span>: <span class=\"hljs-string\">&quot;MIT&quot;</span>,\n  <span class=\"hljs-string\">&quot;dependencies&quot;</span>: {\n    <span class=\"hljs-string\">&quot;path&quot;</span>: <span class=\"hljs-string\">&quot;^0.12.7&quot;</span>,\n    <span class=\"hljs-string\">&quot;rollup&quot;</span>: <span class=\"hljs-string\">&quot;^0.57.1&quot;</span>\n  },\n  <span class=\"hljs-string\">&quot;devDependencies&quot;</span>: {\n    <span class=\"hljs-string\">&quot;babel-core&quot;</span>: <span class=\"hljs-string\">&quot;^6.26.0&quot;</span>,\n    <span class=\"hljs-string\">&quot;babel-loader&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.4&quot;</span>,\n    <span class=\"hljs-string\">&quot;babel-preset-env&quot;</span>: <span class=\"hljs-string\">&quot;^1.6.1&quot;</span>,\n    <span class=\"hljs-string\">&quot;babel-preset-react&quot;</span>: <span class=\"hljs-string\">&quot;^6.24.1&quot;</span>,\n    <span class=\"hljs-string\">&quot;rollup-plugin-babel&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.3&quot;</span>,\n    <span class=\"hljs-string\">&quot;rollup-plugin-buble&quot;</span>: <span class=\"hljs-string\">&quot;^0.19.2&quot;</span>,\n    <span class=\"hljs-string\">&quot;rollup-plugin-commonjs&quot;</span>: <span class=\"hljs-string\">&quot;^9.1.0&quot;</span>,\n    <span class=\"hljs-string\">&quot;rollup-plugin-node-resolve&quot;</span>: <span class=\"hljs-string\">&quot;^3.3.0&quot;</span>\n  }\n}\n\n</code></div></pre>\n<p>注意其中的命令：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">rollup -c config/rollup.<span class=\"hljs-property\">config</span>.<span class=\"hljs-property\">js</span>\n</code></div></pre>\n<p>后面的config/…是路径，这里注意一下，我们只需要运行</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">npm run main\n</code></div></pre>\n<p>就可以进行打包了。</p>\n<h4><a id=\"33__191\"></a>3.3 编写主程序代码</h4>\n<h5><a id=\"331_directivejs_193\"></a>3.3.1 directive.js</h5>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> eventlistener <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./cores/eventlistener&#x27;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n	<span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el,binding, vnode, oldVnode</span>) {\n		<span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">EventListener</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">eventlistener</span>(el,binding, vnode);\n		<span class=\"hljs-title class_\">EventListener</span>.<span class=\"hljs-title function_\">init</span>();\n		<span class=\"hljs-title class_\">EventListener</span>.<span class=\"hljs-title function_\">startListen</span>();\n  },\n	<span class=\"hljs-attr\">update</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n		\n	},\n	<span class=\"hljs-attr\">unbind</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n		\n	}\n}\n</code></div></pre>\n<p>先写生命周期中inserted的时候绑定监听。加入的时候new一个监听对象保存所有包括所有dom的，关于监听的函数如下：</p>\n<h5><a id=\"332_eventlistenerjs_215\"></a>3.3.2 eventlistener.js</h5>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> {isSeen} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../utils/utils&#x27;</span><span class=\"hljs-comment\">//引入工具类的里面的是否看得见元素这个方法判断</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EventListener</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">el,binding,vnode</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">el</span> = el;<span class=\"hljs-comment\">//初始化各种需要的属性</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">binding</span> = binding;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vnode</span> = vnode;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span> = <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span> = vnode.<span class=\"hljs-property\">context</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$lazyload</span> = vnode.<span class=\"hljs-property\">context</span>.<span class=\"hljs-property\">$lazyload</span><span class=\"hljs-comment\">//混合mixin进去的选项</span>\n  }\n\n  <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\"></span>){\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vnode</span>.<span class=\"hljs-property\">context</span>.<span class=\"hljs-property\">imagebox</span>;\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">el</span>,<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">binding</span>.<span class=\"hljs-property\">value</span>);<span class=\"hljs-comment\">//这里每次一个insert加入一个item</span>\n  }\n\n  <span class=\"hljs-title function_\">startListen</span>(<span class=\"hljs-params\"></span>){\n  	<span class=\"hljs-keyword\">const</span> _self = <span class=\"hljs-variable language_\">this</span>;\n  	<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;scroll&#x27;</span>,<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>)=&gt;</span>{\n	  	_self.<span class=\"hljs-title function_\">listenProcess</span>(e);<span class=\"hljs-comment\">//这里开始操作</span>\n  	})\n  }\n}\n</code></div></pre>\n<p>上面主要初始化了很多属性，包括vue的虚拟dom和各种包括el元素dom，binding指令传过来的值等等初始化。</p>\n<p>此文件主要为了处理监听页面滚动的，监听<strong>是否图片进入到可视范围内</strong>，然后进行一系列下方的各种操作。</p>\n<p>其次加入process的函数<code>listenProcess</code>：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">const</span> _self = <span class=\"hljs-variable language_\">this</span>;\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-property\">item</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>)=&gt;</span>{\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-title function_\">isSeen</span>(item)){<span class=\"hljs-comment\">//这里判断元素是否看得见</span>\n            <span class=\"hljs-keyword\">var</span> image = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Image</span>();<span class=\"hljs-comment\">//这里在赋值src前new一个image对象进行缓存，缓冲一下，可以做后续的加载或失败的函数处理</span>\n            image.<span class=\"hljs-property\">src</span> = item.<span class=\"hljs-property\">src</span>;\n            _self.<span class=\"hljs-title function_\">_imageStyle</span>(item);<span class=\"hljs-comment\">//改变item的样式</span>\n\n            _self.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">addPending</span>(item.<span class=\"hljs-property\">ele</span>,item.<span class=\"hljs-property\">src</span>);<span class=\"hljs-comment\">//在对象imagebox中加入了正在pending请求的item(后续会介绍imagebox类)</span>\n\n            image.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-comment\">//加载成功的处理</span>\n                <span class=\"hljs-keyword\">if</span>(image.<span class=\"hljs-property\">complete</span>){\n                    _self.<span class=\"hljs-title function_\">imageOnload</span>(item);\n                }\n            }\n\n            image.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-comment\">//加载失败的处理</span>\n                _self.<span class=\"hljs-title function_\">imageOnerror</span>(item);\n            }\n        }\n    })\n</code></div></pre>\n<p>还有其余的一些方法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-title function_\">imageOnload</span>(<span class=\"hljs-params\">item</span>){<span class=\"hljs-comment\">//图片加载完的操作</span>\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_removeImageStyle</span>(item.<span class=\"hljs-property\">ele</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">addAlready</span>(item.<span class=\"hljs-property\">ele</span>,item.<span class=\"hljs-property\">src</span>);<span class=\"hljs-comment\">//添加到已经加载完的item数组里面</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_imageSet</span>(item.<span class=\"hljs-property\">ele</span>,item.<span class=\"hljs-property\">src</span>)\n  }\n\n  <span class=\"hljs-title function_\">imageOnerror</span>(<span class=\"hljs-params\">item</span>){<span class=\"hljs-comment\">//出现错误的时候</span>\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_removeImageStyle</span>(item.<span class=\"hljs-property\">ele</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">addFailed</span>(item.<span class=\"hljs-property\">ele</span>,item.<span class=\"hljs-property\">src</span>);<span class=\"hljs-comment\">//添加到出现错误item数组里面</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_imageSet</span>(item.<span class=\"hljs-property\">ele</span>,<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$lazyload</span>.<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">errorUrl</span>)<span class=\"hljs-comment\">//把配置中的错误图片url填入</span>\n  }\n\n  <span class=\"hljs-title function_\">_imageStyle</span>(<span class=\"hljs-params\">item</span>){\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_imageSet</span>(item.<span class=\"hljs-property\">ele</span>,<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$lazyload</span>.<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">loadUrl</span>)<span class=\"hljs-comment\">//正在加载的url图片</span>\n    item.<span class=\"hljs-property\">ele</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">padding</span> = <span class=\"hljs-string\">&#x27;80px&#x27;</span>;\n    item.<span class=\"hljs-property\">ele</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">boxSizing</span> = <span class=\"hljs-string\">&#x27;border-box&#x27;</span>;\n  }\n\n  <span class=\"hljs-title function_\">_removeImageStyle</span>(<span class=\"hljs-params\">ele</span>){\n  	ele.<span class=\"hljs-property\">style</span> = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  }\n\n  <span class=\"hljs-title function_\">_imageSet</span>(<span class=\"hljs-params\">ele,value</span>){<span class=\"hljs-comment\">//关于图片赋值src的操作</span>\n    ele.<span class=\"hljs-property\">src</span> = value;\n  }\n</code></div></pre>\n<p>所有的解释都已经写在上面的代码块里面了。</p>\n<h5><a id=\"333_mixinjs_305\"></a>3.3.3 mixin.js</h5>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> imagebox <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./imagebox&#x27;</span>\n\n<span class=\"hljs-keyword\">const</span> mixin = {\n	data () {\n      <span class=\"hljs-keyword\">return</span> {\n          <span class=\"hljs-attr\">imagebox</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">imagebox</span>()<span class=\"hljs-comment\">//这里声明一个new对象，存在全局的变量中，混入vue内部，可以全局使用</span>\n      }\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> mixin;\n</code></div></pre>\n<h4><a id=\"34__321\"></a>3.4 核心代码</h4>\n<h5><a id=\"341_imageboxjs_323\"></a>3.4.1 imagebox.js类</h5>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ImageBox</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">item</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemPending</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemFailed</span> = [];\n  }\n\n  <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">ele,src</span>) {<span class=\"hljs-comment\">//insert插入的时候把所有的dom加入到数组中去初始化</span>\n  	<span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_item</span>)=&gt;</span>{\n  		<span class=\"hljs-keyword\">return</span> _item.<span class=\"hljs-property\">ele</span> === ele;\n  	})\n  	<span class=\"hljs-keyword\">if</span>(index === -<span class=\"hljs-number\">1</span>){\n  		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">item</span>.<span class=\"hljs-title function_\">push</span>({\n	    	<span class=\"hljs-attr\">ele</span>:ele,\n	    	<span class=\"hljs-attr\">src</span>:src\n	    })\n  	}\n  }\n\n  <span class=\"hljs-title function_\">addFailed</span>(<span class=\"hljs-params\">ele,src</span>){<span class=\"hljs-comment\">//失败的时候添加到数组</span>\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_addFailed</span>(ele,src);\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_removeFromPending</span>(ele);\n  }\n\n  <span class=\"hljs-title function_\">addPending</span>(<span class=\"hljs-params\">ele,src</span>){<span class=\"hljs-comment\">//正在加载的时候添加到数组</span>\n  	\n  }\n\n  <span class=\"hljs-title function_\">addAlready</span>(<span class=\"hljs-params\">ele,src</span>){<span class=\"hljs-comment\">//加载完的图片dom添加到数组</span>\n  	\n  }\n\n  <span class=\"hljs-title function_\">_addAlready</span>(<span class=\"hljs-params\">ele,src</span>) {<span class=\"hljs-comment\">//私有方法（仅在名称上），添加到数组，下面同理</span>\n  	<span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_item</span>)=&gt;</span>{\n  		<span class=\"hljs-keyword\">return</span> _item.<span class=\"hljs-property\">ele</span> === ele;\n  	})\n  	<span class=\"hljs-keyword\">if</span>(index === -<span class=\"hljs-number\">1</span>){\n  		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span>.<span class=\"hljs-title function_\">push</span>({\n	    	<span class=\"hljs-attr\">ele</span>:ele,\n	    	<span class=\"hljs-attr\">src</span>:src\n	    })\n  	}\n  }\n\n  <span class=\"hljs-title function_\">_addPending</span>(<span class=\"hljs-params\">ele,src</span>) {\n  	\n  }\n\n  <span class=\"hljs-title function_\">_addFailed</span>(<span class=\"hljs-params\">ele,src</span>) {\n  	\n  }\n\n  <span class=\"hljs-title function_\">_remove</span>(<span class=\"hljs-params\">ele</span>) {<span class=\"hljs-comment\">//移除某个dom</span>\n  	\n  }\n\n  <span class=\"hljs-title function_\">_removeFromPending</span>(<span class=\"hljs-params\">ele</span>) {\n  	\n  }\n}\n\n</code></div></pre>\n<p>上述是一个图片的box，用于存取页面加载时候，image图片对象的box存取。主要思路是分了三个数组，<strong>一个存储所有的图片</strong>，<strong>一个存储正在加载的图片</strong>，<strong>一个存储加载失败的图片</strong>，然后最重要的是！！！</p>\n<p><strong>把这个imagebox要混入到全局，使其可以当做全局变量在全局使用。</strong></p>\n<h5><a id=\"342_lazyloadjs_394\"></a>3.4.2 lazyload.js</h5>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">DEFAULT_ERROR_URL</span> = <span class=\"hljs-string\">&#x27;./404.svg&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">DEFAULT_LOAD_URL</span> = <span class=\"hljs-string\">&#x27;./loading-spin.svg&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LazyLoad</span> {\n	<span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">options</span> = {\n    	<span class=\"hljs-attr\">loadUrl</span>: <span class=\"hljs-variable constant_\">DEFAULT_LOAD_URL</span>,\n    	<span class=\"hljs-attr\">errorUrl</span>: <span class=\"hljs-variable constant_\">DEFAULT_ERROR_URL</span>\n    };\n  }\n\n  <span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\">options</span>){\n  	<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">options</span>, options);\n  }\n} \n</code></div></pre>\n<p>此类暂时用来存<strong>储各种配置</strong>和lazy的预定默认值，options里面存加载的时候的图片地址和错误加载的时候的图片地址。</p>\n<p>默认值是最上面两个值，是不传数据默认的配置。</p>\n<h3><a id=\"2018617_418\"></a>四、2018年6月17号更新</h3>\n<h4><a id=\"41_update_420\"></a>4.1 指令的更新（update）生命周期</h4>\n<p>之前编写的代码有很多瑕疵，比如insert之后，如果图片的源值改变后，你会发现无法改变视图，因为update里面没有写相关程序。</p>\n<p>思路很简单，就是如果你指令的值改变了后，就进行一个数组遍历，遍历所有insert进去的元素，一个个对比，如果值改变了，只需要把他们加到item(总item数组)就可以了。</p>\n<p>因为之前的思路是遍历item的数组进行请求，所以只要item里面有值，就会去进行请求。改变后代码如下：</p>\n<p>directive.js</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> eventlistener <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./cores/eventlistener&#x27;</span>\n\n<span class=\"hljs-keyword\">var</span> listener = <span class=\"hljs-literal\">null</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n\n	<span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el,binding, vnode, oldVnode</span>) {\n		<span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">EventListener</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">eventlistener</span>(el,binding, vnode);\n		listener = <span class=\"hljs-title class_\">EventListener</span>;\n		<span class=\"hljs-title class_\">EventListener</span>.<span class=\"hljs-title function_\">init</span>();\n		<span class=\"hljs-title class_\">EventListener</span>.<span class=\"hljs-title function_\">startListen</span>();\n  },\n	<span class=\"hljs-attr\">update</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">el,{name,value,oldValue,expression}, vnode, oldVnode</span>){\n		<span class=\"hljs-keyword\">if</span>(value === oldValue){\n			<span class=\"hljs-keyword\">return</span>;\n		}\n		listener.<span class=\"hljs-title function_\">update</span>(el,value);\n	},\n	<span class=\"hljs-attr\">unbind</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n		listener.<span class=\"hljs-title function_\">removeListen</span>();\n	}\n}\n</code></div></pre>\n<p>imagebox.js</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ImageBox</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eleAll</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">item</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemPending</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemFailed</span> = [];\n  }\n\n  <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">ele,src</span>) {\n  	<span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_item</span>)=&gt;</span>{\n  		<span class=\"hljs-keyword\">return</span> _item.<span class=\"hljs-property\">ele</span> === ele;\n  	})\n  	<span class=\"hljs-keyword\">if</span>(index === -<span class=\"hljs-number\">1</span>){\n  		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">item</span>.<span class=\"hljs-title function_\">push</span>({\n	    	<span class=\"hljs-attr\">ele</span>:ele,\n	    	<span class=\"hljs-attr\">src</span>:src\n	    })\n  	}\n  }\n\n  <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\">ele,src</span>){\n    <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>=&gt;</span>{\n      <span class=\"hljs-keyword\">return</span> item.<span class=\"hljs-property\">ele</span> === ele;\n    });\n\n    <span class=\"hljs-keyword\">if</span>(index != -<span class=\"hljs-number\">1</span>){\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span>.<span class=\"hljs-title function_\">splice</span>(index,<span class=\"hljs-number\">1</span>);\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">add</span>(ele,src);\n      <span class=\"hljs-keyword\">return</span>;\n    };\n\n    <span class=\"hljs-keyword\">let</span> _index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemFailed</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>=&gt;</span>{\n      <span class=\"hljs-keyword\">return</span> item.<span class=\"hljs-property\">ele</span> === ele;\n    });\n\n    <span class=\"hljs-keyword\">if</span>(_index !=-<span class=\"hljs-number\">1</span>){\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemFailed</span>.<span class=\"hljs-title function_\">splice</span>(_index,<span class=\"hljs-number\">1</span>);\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">add</span>(ele,src);\n      <span class=\"hljs-keyword\">return</span>;\n    };\n\n  }\n\n  <span class=\"hljs-title function_\">addFailed</span>(<span class=\"hljs-params\">ele,src</span>){\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_addFailed</span>(ele,src);\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_removeFromPending</span>(ele);\n  }\n\n  <span class=\"hljs-title function_\">addPending</span>(<span class=\"hljs-params\">ele,src</span>){\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_addPending</span>(ele,src);\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_remove</span>(ele);\n  }\n\n  <span class=\"hljs-title function_\">addAlready</span>(<span class=\"hljs-params\">ele,src</span>){\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_addAlready</span>(ele,src);\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_removeFromPending</span>(ele);\n  }\n\n  <span class=\"hljs-title function_\">_addAlready</span>(<span class=\"hljs-params\">ele,src</span>) {\n  	<span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_item</span>)=&gt;</span>{\n  		<span class=\"hljs-keyword\">return</span> _item.<span class=\"hljs-property\">ele</span> === ele;\n  	})\n  	<span class=\"hljs-keyword\">if</span>(index === -<span class=\"hljs-number\">1</span>){\n  		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemAlready</span>.<span class=\"hljs-title function_\">push</span>({\n	    	<span class=\"hljs-attr\">ele</span>:ele,\n	    	<span class=\"hljs-attr\">src</span>:src\n	    })\n  	}\n  }\n\n  <span class=\"hljs-title function_\">_addPending</span>(<span class=\"hljs-params\">ele,src</span>) {\n  	<span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemPending</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_item</span>)=&gt;</span>{\n  		<span class=\"hljs-keyword\">return</span> _item.<span class=\"hljs-property\">ele</span> === ele;\n  	})\n  	<span class=\"hljs-keyword\">if</span>(index === -<span class=\"hljs-number\">1</span>){\n  		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemPending</span>.<span class=\"hljs-title function_\">push</span>({\n	    	<span class=\"hljs-attr\">ele</span>:ele,\n	    	<span class=\"hljs-attr\">src</span>:src\n	    })\n  	}\n  }\n\n  <span class=\"hljs-title function_\">_addFailed</span>(<span class=\"hljs-params\">ele,src</span>) {\n  	<span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemFailed</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_item</span>)=&gt;</span>{\n  		<span class=\"hljs-keyword\">return</span> _item.<span class=\"hljs-property\">ele</span> === ele;\n  	})\n  	<span class=\"hljs-keyword\">if</span>(index === -<span class=\"hljs-number\">1</span>){\n  		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemFailed</span>.<span class=\"hljs-title function_\">push</span>({\n	    	<span class=\"hljs-attr\">ele</span>:ele,\n	    	<span class=\"hljs-attr\">src</span>:src\n	    })\n  	}\n  }\n\n  <span class=\"hljs-title function_\">_remove</span>(<span class=\"hljs-params\">ele</span>) {\n  	<span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">item</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_item</span>)=&gt;</span>{\n  		<span class=\"hljs-keyword\">return</span> _item.<span class=\"hljs-property\">ele</span> === ele;\n  	});\n  	<span class=\"hljs-keyword\">if</span>(index!=-<span class=\"hljs-number\">1</span>){\n  		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">item</span>.<span class=\"hljs-title function_\">splice</span>(index,<span class=\"hljs-number\">1</span>);\n  	}\n  }\n\n  <span class=\"hljs-title function_\">_removeFromPending</span>(<span class=\"hljs-params\">ele</span>) {\n  	<span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemPending</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_item</span>)=&gt;</span>{\n  		<span class=\"hljs-keyword\">return</span> _item.<span class=\"hljs-property\">ele</span> === ele;\n  	});\n  	<span class=\"hljs-keyword\">if</span>(index!=-<span class=\"hljs-number\">1</span>){\n  		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">itemPending</span>.<span class=\"hljs-title function_\">splice</span>(index,<span class=\"hljs-number\">1</span>);\n  	}\n  }\n}\n\n</code></div></pre>\n<p>eventlistener.js</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> {isSeen} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../utils/utils&#x27;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EventListener</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">el,binding,vnode</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">el</span> = el;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">binding</span> = binding;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vnode</span> = vnode;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span> = <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span> = vnode.<span class=\"hljs-property\">context</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$lazyload</span> = vnode.<span class=\"hljs-property\">context</span>.<span class=\"hljs-property\">$lazyload</span>\n  }\n\n  <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\"></span>){\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vnode</span>.<span class=\"hljs-property\">context</span>.<span class=\"hljs-property\">imagebox</span>;\n		<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">el</span>,<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">binding</span>.<span class=\"hljs-property\">value</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">listenProcess</span>();\n  }\n\n  <span class=\"hljs-title function_\">startListen</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-keyword\">var</span> listenProcess = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">listenProcess</span>;\n  	<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;scroll&#x27;</span>,listenProcess.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>),<span class=\"hljs-literal\">false</span>);\n  }\n\n  <span class=\"hljs-title function_\">removeListen</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-keyword\">var</span> listenProcess = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">listenProcess</span>;\n    <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&#x27;scroll&#x27;</span>,listenProcess.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>),<span class=\"hljs-literal\">false</span>);\n  }\n\n  <span class=\"hljs-title function_\">listenProcess</span>(<span class=\"hljs-params\"></span>){\n  	<span class=\"hljs-keyword\">const</span> _self = <span class=\"hljs-variable language_\">this</span>;\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-property\">item</span>.<span class=\"hljs-property\">length</span> == <span class=\"hljs-number\">0</span>){\n      <span class=\"hljs-keyword\">return</span>;\n    }\n\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-property\">item</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>)=&gt;</span>{\n			<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-title function_\">isSeen</span>(item)){\n\n				<span class=\"hljs-keyword\">var</span> image = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Image</span>();\n	      image.<span class=\"hljs-property\">src</span> = item.<span class=\"hljs-property\">src</span>;\n	      _self.<span class=\"hljs-title function_\">_imageStyle</span>(item);\n	      \n	      _self.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">addPending</span>(item.<span class=\"hljs-property\">ele</span>,item.<span class=\"hljs-property\">src</span>);\n\n	      image.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n	        <span class=\"hljs-keyword\">if</span>(image.<span class=\"hljs-property\">complete</span>){\n	        	_self.<span class=\"hljs-title function_\">imageOnload</span>(item);\n	        }\n	      }\n\n	      image.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n	        _self.<span class=\"hljs-title function_\">imageOnerror</span>(item);\n	      }\n			}\n		})\n  }\n\n  <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\">ele,src</span>){\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">update</span>(ele,src);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">listenProcess</span>();\n  }\n\n  <span class=\"hljs-title function_\">imageOnload</span>(<span class=\"hljs-params\">item</span>){\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_removeImageStyle</span>(item.<span class=\"hljs-property\">ele</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">addAlready</span>(item.<span class=\"hljs-property\">ele</span>,item.<span class=\"hljs-property\">src</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_imageSet</span>(item.<span class=\"hljs-property\">ele</span>,item.<span class=\"hljs-property\">src</span>)\n  }\n\n  <span class=\"hljs-title function_\">imageOnerror</span>(<span class=\"hljs-params\">item</span>){\n  	<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_removeImageStyle</span>(item.<span class=\"hljs-property\">ele</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">imagebox</span>.<span class=\"hljs-title function_\">addFailed</span>(item.<span class=\"hljs-property\">ele</span>,item.<span class=\"hljs-property\">src</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">_imageSet</span>(item.<span class=\"hljs-property\">ele</span>,<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$lazyload</span>.<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">errorUrl</span>)\n  }\n\n  <span class=\"hljs-title function_\">_imageStyle</span>(<span class=\"hljs-params\">item</span>){\n    <span class=\"hljs-comment\">// this._imageSet(item.ele,this.$lazyload.options.loadUrl);</span>\n    item.<span class=\"hljs-property\">ele</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">background</span> = <span class=\"hljs-string\">`url(<span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.$lazyload.options.loadUrl}</span>) no-repeat center`</span>;\n  }\n\n  <span class=\"hljs-title function_\">_removeImageStyle</span>(<span class=\"hljs-params\">ele</span>){\n  	ele.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">background</span> = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  }\n\n  <span class=\"hljs-title function_\">_imageSet</span>(<span class=\"hljs-params\">ele,value</span>){\n    ele.<span class=\"hljs-property\">src</span> = value;\n  }\n}\n\n</code></div></pre>\n<p>utils.js</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">const</span> isSeen = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item,imagebox</span>){\n  <span class=\"hljs-keyword\">var</span> ele = item.<span class=\"hljs-property\">ele</span>;\n  <span class=\"hljs-keyword\">var</span> src = item.<span class=\"hljs-property\">src</span>;\n  <span class=\"hljs-comment\">//图片距离页面顶部的距离</span>\n  <span class=\"hljs-keyword\">var</span> top = ele.<span class=\"hljs-title function_\">getBoundingClientRect</span>().<span class=\"hljs-property\">top</span>;\n  <span class=\"hljs-comment\">//页面可视区域的高度</span>\n  <span class=\"hljs-keyword\">var</span> windowHeight = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">documentElement</span>.<span class=\"hljs-property\">clientHeight</span> || <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">clientHeight</span>;\n  <span class=\"hljs-comment\">//top + 10 已经进入了可视区域10像素</span>\n  <span class=\"hljs-keyword\">if</span>(top + <span class=\"hljs-number\">10</span> &lt; windowHeight){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  }<span class=\"hljs-keyword\">else</span>{\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> {\n  isSeen\n};\n</code></div></pre>\n<h3><a id=\"js_691\"></a>五、打包成.js可以外部直接引用</h3>\n<p>打包后的代码：<strong><a href=\"http://www.tangyida.top/static/study/lazyload.js\" target=\"_blank\">lazyload.js</a></strong></p>\n<h4><a id=\"_695\"></a>使用方法</h4>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title class_\">LazyLoad</span>,{\n    <span class=\"hljs-attr\">loadUrl</span>:<span class=\"hljs-string\">&#x27;./loading-spin.svg&#x27;</span>,<span class=\"hljs-comment\">//这里写你的加载时候的图片配置</span>\n    <span class=\"hljs-attr\">errorUrl</span>:<span class=\"hljs-string\">&#x27;./404.svg&#x27;</span><span class=\"hljs-comment\">//错误加载的图片配置</span>\n});\n</code></div></pre>\n<h4><a id=\"_704\"></a>元素中使用指令</h4>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;img v-lazy=<span class=\"hljs-string\">&quot;item&quot;</span> v-<span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;(item,$key) in imageArr&quot;</span>&gt;\n</code></div></pre>\n<h4><a id=\"imageArr_710\"></a>imageArr测试数据</h4>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-attr\">imageArr</span>:[\n	<span class=\"hljs-string\">&#x27;http://covteam.u.qiniudn.com/test16.jpg?imageView2/2/format/webp&#x27;</span>,\n	<span class=\"hljs-string\">&#x27;http://covteam.u.qiniudn.com/test14.jpg?imageView2/2/format/webp&#x27;</span>,\n	<span class=\"hljs-string\">&#x27;http://covteam.u.qiniudn.com/test15.jpg?imageView2/2/format/webp&#x27;</span>,\n	<span class=\"hljs-string\">&#x27;http://covteam.u.qiniudn.com/test17.jpg?imageView2/2/format/webp&#x27;</span>,\n	<span class=\"hljs-string\">&#x27;http://hilongjw.github.io/vue-lazyload/dist/test9.jpg&#x27;</span>,\n	<span class=\"hljs-string\">&#x27;http://hilongjw.github.io/vue-lazyload/dist/test10.jpg&#x27;</span>,\n	<span class=\"hljs-string\">&#x27;http://hilongjw.github.io/vue-lazyload/dist/test14.jpg&#x27;</span>\n]\n</code></div></pre>\n<p>测试地址：<a href=\"http://www.tangyida.top/static/study/lazyload/test.html\" target=\"_blank\">戳我戳我</a></p>\n<h3><a id=\"_726\"></a>五、后记</h3>\n<p>其实这些代码的编写还是比较简单的，写完过后进行总结，你会发现，其中最难的是：</p>\n<p><strong>整个项目的结构，和代码模块之间的逻辑关系</strong>。</p>\n<p>这个才是最难掌握的，如果涉及到大一点的项目，好一点的项目结构能让整个项目进度等等因素发生巨大的变化，提升巨大的效率。而写插件最难的就是在这。</p>\n<p><strong>如何有效地拆分代码？如何有效地进行项目结构的构造?</strong> 这才是整个插件编写的核心。</p>\n<p>之前写过一个vue关于表单验证的插件，也是被项目结构搞得焦头烂额。还有写过一个cordova的插件，遵循它的插件规范。</p>\n<p>所以我深知写插件的时候，它结构和模块化的重要性。而结构和模块化的优秀，会让你事半功倍。当你经验积累到一定程度的时候，你会发现，你也可以写框架了。</p>\n');
INSERT INTO `article_content` VALUES ('edb409243c0e1b8a819fe729b6566ab2', '### 1 Pipe\n\nJava NIO 管道是 2 个线程之间的单向数据连接。Pipe 有一个 source 通道和一个 sink 通道。数据会被写到 sink 通道，从 source 通道读取。\n\n::: hljs-center\n\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/2f9b2e23b0414df2a415fbd52fca6338.png)\n\n:::\n\n#### 1.1 创建管道\n通过 Pipe.open()方法打开管道。\n```java\nPipe pipe = Pipe.open();\n```\n\n#### 1.2 写入管道\n要向管道写数据，需要访问 sink 通道。：\n```java\nPipe.SinkChannel sinkChannel = pipe.sink();\n```\n\n通过调用 SinkChannel 的 write()方法，将数据写入 SinkChannel：\n```java\nString newData = \"New String to write to file...\" + System.currentTimeMillis(); \nByteBuffer buf = ByteBuffer.allocate(48); \nbuf.clear(); buf.put(newData.getBytes()); \nbuf.flip(); \nwhile(buf.hasRemaining()) { \nsinkChannel.write(buf); \n}\n```\n\n#### 1.3 从管道读取数据\n从读取管道的数据，需要访问 source 通道，像这样：\n```java\nPipe.SourceChannel sourceChannel = pipe.source();\n```\n\n调用 source 通道的 read()方法来读取数据：\n```java\nByteBuffer buf = ByteBuffer.allocate(48); \nint bytesRead = sourceChannel.read(buf);\n```\nread()方法返回的 int 值会告诉我们多少字节被读进了缓冲区。\n\n#### 1.4 示例\n```java\npublic static void main(String[] args) throws Exception {\n        //获取管道\n        Pipe pipe = Pipe.open();\n        //获取sink通道\n        Pipe.SinkChannel sinkChannel = pipe.sink();\n        //创建缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        byteBuffer.put(\"Jzjzzzz\".getBytes(StandardCharsets.UTF_8));\n        byteBuffer.flip();\n        //写入数据\n        sinkChannel.write(byteBuffer);\n        //获取source通道\n        Pipe.SourceChannel sourceChannel = pipe.source();\n        //创建缓冲区,读取数据\n        //ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n        byteBuffer.flip();\n        int length = sourceChannel.read(byteBuffer);\n        System.out.println(new String(byteBuffer.array(),0,length));\n        //关闭通道\n        sourceChannel.close();\n        sinkChannel.close();\n    }\n```\n\n### 2 FileLock\n\n#### 2.1 FileLock 简介\n文件锁在 OS 中很常见，如果多个程序同时访问、修改同一个文件，很容易因为文件 数据不同步而出现问题。给文件加一个锁，同一时间，只能有一个程序修改此文件， 或者程序都只能读此文件，这就解决了同步问题。\n\n文件锁是进程级别的，不是线程级别的。文件锁可以解决多个进程并发访问、修改同 一个文件的问题，但不能解决多线程并发访问、修改同一文件的问题。使用文件锁时， 同一进程内的多个线程，可以同时访问、修改此文件。\n\n文件锁是当前程序所属的 JVM 实例持有的，一旦获取到文件锁（对文件加锁），要调用 release()，或者关闭对应的 FileChannel 对象，或者当前 JVM 退出，才会释放这个锁。\n\n一旦某个进程（比如说 JVM 实例）对某个文件加锁，则在释放这个锁之前，此进程不 能再对此文件加锁，就是说 JVM 实例在同一文件上的文件锁是不重叠的（进程级别不 能重复在同一文件上获取锁）。\n\n#### 2.2 文件锁分类\n==排它锁==：又叫独占锁。对文件加排它锁后，该进程可以对此文件进行读写，该进程独 占此文件，其他进程不能读写此文件，直到该进程释放文件锁。\n\n==共享锁==：某个进程对文件加共享锁，其他进程也可以访问此文件，但这些进程都只能 读此文件，不能写。线程是安全的。只要还有一个进程持有共享锁，此文件就只能读， 不能写。\n\n#### 2.3 使用示例\n```java\n//创建 FileChannel 对象，文件锁只能通过 FileChannel 对象来使用 \nFileChannel fileChannel=new FileOutputStream(\"./1.txt\").getChannel(); \n//对文件加锁 \nFileLock lock=fileChannel.lock(); \n//对此文件进行一些读写操作。 \n//....... \n//释放锁 \nlock.release();\n```\n文件锁要通过 FileChannel 对象使用。\n\n#### 2.4 获取文件锁方法\n有 4 种获取文件锁的方法：\n- lock() //对整个文件加锁，默认为排它锁。\n- lock(long position, long size, booean shared) //自定义加锁方式。前 2 个参数 指定要加锁的部分（可以只对此文件的部分内容加锁），第三个参数值指定是否是共享锁。\n- tryLock() //对整个文件加锁，默认为排它锁。\n- tryLock(long position, long size, booean shared) //自定义加锁方式。\n\n如果指定为共享锁，则其它进程可读此文件，所有进程均不能写此文件，如果某进程 试图对此文件进行写操作，会抛出异常。\n\n#### 2.5 lock 与 tryLock 的区别\n\nlock 是阻塞式的，如果未获取到文件锁，会一直阻塞当前线程，直到获取文件锁。\n\ntryLock 和 lock 的作用相同，只不过 tryLock 是非阻塞式的，tryLock 是尝试获取文 件锁，获取成功就返回锁对象，否则返回 null，不会阻塞当前线程。\n\n#### 2.6 FileLock 两个方法\n```java\nboolean isShared() //此文件锁是否是共享锁 \nboolean isValid() //此文件锁是否还有效\n```\n在某些 OS 上，对某个文件加锁后，不能对此文件使用通道映射。\n\n#### 2.7 完整例子\n```java\npublic class FileLockDemo01 {\n    public static void main(String[] args) throws Exception {\n        String input = \"Jzj\";\n        System.out.println(\"input:\"+input);\n        ByteBuffer buffer = ByteBuffer.wrap(input.getBytes(StandardCharsets.UTF_8));\n\n        String filePath = \"d:\\\\111.txt\";\n        Path path = Paths.get(filePath);\n        FileChannel channel = FileChannel.open(\n                path,\n                StandardOpenOption.WRITE,\n                StandardOpenOption.APPEND);\n        channel.position(channel.size()-1);\n\n        //加锁\n        FileLock lock = channel.lock(0L,Long.MAX_VALUE,true);\n        System.out.println(\"是否共享锁:\"+lock.isShared());\n\n        channel.write(buffer);\n        channel.close();\n        //读文件\n        readFile(filePath);\n    }\n\n    private static void readFile(String filePath) throws Exception {\n        FileReader fileReader = new FileReader(filePath);\n        BufferedReader bufferedReader = new BufferedReader(fileReader);\n        String tr = bufferedReader.readLine();\n        System.out.println(\"读取出内容:\");\n        while (tr != null){\n            System.out.println(\" \" +tr);\n            tr = bufferedReader.readLine();\n        }\n        fileReader.close();\n        bufferedReader.close();\n    }\n}\n```\n', '2022-10-09 16:52:29', '2022-10-09 17:23:51', '<h3><a id=\"1_Pipe_0\"></a>1 Pipe</h3>\n<p>Java NIO 管道是 2 个线程之间的单向数据连接。Pipe 有一个 source 通道和一个 sink 通道。数据会被写到 sink 通道，从 source 通道读取。</p>\n<div class=\"hljs-center\">\n<p><img src=\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/2f9b2e23b0414df2a415fbd52fca6338.png\" alt=\"image.png\" /></p>\n</div>\n<h4><a id=\"11__10\"></a>1.1 创建管道</h4>\n<p>通过 Pipe.open()方法打开管道。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">Pipe</span> <span class=\"hljs-variable\">pipe</span> <span class=\"hljs-operator\">=</span> Pipe.open();\n</code></div></pre>\n<h4><a id=\"12__16\"></a>1.2 写入管道</h4>\n<p>要向管道写数据，需要访问 sink 通道。：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">Pipe.<span class=\"hljs-type\">SinkChannel</span> <span class=\"hljs-variable\">sinkChannel</span> <span class=\"hljs-operator\">=</span> pipe.sink();\n</code></div></pre>\n<p>通过调用 SinkChannel 的 write()方法，将数据写入 SinkChannel：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">newData</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;New String to write to file...&quot;</span> + System.currentTimeMillis(); \n<span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buf</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">48</span>); \nbuf.clear(); buf.put(newData.getBytes()); \nbuf.flip(); \n<span class=\"hljs-keyword\">while</span>(buf.hasRemaining()) { \nsinkChannel.write(buf); \n}\n</code></div></pre>\n<h4><a id=\"13__33\"></a>1.3 从管道读取数据</h4>\n<p>从读取管道的数据，需要访问 source 通道，像这样：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">Pipe.<span class=\"hljs-type\">SourceChannel</span> <span class=\"hljs-variable\">sourceChannel</span> <span class=\"hljs-operator\">=</span> pipe.source();\n</code></div></pre>\n<p>调用 source 通道的 read()方法来读取数据：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buf</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">48</span>); \n<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">bytesRead</span> <span class=\"hljs-operator\">=</span> sourceChannel.read(buf);\n</code></div></pre>\n<p>read()方法返回的 int 值会告诉我们多少字节被读进了缓冲区。</p>\n<h4><a id=\"14__46\"></a>1.4 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">//获取管道</span>\n        <span class=\"hljs-type\">Pipe</span> <span class=\"hljs-variable\">pipe</span> <span class=\"hljs-operator\">=</span> Pipe.open();\n        <span class=\"hljs-comment\">//获取sink通道</span>\n        Pipe.<span class=\"hljs-type\">SinkChannel</span> <span class=\"hljs-variable\">sinkChannel</span> <span class=\"hljs-operator\">=</span> pipe.sink();\n        <span class=\"hljs-comment\">//创建缓冲区</span>\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">byteBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);\n        byteBuffer.put(<span class=\"hljs-string\">&quot;Jzjzzzz&quot;</span>.getBytes(StandardCharsets.UTF_8));\n        byteBuffer.flip();\n        <span class=\"hljs-comment\">//写入数据</span>\n        sinkChannel.write(byteBuffer);\n        <span class=\"hljs-comment\">//获取source通道</span>\n        Pipe.<span class=\"hljs-type\">SourceChannel</span> <span class=\"hljs-variable\">sourceChannel</span> <span class=\"hljs-operator\">=</span> pipe.source();\n        <span class=\"hljs-comment\">//创建缓冲区,读取数据</span>\n        <span class=\"hljs-comment\">//ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);</span>\n        byteBuffer.flip();\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">length</span> <span class=\"hljs-operator\">=</span> sourceChannel.read(byteBuffer);\n        System.out.println(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(byteBuffer.array(),<span class=\"hljs-number\">0</span>,length));\n        <span class=\"hljs-comment\">//关闭通道</span>\n        sourceChannel.close();\n        sinkChannel.close();\n    }\n</code></div></pre>\n<h3><a id=\"2_FileLock_72\"></a>2 FileLock</h3>\n<h4><a id=\"21_FileLock__74\"></a>2.1 FileLock 简介</h4>\n<p>文件锁在 OS 中很常见，如果多个程序同时访问、修改同一个文件，很容易因为文件 数据不同步而出现问题。给文件加一个锁，同一时间，只能有一个程序修改此文件， 或者程序都只能读此文件，这就解决了同步问题。</p>\n<p>文件锁是进程级别的，不是线程级别的。文件锁可以解决多个进程并发访问、修改同 一个文件的问题，但不能解决多线程并发访问、修改同一文件的问题。使用文件锁时， 同一进程内的多个线程，可以同时访问、修改此文件。</p>\n<p>文件锁是当前程序所属的 JVM 实例持有的，一旦获取到文件锁（对文件加锁），要调用 release()，或者关闭对应的 FileChannel 对象，或者当前 JVM 退出，才会释放这个锁。</p>\n<p>一旦某个进程（比如说 JVM 实例）对某个文件加锁，则在释放这个锁之前，此进程不 能再对此文件加锁，就是说 JVM 实例在同一文件上的文件锁是不重叠的（进程级别不 能重复在同一文件上获取锁）。</p>\n<h4><a id=\"22__83\"></a>2.2 文件锁分类</h4>\n<p><mark>排它锁</mark>：又叫独占锁。对文件加排它锁后，该进程可以对此文件进行读写，该进程独 占此文件，其他进程不能读写此文件，直到该进程释放文件锁。</p>\n<p><mark>共享锁</mark>：某个进程对文件加共享锁，其他进程也可以访问此文件，但这些进程都只能 读此文件，不能写。线程是安全的。只要还有一个进程持有共享锁，此文件就只能读， 不能写。</p>\n<h4><a id=\"23__88\"></a>2.3 使用示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//创建 FileChannel 对象，文件锁只能通过 FileChannel 对象来使用 </span>\nFileChannel fileChannel=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileOutputStream</span>(<span class=\"hljs-string\">&quot;./1.txt&quot;</span>).getChannel(); \n<span class=\"hljs-comment\">//对文件加锁 </span>\nFileLock lock=fileChannel.lock(); \n<span class=\"hljs-comment\">//对此文件进行一些读写操作。 </span>\n<span class=\"hljs-comment\">//....... </span>\n<span class=\"hljs-comment\">//释放锁 </span>\nlock.release();\n</code></div></pre>\n<p>文件锁要通过 FileChannel 对象使用。</p>\n<h4><a id=\"24__101\"></a>2.4 获取文件锁方法</h4>\n<p>有 4 种获取文件锁的方法：</p>\n<ul>\n<li>lock() //对整个文件加锁，默认为排它锁。</li>\n<li>lock(long position, long size, booean shared) //自定义加锁方式。前 2 个参数 指定要加锁的部分（可以只对此文件的部分内容加锁），第三个参数值指定是否是共享锁。</li>\n<li>tryLock() //对整个文件加锁，默认为排它锁。</li>\n<li>tryLock(long position, long size, booean shared) //自定义加锁方式。</li>\n</ul>\n<p>如果指定为共享锁，则其它进程可读此文件，所有进程均不能写此文件，如果某进程 试图对此文件进行写操作，会抛出异常。</p>\n<h4><a id=\"25_lock__tryLock__110\"></a>2.5 lock 与 tryLock 的区别</h4>\n<p>lock 是阻塞式的，如果未获取到文件锁，会一直阻塞当前线程，直到获取文件锁。</p>\n<p>tryLock 和 lock 的作用相同，只不过 tryLock 是非阻塞式的，tryLock 是尝试获取文 件锁，获取成功就返回锁对象，否则返回 null，不会阻塞当前线程。</p>\n<h4><a id=\"26_FileLock__116\"></a>2.6 FileLock 两个方法</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isShared</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">//此文件锁是否是共享锁 </span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isValid</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">//此文件锁是否还有效</span>\n</code></div></pre>\n<p>在某些 OS 上，对某个文件加锁后，不能对此文件使用通道映射。</p>\n<h4><a id=\"27__123\"></a>2.7 完整例子</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FileLockDemo01</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">input</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Jzj&quot;</span>;\n        System.out.println(<span class=\"hljs-string\">&quot;input:&quot;</span>+input);\n        <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(input.getBytes(StandardCharsets.UTF_8));\n\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;d:\\\\111.txt&quot;</span>;\n        <span class=\"hljs-type\">Path</span> <span class=\"hljs-variable\">path</span> <span class=\"hljs-operator\">=</span> Paths.get(filePath);\n        <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> FileChannel.open(\n                path,\n                StandardOpenOption.WRITE,\n                StandardOpenOption.APPEND);\n        channel.position(channel.size()-<span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-comment\">//加锁</span>\n        <span class=\"hljs-type\">FileLock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> channel.lock(<span class=\"hljs-number\">0L</span>,Long.MAX_VALUE,<span class=\"hljs-literal\">true</span>);\n        System.out.println(<span class=\"hljs-string\">&quot;是否共享锁:&quot;</span>+lock.isShared());\n\n        channel.write(buffer);\n        channel.close();\n        <span class=\"hljs-comment\">//读文件</span>\n        readFile(filePath);\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">readFile</span><span class=\"hljs-params\">(String filePath)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-type\">FileReader</span> <span class=\"hljs-variable\">fileReader</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileReader</span>(filePath);\n        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">bufferedReader</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(fileReader);\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">tr</span> <span class=\"hljs-operator\">=</span> bufferedReader.readLine();\n        System.out.println(<span class=\"hljs-string\">&quot;读取出内容:&quot;</span>);\n        <span class=\"hljs-keyword\">while</span> (tr != <span class=\"hljs-literal\">null</span>){\n            System.out.println(<span class=\"hljs-string\">&quot; &quot;</span> +tr);\n            tr = bufferedReader.readLine();\n        }\n        fileReader.close();\n        bufferedReader.close();\n    }\n}\n</code></div></pre>\n');

-- ----------------------------
-- Table structure for article_inform
-- ----------------------------
DROP TABLE IF EXISTS `article_inform`;
CREATE TABLE `article_inform`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章id',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `create_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '创建者',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '状态（0-下架，1-发布）',
  `article_title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章标题',
  `introduce` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '简介',
  `log_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题图',
  `article_type` char(5) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章分类',
  `article_tag` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章标签',
  `top_status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否置顶（0-不置顶，1-置顶）',
  `origin_status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否原创（0-原创，1-转载）',
  `comment_status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否开启评论（0-不开启，1-开启）',
  `click_rate` bigint(20) NULL DEFAULT NULL COMMENT '文章点击量',
  `number_like` bigint(20) NULL DEFAULT NULL COMMENT '点赞数',
  `aggregate_id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '归档id',
  `sort` int(11) NULL DEFAULT NULL COMMENT '排序',
  `comment_number` int(11) NULL DEFAULT NULL COMMENT '评论数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章基础信息' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_inform
-- ----------------------------
INSERT INTO `article_inform` VALUES ('0ae360525f681ccd6c35c0cda7bc87c2', '2022-09-26 10:01:37', '2022-09-27 14:49:43', '漫漫长路', '1', '阿里云OSS（一）', '阿里云OSS', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/e5a630491c4c4eabb9b0f6cd408afcbb.jpg', '0', '0,7', '0', '0', '0', 22, 1, '09d7c62e8f9d0348782c6381e2c0b6c0', 0, 1);
INSERT INTO `article_inform` VALUES ('320ab09bf4402f0abb812e8530e217ea', '2022-09-26 14:58:03', '2022-09-30 15:03:52', '漫漫前路', '1', '腾讯云短信服务', '腾讯云短信服务', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/3e2924038d9f4b3cbace962ab5d8f938.jpg', '0', '0,9', '0', '0', '0', 12, 0, '', 0, 0);
INSERT INTO `article_inform` VALUES ('4fd382ced2e902c7ff6373c440b95174', '2022-09-26 14:47:31', '2022-10-09 14:39:11', '漫漫前路', '1', '阿里云OSS（三）', '阿里云OSS', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/ef56bf3ce3fc4f77a2435d7d33a408c5.jpg', '0', '0,7', '0', '0', '0', 47, 0, '09d7c62e8f9d0348782c6381e2c0b6c0', 0, 0);
INSERT INTO `article_inform` VALUES ('5dc9ccb15fe3224878945a842f7f6427', '2022-09-30 16:30:45', '2022-10-09 15:05:36', '漫漫前路', '1', 'Java网络编程-NIO（SocketChannel）', 'Java网络编程-NIO（SocketChannel）', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg', '0', '0,10', '0', '1', '0', 12, 1, '6af32c16a767b5a74dc711d8d688236f', 0, 0);
INSERT INTO `article_inform` VALUES ('68c89984823c939509f7601517b358ad', '2022-10-09 10:56:26', '2022-10-09 16:22:46', '漫漫前路', '1', 'Java网络编程-NIO（Selector）', 'Java网络编程-NIO（Selector）', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/dd6766ece27b4fcf90dcd0a5167297d0.jpg', '0', '0,10', '0', '1', '0', 2, 0, '6af32c16a767b5a74dc711d8d688236f', 0, 0);
INSERT INTO `article_inform` VALUES ('6ad6bbb7161e5ad89760b8ca830870ef', '2022-09-30 14:45:15', '2022-10-09 10:48:42', '漫漫前路', '1', 'Java网络编程-NIO（概述）', 'Java 网络编程系列之 NIO', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/dfae8c0b0a2b4577aa268401bf0c60e4.jpg', '0', '0,10', '0', '1', '0', 22, 0, '6af32c16a767b5a74dc711d8d688236f', 0, 0);
INSERT INTO `article_inform` VALUES ('6bb0a02f479905e24398dfe187c49641', '2022-10-09 17:29:00', '2022-10-09 17:29:11', '漫漫前路', '1', 'Java网络编程-NIO（其他）', 'Java网络编程-NIO（其他）', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/1671f73bdd3140f3a2cc646e948d98f0.jpg', '0', '0,10', '0', '1', '0', 2, 0, '6af32c16a767b5a74dc711d8d688236f', 0, 0);
INSERT INTO `article_inform` VALUES ('7d9a6f525ea2d6778e3b2a58a2d985a7', '2022-09-26 09:21:55', '2022-10-09 16:21:35', '漫漫长路', '1', '阿里云OSS（二）', '阿里云OSS', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/5bce8eaf8da046d0a6a3fa9cb3bd7d73.jpg', '0', '0,7', '0', '0', '0', 13, 0, '09d7c62e8f9d0348782c6381e2c0b6c0', 0, 0);
INSERT INTO `article_inform` VALUES ('8556d1aadfebf82abaa7e2159d499d8b', '2022-10-08 16:37:01', '2022-10-09 10:49:00', '漫漫前路', '1', 'Java网络编程-NIO（Buffer）', 'Java网络编程-NIO（Buffer）', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/08/ad90335701f84465b105d9548cc6f992.jpg', '0', '0,10', '0', '1', '0', 4, 0, '6af32c16a767b5a74dc711d8d688236f', 0, 0);
INSERT INTO `article_inform` VALUES ('ace86a2c5d5c94e559bbfe3158d342fc', '2022-09-30 15:13:36', '2022-10-08 16:34:14', '漫漫前路', '1', 'Java网络编程-NIO（Channel）', 'Java网络编程-NIO（Channel）', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/9022fbc5907d4e4ebe016e4d8976ce9d.jpg', '0', '0,10', '0', '1', '0', 14, 0, '6af32c16a767b5a74dc711d8d688236f', 0, 0);
INSERT INTO `article_inform` VALUES ('c2317a9079991be3273a65254f263441', '2022-09-26 15:03:36', '2022-09-30 14:50:57', '漫漫前路', '1', '阿里巴巴EasyExcel的使用', '阿里巴巴EasyExcel的使用', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/434f3e2fc8a94f3c9001bd743f9fcf88.jpg', '0', '0', '0', '0', '0', 39, 0, '', 0, 0);
INSERT INTO `article_inform` VALUES ('edb409243c0e1b8a819fe729b6566ab2', '2022-10-09 16:52:29', '2022-10-09 17:23:51', '漫漫前路', '1', 'Java网络编程-NIO（Pipe 和 FileLock）', 'Java网络编程-NIO（Pipe 和 FileLock）', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/e0f6fb09458242b08216b9cbeec18f1b.jpg', '0', '0,10', '0', '1', '0', 0, 0, '6af32c16a767b5a74dc711d8d688236f', 0, 0);

-- ----------------------------
-- Table structure for article_summary
-- ----------------------------
DROP TABLE IF EXISTS `article_summary`;
CREATE TABLE `article_summary`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '归档表id',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '归档名称',
  `banner` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '归档图',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '状态',
  `top_status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否显示在首页',
  `author` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '作者',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章归档' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_summary
-- ----------------------------
INSERT INTO `article_summary` VALUES ('09d7c62e8f9d0348782c6381e2c0b6c0', '阿里云OSS', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/26/03b075772ba346ecbe91110f6fd9b4f4.jpg', '2022-09-26 10:02:59', '2022-09-26 10:02:59', '1', NULL, '漫漫长路');
INSERT INTO `article_summary` VALUES ('6af32c16a767b5a74dc711d8d688236f', '尚硅谷NIO笔记', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/2662e8eef71d439e81c62ba7cb850bd0.jpg', '2022-09-30 15:07:37', '2022-09-30 15:07:37', '1', NULL, '漫漫前路');
INSERT INTO `article_summary` VALUES ('ac578e0aba0f32dffd9d1a10a159b04c', '尚硅谷Netty笔记', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/e380b7f1034443fea069c6e3db3e2aab.jpg', '2022-09-30 15:08:49', '2022-09-30 15:08:49', '1', NULL, '漫漫前路');
INSERT INTO `article_summary` VALUES ('f796f398a0dd7e44a3e407837250f3c1', '尚硅谷MySQL笔记', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/4b416e9fee76496498e692c76eb59542.jpg', '2022-09-30 15:08:21', '2022-09-30 15:08:21', '1', NULL, '漫漫前路');

-- ----------------------------
-- Table structure for friend_link
-- ----------------------------
DROP TABLE IF EXISTS `friend_link`;
CREATE TABLE `friend_link`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT 'id',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '链接名称',
  `link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '链接',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `status` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '友情链接' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of friend_link
-- ----------------------------
INSERT INTO `friend_link` VALUES ('d855c662eddc70853cee7304bb1c1b05', 'Jzjzzzz', 'https://www.jzjzzzz.icu/', '2022-09-10 00:50:33', '2022-09-10 00:50:33', '1');

-- ----------------------------
-- Table structure for gallery
-- ----------------------------
DROP TABLE IF EXISTS `gallery`;
CREATE TABLE `gallery`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT 'id',
  `img_address` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '图片地址',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '修改时间',
  `status` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '图集' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of gallery
-- ----------------------------
INSERT INTO `gallery` VALUES ('03a99c7b12edf4afdc22555223dd6578', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/24/7e9fc5305e3e40ac95f56d1424d7d9ef.jpg', '2022-09-24 20:24:07', '2022-09-24 20:24:07', '1');
INSERT INTO `gallery` VALUES ('1d6ac129b136aa5f3cfb8499da523010', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/96e53ccf50044613b931282b1a8c6765.jpg', '2022-09-30 14:45:40', '2022-09-30 14:45:40', '1');
INSERT INTO `gallery` VALUES ('56c84ccbfc3c047eb1519db2347c4c4b', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/24/7aa46f57b11341ffac4512901d331ca2.jpg', '2022-09-24 20:53:35', '2022-09-24 20:53:35', '1');
INSERT INTO `gallery` VALUES ('74a56a311f6909b8584ed82be5cbf421', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/24/c2662067ad0946908572136e5ccd83a0.jpg', '2022-09-24 20:26:44', '2022-09-24 20:26:44', '1');
INSERT INTO `gallery` VALUES ('768b183cdbb975413bfbe9cc5d7d4ba4', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/45b13c6c457a41bcacf5b2ec962ec190.jpg', '2022-09-30 14:45:33', '2022-09-30 14:45:33', '1');
INSERT INTO `gallery` VALUES ('a79d7c800d159273df96311ece81dd59', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/456dc869a1cf4898b12f3cf5db848d01.jpg', '2022-09-30 14:45:48', '2022-09-30 14:45:48', '1');
INSERT INTO `gallery` VALUES ('b079b8bd7ea66bf73023aa653f4d7f89', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/24/e770e59ba7c5499cbbfd00e1b500437a.jpg', '2022-09-24 21:00:37', '2022-09-24 21:00:37', '1');
INSERT INTO `gallery` VALUES ('b9d7fcea75c0cc18c5e7c04ef5968dd1', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/6d8895578d8d43d9ad6771b1f5630a70.jpg', '2022-09-30 14:45:28', '2022-09-30 14:45:28', '1');
INSERT INTO `gallery` VALUES ('d798f3e5f208c754a7511f1f2d4a1fd0', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/24/9dd1d99171cc47c59ae05e989520afba.jpg', '2022-09-24 20:26:48', '2022-09-24 20:26:48', '1');
INSERT INTO `gallery` VALUES ('ecec1412dcc54c4d92110e1bccccea60', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/24/cfb8c7582ccd48f28e6bfb0c92dc5507.jpg', '2022-09-24 20:25:28', '2022-09-24 20:25:28', '1');

-- ----------------------------
-- Table structure for qrtz_blob_triggers
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_blob_triggers`;
CREATE TABLE `qrtz_blob_triggers`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `BLOB_DATA` blob NULL,
  PRIMARY KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) USING BTREE,
  CONSTRAINT `QRTZ_BLOB_TRIGGERS_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_blob_triggers
-- ----------------------------

-- ----------------------------
-- Table structure for qrtz_calendars
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_calendars`;
CREATE TABLE `qrtz_calendars`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `CALENDAR_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `CALENDAR` blob NOT NULL,
  PRIMARY KEY (`SCHED_NAME`, `CALENDAR_NAME`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_calendars
-- ----------------------------

-- ----------------------------
-- Table structure for qrtz_cron_triggers
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_cron_triggers`;
CREATE TABLE `qrtz_cron_triggers`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `CRON_EXPRESSION` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TIME_ZONE_ID` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) USING BTREE,
  CONSTRAINT `QRTZ_CRON_TRIGGERS_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_cron_triggers
-- ----------------------------
INSERT INTO `qrtz_cron_triggers` VALUES ('VblogScheduler', 'com.jzj.vblog.job.ArticleCountJob', 'Article', '0 0/2 * * * ?', 'Asia/Shanghai');
INSERT INTO `qrtz_cron_triggers` VALUES ('VblogScheduler', 'com.jzj.vblog.job.HelloJob', 'Hello', '0/2 * * * * ?', 'Asia/Shanghai');

-- ----------------------------
-- Table structure for qrtz_fired_triggers
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_fired_triggers`;
CREATE TABLE `qrtz_fired_triggers`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `ENTRY_ID` varchar(95) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `INSTANCE_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `FIRED_TIME` bigint(13) NOT NULL,
  `SCHED_TIME` bigint(13) NOT NULL,
  `PRIORITY` int(11) NOT NULL,
  `STATE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `JOB_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `JOB_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `IS_NONCONCURRENT` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `REQUESTS_RECOVERY` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`SCHED_NAME`, `ENTRY_ID`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_fired_triggers
-- ----------------------------

-- ----------------------------
-- Table structure for qrtz_job_details
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_job_details`;
CREATE TABLE `qrtz_job_details`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `JOB_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `JOB_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `DESCRIPTION` varchar(250) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `JOB_CLASS_NAME` varchar(250) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `IS_DURABLE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `IS_NONCONCURRENT` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `IS_UPDATE_DATA` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `REQUESTS_RECOVERY` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `JOB_DATA` blob NULL,
  PRIMARY KEY (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_job_details
-- ----------------------------
INSERT INTO `qrtz_job_details` VALUES ('VblogScheduler', 'com.jzj.vblog.job.ArticleCountJob', 'Article', NULL, 'com.jzj.vblog.job.ArticleCountJob', '0', '0', '0', '0', 0xACED0005737200156F72672E71756172747A2E4A6F62446174614D61709FB083E8BFA9B0CB020000787200266F72672E71756172747A2E7574696C732E537472696E674B65794469727479466C61674D61708208E8C3FBC55D280200015A0013616C6C6F77735472616E7369656E74446174617872001D6F72672E71756172747A2E7574696C732E4469727479466C61674D617013E62EAD28760ACE0200025A000564697274794C00036D617074000F4C6A6176612F7574696C2F4D61703B787000737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F40000000000010770800000010000000007800);
INSERT INTO `qrtz_job_details` VALUES ('VblogScheduler', 'com.jzj.vblog.job.HelloJob', 'Hello', NULL, 'com.jzj.vblog.job.HelloJob', '0', '0', '0', '0', 0xACED0005737200156F72672E71756172747A2E4A6F62446174614D61709FB083E8BFA9B0CB020000787200266F72672E71756172747A2E7574696C732E537472696E674B65794469727479466C61674D61708208E8C3FBC55D280200015A0013616C6C6F77735472616E7369656E74446174617872001D6F72672E71756172747A2E7574696C732E4469727479466C61674D617013E62EAD28760ACE0200025A000564697274794C00036D617074000F4C6A6176612F7574696C2F4D61703B787000737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F40000000000010770800000010000000007800);

-- ----------------------------
-- Table structure for qrtz_locks
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_locks`;
CREATE TABLE `qrtz_locks`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `LOCK_NAME` varchar(40) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`SCHED_NAME`, `LOCK_NAME`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_locks
-- ----------------------------
INSERT INTO `qrtz_locks` VALUES ('VblogScheduler', 'TRIGGER_ACCESS');

-- ----------------------------
-- Table structure for qrtz_paused_trigger_grps
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_paused_trigger_grps`;
CREATE TABLE `qrtz_paused_trigger_grps`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`SCHED_NAME`, `TRIGGER_GROUP`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_paused_trigger_grps
-- ----------------------------

-- ----------------------------
-- Table structure for qrtz_scheduler_state
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_scheduler_state`;
CREATE TABLE `qrtz_scheduler_state`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `INSTANCE_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `LAST_CHECKIN_TIME` bigint(13) NOT NULL,
  `CHECKIN_INTERVAL` bigint(13) NOT NULL,
  PRIMARY KEY (`SCHED_NAME`, `INSTANCE_NAME`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_scheduler_state
-- ----------------------------

-- ----------------------------
-- Table structure for qrtz_simple_triggers
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_simple_triggers`;
CREATE TABLE `qrtz_simple_triggers`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `REPEAT_COUNT` bigint(7) NOT NULL,
  `REPEAT_INTERVAL` bigint(12) NOT NULL,
  `TIMES_TRIGGERED` bigint(10) NOT NULL,
  PRIMARY KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) USING BTREE,
  CONSTRAINT `QRTZ_SIMPLE_TRIGGERS_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_simple_triggers
-- ----------------------------

-- ----------------------------
-- Table structure for qrtz_simprop_triggers
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_simprop_triggers`;
CREATE TABLE `qrtz_simprop_triggers`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `STR_PROP_1` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `STR_PROP_2` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `STR_PROP_3` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `INT_PROP_1` int(11) NULL DEFAULT NULL,
  `INT_PROP_2` int(11) NULL DEFAULT NULL,
  `LONG_PROP_1` bigint(20) NULL DEFAULT NULL,
  `LONG_PROP_2` bigint(20) NULL DEFAULT NULL,
  `DEC_PROP_1` decimal(13, 4) NULL DEFAULT NULL,
  `DEC_PROP_2` decimal(13, 4) NULL DEFAULT NULL,
  `BOOL_PROP_1` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `BOOL_PROP_2` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) USING BTREE,
  CONSTRAINT `QRTZ_SIMPROP_TRIGGERS_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) REFERENCES `qrtz_triggers` (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_simprop_triggers
-- ----------------------------

-- ----------------------------
-- Table structure for qrtz_triggers
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_triggers`;
CREATE TABLE `qrtz_triggers`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `JOB_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `JOB_GROUP` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `DESCRIPTION` varchar(250) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `NEXT_FIRE_TIME` bigint(13) NULL DEFAULT NULL,
  `PREV_FIRE_TIME` bigint(13) NULL DEFAULT NULL,
  `PRIORITY` int(11) NULL DEFAULT NULL,
  `TRIGGER_STATE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TRIGGER_TYPE` varchar(8) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `START_TIME` bigint(13) NOT NULL,
  `END_TIME` bigint(13) NULL DEFAULT NULL,
  `CALENDAR_NAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `MISFIRE_INSTR` smallint(2) NULL DEFAULT NULL,
  `JOB_DATA` blob NULL,
  PRIMARY KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) USING BTREE,
  INDEX `SCHED_NAME`(`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) USING BTREE,
  CONSTRAINT `QRTZ_TRIGGERS_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) REFERENCES `qrtz_job_details` (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of qrtz_triggers
-- ----------------------------
INSERT INTO `qrtz_triggers` VALUES ('VblogScheduler', 'com.jzj.vblog.job.ArticleCountJob', 'Article', 'com.jzj.vblog.job.ArticleCountJob', 'Article', NULL, 1665307800000, 1665307680000, 5, 'WAITING', 'CRON', 1661255313000, 0, NULL, 0, '');
INSERT INTO `qrtz_triggers` VALUES ('VblogScheduler', 'com.jzj.vblog.job.HelloJob', 'Hello', 'com.jzj.vblog.job.HelloJob', 'Hello', NULL, 1661249656000, 1661249654000, 5, 'PAUSED', 'CRON', 1661170536000, 0, NULL, 0, '');

-- ----------------------------
-- Table structure for sys_config
-- ----------------------------
DROP TABLE IF EXISTS `sys_config`;
CREATE TABLE `sys_config`  (
  `id` int(5) NOT NULL AUTO_INCREMENT COMMENT '参数主键',
  `config_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '参数名称',
  `config_key` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '参数键名',
  `config_value` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '参数键值',
  `config_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT 'N' COMMENT '系统内置（Y是 N否）',
  `create_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '创建者',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '更新者',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '参数配置表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_config
-- ----------------------------
INSERT INTO `sys_config` VALUES (1, '主框架页-默认皮肤样式名称', 'sys.index.skinName', 'skin-blue', 'Y', 'admin', '2022-04-27 02:10:24', 'admin', '2022-07-22 02:28:46', '蓝色 skin-blue、绿色 skin-green、紫色 skin-purple、红色 skin-red、黄色 skin-yellow');
INSERT INTO `sys_config` VALUES (3, '主框架页-侧边栏主题', 'sys.index.sideTheme', 'theme-dark', 'Y', 'admin', '2022-04-27 02:10:24', '', NULL, '深色主题theme-dark，浅色主题theme-light');
INSERT INTO `sys_config` VALUES (6, 'oss云存储-是否开启云存储', 'sys.oss.enable', 'true', 'Y', 'admin', '2022-07-27 14:52:18', 'admin', '2022-07-29 15:02:59', '开启云存储需要配置application.yml里的oss相关参数（true开启，false关闭）');
INSERT INTO `sys_config` VALUES (7, '是否开启邮箱通知', 'sys_email_enable', 'true', 'Y', 'admin', '2022-09-20 14:45:07', 'admin', '2022-09-23 22:16:59', '后台回复留言，邮箱通知留言者,开启需要配置email相关参数 （true开启，false关闭）');

-- ----------------------------
-- Table structure for sys_count
-- ----------------------------
DROP TABLE IF EXISTS `sys_count`;
CREATE TABLE `sys_count`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT 'id',
  `article_count` bigint(20) NULL DEFAULT NULL COMMENT '文章数',
  `summary_count` bigint(20) NULL DEFAULT NULL COMMENT '归档数',
  `user_count` bigint(20) NULL DEFAULT NULL COMMENT '用户数',
  `click_count` bigint(20) NULL DEFAULT NULL COMMENT '点击数',
  `like_count` bigint(20) NULL DEFAULT NULL COMMENT '点赞数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '统计归档' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_count
-- ----------------------------
INSERT INTO `sys_count` VALUES ('1', 11, 4, 0, 187, 2);

-- ----------------------------
-- Table structure for sys_dict_data
-- ----------------------------
DROP TABLE IF EXISTS `sys_dict_data`;
CREATE TABLE `sys_dict_data`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '字典编码',
  `dict_sort` int(4) NULL DEFAULT 0 COMMENT '字典排序',
  `dict_label` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '字典标签',
  `dict_value` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '字典键值',
  `dict_type` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '字典类型',
  `css_class` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '样式属性（其他样式扩展）',
  `list_class` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '表格回显样式',
  `is_default` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT 'N' COMMENT '是否默认（Y是 N否）',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '状态（0正常 1停用）',
  `create_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '创建者',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '更新者',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 140 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '字典数据表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_dict_data
-- ----------------------------
INSERT INTO `sys_dict_data` VALUES (1, 1, '男', '0', 'sys_user_sex', '', '', 'Y', '0', 'admin', '2022-04-27 02:10:24', 'admin', '2022-07-22 06:16:44', '性别男');
INSERT INTO `sys_dict_data` VALUES (2, 2, '女', '1', 'sys_user_sex', '', '', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '性别女');
INSERT INTO `sys_dict_data` VALUES (3, 3, '未知', '2', 'sys_user_sex', '', '', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '性别未知');
INSERT INTO `sys_dict_data` VALUES (4, 1, '显示', '0', 'sys_show_hide', '', 'primary', 'Y', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '显示菜单');
INSERT INTO `sys_dict_data` VALUES (5, 2, '隐藏', '1', 'sys_show_hide', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '隐藏菜单');
INSERT INTO `sys_dict_data` VALUES (6, 1, '正常', '0', 'sys_normal_disable', '', 'primary', 'Y', '0', 'admin', '2022-04-27 02:10:24', 'admin', '2022-07-21 11:52:18', '正常状态');
INSERT INTO `sys_dict_data` VALUES (7, 2, '停用', '1', 'sys_normal_disable', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '停用状态');
INSERT INTO `sys_dict_data` VALUES (8, 1, '正常', '0', 'sys_job_status', '', 'primary', 'Y', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '正常状态');
INSERT INTO `sys_dict_data` VALUES (9, 2, '暂停', '1', 'sys_job_status', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '停用状态');
INSERT INTO `sys_dict_data` VALUES (10, 1, '默认', 'DEFAULT', 'sys_job_group', '', '', 'Y', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '默认分组');
INSERT INTO `sys_dict_data` VALUES (11, 2, '系统', 'SYSTEM', 'sys_job_group', '', '', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '系统分组');
INSERT INTO `sys_dict_data` VALUES (12, 1, '是', 'Y', 'sys_yes_no', '', 'primary', 'Y', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '系统默认是');
INSERT INTO `sys_dict_data` VALUES (13, 2, '否', 'N', 'sys_yes_no', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '系统默认否');
INSERT INTO `sys_dict_data` VALUES (14, 1, '通知', '1', 'sys_notice_type', '', 'warning', 'Y', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '通知');
INSERT INTO `sys_dict_data` VALUES (15, 2, '公告', '2', 'sys_notice_type', '', 'success', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '公告');
INSERT INTO `sys_dict_data` VALUES (16, 1, '正常', '0', 'sys_notice_status', '', 'primary', 'Y', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '正常状态');
INSERT INTO `sys_dict_data` VALUES (17, 2, '关闭', '1', 'sys_notice_status', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '关闭状态');
INSERT INTO `sys_dict_data` VALUES (18, 1, '新增', '1', 'sys_oper_type', '', 'info', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '新增操作');
INSERT INTO `sys_dict_data` VALUES (19, 2, '修改', '2', 'sys_oper_type', '', 'info', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '修改操作');
INSERT INTO `sys_dict_data` VALUES (20, 3, '删除', '3', 'sys_oper_type', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '删除操作');
INSERT INTO `sys_dict_data` VALUES (21, 4, '授权', '4', 'sys_oper_type', '', 'primary', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '授权操作');
INSERT INTO `sys_dict_data` VALUES (22, 5, '导出', '5', 'sys_oper_type', '', 'warning', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '导出操作');
INSERT INTO `sys_dict_data` VALUES (23, 6, '导入', '6', 'sys_oper_type', '', 'warning', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '导入操作');
INSERT INTO `sys_dict_data` VALUES (24, 7, '强退', '7', 'sys_oper_type', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '强退操作');
INSERT INTO `sys_dict_data` VALUES (25, 8, '生成代码', '8', 'sys_oper_type', '', 'warning', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '生成操作');
INSERT INTO `sys_dict_data` VALUES (26, 9, '清空数据', '9', 'sys_oper_type', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '清空操作');
INSERT INTO `sys_dict_data` VALUES (27, 1, '成功', '0', 'sys_common_status', '', 'primary', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '正常状态');
INSERT INTO `sys_dict_data` VALUES (28, 2, '失败', '1', 'sys_common_status', '', 'danger', 'N', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '停用状态');
INSERT INTO `sys_dict_data` VALUES (101, 0, '编程', '0', 'sys_article_type', NULL, 'primary', 'N', '0', 'admin', '2022-07-22 01:20:03', '', NULL, '编程');
INSERT INTO `sys_dict_data` VALUES (102, 1, '日常', '1', 'sys_article_type', NULL, 'primary', 'N', '0', 'admin', '2022-07-22 01:20:43', '', NULL, '日常');
INSERT INTO `sys_dict_data` VALUES (103, 0, 'Java', '0', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-07-22 01:21:22', '', NULL, 'Java');
INSERT INTO `sys_dict_data` VALUES (104, 0, 'SQL', '1', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-07-22 01:21:38', 'admin', '2022-08-08 09:27:52', 'SQL');
INSERT INTO `sys_dict_data` VALUES (105, 1, '下架', '0', 'sys_article_status', NULL, 'danger', 'N', '0', 'admin', '2022-07-22 19:22:30', 'admin', '2022-08-19 15:48:22', '文章下架');
INSERT INTO `sys_dict_data` VALUES (106, 0, '发布', '1', 'sys_article_status', NULL, 'primary', 'N', '0', 'admin', '2022-07-22 19:22:53', 'admin', '2022-08-19 15:48:16', '文章发布');
INSERT INTO `sys_dict_data` VALUES (107, 0, '默认', '0', 'sys_article_top', NULL, 'primary', 'N', '0', 'admin', '2022-07-22 19:24:59', 'admin', '2022-07-22 19:27:42', '不置顶');
INSERT INTO `sys_dict_data` VALUES (108, 0, '置顶', '1', 'sys_article_top', NULL, 'success', 'N', '0', 'admin', '2022-07-22 19:25:07', 'admin', '2022-08-05 15:51:39', '置顶');
INSERT INTO `sys_dict_data` VALUES (109, 0, '原创', '0', 'sys_article_origin', NULL, 'success', 'N', '0', 'admin', '2022-07-22 19:27:31', 'admin', '2022-08-05 15:51:53', '文章原创');
INSERT INTO `sys_dict_data` VALUES (110, 0, '转载', '1', 'sys_article_origin', NULL, 'primary', 'N', '0', 'admin', '2022-07-22 19:28:10', '', NULL, '转载');
INSERT INTO `sys_dict_data` VALUES (111, 0, '开启', '0', 'sys_article_comment', NULL, 'primary', 'N', '0', 'admin', '2022-07-22 19:28:36', 'admin', '2022-07-22 19:28:40', '开启评论');
INSERT INTO `sys_dict_data` VALUES (112, 0, '关闭', '1', 'sys_article_comment', NULL, 'danger', 'N', '0', 'admin', '2022-07-22 19:28:54', 'admin', '2022-08-05 15:52:04', '关闭评论');
INSERT INTO `sys_dict_data` VALUES (113, 0, '工具', '0', 'sys_website_type', NULL, 'primary', 'N', '0', 'admin', '2022-07-26 15:28:50', '', NULL, '工具');
INSERT INTO `sys_dict_data` VALUES (114, 0, 'Java', '1', 'sys_website_type', NULL, 'primary', 'N', '0', 'admin', '2022-07-26 15:29:03', '', NULL, 'Java');
INSERT INTO `sys_dict_data` VALUES (115, 0, '前端', '2', 'sys_website_type', NULL, 'primary', 'N', '0', 'admin', '2022-07-26 15:29:13', 'admin', '2022-07-26 15:29:18', '前端');
INSERT INTO `sys_dict_data` VALUES (116, 0, '发布', '0', 'sys_website_status', NULL, 'success', 'N', '0', 'admin', '2022-07-26 15:32:28', 'admin', '2022-09-09 16:40:26', '发布');
INSERT INTO `sys_dict_data` VALUES (117, 0, '下架', '1', 'sys_website_status', NULL, 'info', 'N', '0', 'admin', '2022-07-26 15:32:42', 'admin', '2022-07-27 16:36:26', '下架');
INSERT INTO `sys_dict_data` VALUES (118, 0, 'Spring', '2', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-08-08 09:27:25', 'admin', '2022-08-08 09:27:39', 'spring');
INSERT INTO `sys_dict_data` VALUES (119, 0, 'Spring MVC', '3', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-08-08 09:28:23', '', NULL, 'Spring MVC');
INSERT INTO `sys_dict_data` VALUES (120, 0, 'MyBatis', '4', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-08-08 09:28:42', 'admin', '2022-08-08 09:28:54', 'Mybatis');
INSERT INTO `sys_dict_data` VALUES (121, 0, '上架', '1', 'sys_summary_status', NULL, 'primary', 'N', '0', 'admin', '2022-08-11 11:31:07', 'admin', '2022-08-11 11:31:40', '上架');
INSERT INTO `sys_dict_data` VALUES (122, 0, '下架', '0', 'sys_summary_status', NULL, 'danger', 'N', '0', 'admin', '2022-08-11 11:31:26', 'admin', '2022-08-11 11:31:35', '下架');
INSERT INTO `sys_dict_data` VALUES (123, 0, '默认', '0', 'sys_summary_top', NULL, 'success', 'N', '0', 'admin', '2022-08-12 19:17:40', 'admin', '2022-08-12 19:43:52', '不显示在首页');
INSERT INTO `sys_dict_data` VALUES (124, 0, '展示', '1', 'sys_summary_top', NULL, 'primary', 'N', '0', 'admin', '2022-08-12 19:17:54', 'admin', '2022-08-12 19:43:48', '显示在首页');
INSERT INTO `sys_dict_data` VALUES (125, 0, 'BUG', '2', 'sys_article_type', NULL, 'primary', 'N', '0', 'admin', '2022-08-19 15:45:26', 'admin', '2022-08-19 15:45:32', 'BUG');
INSERT INTO `sys_dict_data` VALUES (126, 0, '算法', '5', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-08-19 15:46:31', '', NULL, '算法');
INSERT INTO `sys_dict_data` VALUES (127, 0, 'JUC', '6', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-08-29 09:25:52', '', NULL, 'JUC');
INSERT INTO `sys_dict_data` VALUES (128, 0, '发布', '1', 'sys_friend_link', NULL, 'primary', 'N', '0', 'admin', '2022-09-09 16:40:51', '', NULL, '发布');
INSERT INTO `sys_dict_data` VALUES (129, 0, '下架', '0', 'sys_friend_link', NULL, 'danger', 'N', '0', 'admin', '2022-09-09 16:41:10', '', NULL, '下架');
INSERT INTO `sys_dict_data` VALUES (130, 0, '留言板', '0', 'article_comment_type', NULL, 'primary', 'N', '0', 'admin', '2022-09-11 15:32:58', '', NULL, '留言板');
INSERT INTO `sys_dict_data` VALUES (131, 0, '文章', '1', 'article_comment_type', NULL, 'success', 'N', '0', 'admin', '2022-09-11 15:33:16', '', NULL, '文章评论');
INSERT INTO `sys_dict_data` VALUES (132, 0, '未回复', '0', 'article_comment_status', NULL, 'danger', 'N', '0', 'admin', '2022-09-11 15:35:37', 'admin', '2022-09-11 15:35:46', '未回复');
INSERT INTO `sys_dict_data` VALUES (133, 0, '已回复', '1', 'article_comment_status', NULL, 'success', 'N', '0', 'admin', '2022-09-11 15:35:58', 'admin', '2022-09-11 15:36:10', '已回复');
INSERT INTO `sys_dict_data` VALUES (134, 0, '未审核', '0', 'article_comment_audit_status', NULL, 'info', 'N', '0', 'admin', '2022-09-23 21:08:23', '', NULL, '未审核');
INSERT INTO `sys_dict_data` VALUES (135, 0, '通过', '1', 'article_comment_audit_status', NULL, 'success', 'N', '0', 'admin', '2022-09-23 21:08:41', '', NULL, '通过');
INSERT INTO `sys_dict_data` VALUES (136, 0, '未通过', '2', 'article_comment_audit_status', NULL, 'danger', 'N', '0', 'admin', '2022-09-23 21:09:02', '', NULL, '未通过');
INSERT INTO `sys_dict_data` VALUES (137, 0, 'OSS', '7', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-09-26 10:06:37', '', NULL, 'OSS');
INSERT INTO `sys_dict_data` VALUES (138, 0, '短信', '9', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-09-26 14:51:32', '', NULL, '短信');
INSERT INTO `sys_dict_data` VALUES (139, 0, 'NIO', '10', 'sys_article_tag', NULL, 'primary', 'N', '0', 'admin', '2022-09-30 15:07:08', '', NULL, 'NIO');

-- ----------------------------
-- Table structure for sys_dict_type
-- ----------------------------
DROP TABLE IF EXISTS `sys_dict_type`;
CREATE TABLE `sys_dict_type`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '字典主键',
  `dict_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '字典名称',
  `dict_type` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '字典类型',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '状态（0正常 1停用）',
  `create_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '创建者',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '更新者',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `dict_type`(`dict_type`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 118 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '字典类型表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_dict_type
-- ----------------------------
INSERT INTO `sys_dict_type` VALUES (1, '用户性别', 'sys_user_sex', '0', 'admin', '2022-04-27 02:10:24', 'admin', '2022-07-22 06:57:38', '用户性别列表');
INSERT INTO `sys_dict_type` VALUES (2, '菜单状态', 'sys_show_hide', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '菜单状态列表');
INSERT INTO `sys_dict_type` VALUES (3, '系统开关', 'sys_normal_disable', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '系统开关列表');
INSERT INTO `sys_dict_type` VALUES (4, '任务状态', 'sys_job_status', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '任务状态列表');
INSERT INTO `sys_dict_type` VALUES (5, '任务分组', 'sys_job_group', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '任务分组列表');
INSERT INTO `sys_dict_type` VALUES (6, '系统是否', 'sys_yes_no', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '系统是否列表');
INSERT INTO `sys_dict_type` VALUES (7, '通知类型', 'sys_notice_type', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '通知类型列表');
INSERT INTO `sys_dict_type` VALUES (8, '通知状态', 'sys_notice_status', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '通知状态列表');
INSERT INTO `sys_dict_type` VALUES (9, '操作类型', 'sys_oper_type', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '操作类型列表');
INSERT INTO `sys_dict_type` VALUES (10, '系统状态', 'sys_common_status', '0', 'admin', '2022-04-27 02:10:24', '', NULL, '登录状态列表');
INSERT INTO `sys_dict_type` VALUES (100, '文章分类', 'sys_article_type', '0', 'admin', '2022-07-20 01:14:22', 'admin', '2022-07-22 06:17:14', '文章分类');
INSERT INTO `sys_dict_type` VALUES (104, '文章标签', 'sys_article_tag', '0', 'admin', '2022-07-22 01:19:31', '', NULL, '文章标签');
INSERT INTO `sys_dict_type` VALUES (106, '文章状态', 'sys_article_status', '0', 'admin', '2022-07-22 17:09:06', '', NULL, '文章状态');
INSERT INTO `sys_dict_type` VALUES (107, '文章置顶', 'sys_article_top', '0', 'admin', '2022-07-22 19:23:51', '', NULL, '文章是否置顶');
INSERT INTO `sys_dict_type` VALUES (108, '文章原创', 'sys_article_origin', '0', 'admin', '2022-07-22 19:26:02', '', NULL, '文章是否原创');
INSERT INTO `sys_dict_type` VALUES (109, '文章评论', 'sys_article_comment', '0', 'admin', '2022-07-22 19:26:44', '', NULL, '是否开启评论');
INSERT INTO `sys_dict_type` VALUES (110, '资源分类', 'sys_website_type', '0', 'admin', '2022-07-26 15:27:22', '', NULL, '资源分类');
INSERT INTO `sys_dict_type` VALUES (111, '资源状态', 'sys_website_status', '0', 'admin', '2022-07-26 15:32:05', '', NULL, '资源状态');
INSERT INTO `sys_dict_type` VALUES (112, '归档状态', 'sys_summary_status', '0', 'admin', '2022-08-11 11:30:26', '', NULL, '归档状态');
INSERT INTO `sys_dict_type` VALUES (113, '归档置顶', 'sys_summary_top', '0', 'admin', '2022-08-12 19:17:03', '', NULL, '归档置顶');
INSERT INTO `sys_dict_type` VALUES (114, '友链状态', 'sys_friend_link', '0', 'admin', '2022-09-09 16:38:49', '', NULL, '友链状态');
INSERT INTO `sys_dict_type` VALUES (115, '评论类型', 'article_comment_type', '0', 'admin', '2022-09-11 15:32:13', '', NULL, '评论类型');
INSERT INTO `sys_dict_type` VALUES (116, '评论状态', 'article_comment_status', '0', 'admin', '2022-09-11 15:35:16', 'admin', '2022-09-12 19:04:17', '评论状态');
INSERT INTO `sys_dict_type` VALUES (117, '评论审核状态', 'article_comment_audit_status', '0', 'admin', '2022-09-23 21:08:01', '', NULL, '评论审核状态');

-- ----------------------------
-- Table structure for sys_logininfor
-- ----------------------------
DROP TABLE IF EXISTS `sys_logininfor`;
CREATE TABLE `sys_logininfor`  (
  `info_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '访问ID',
  `user_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '用户账号',
  `ipaddr` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '登录IP地址',
  `login_location` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '登录地点',
  `browser` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '浏览器类型',
  `os` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '操作系统',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '登录状态（0成功 1失败）',
  `msg` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '提示消息',
  `login_time` datetime NULL DEFAULT NULL COMMENT '访问时间',
  PRIMARY KEY (`info_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 112 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '系统访问记录' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_logininfor
-- ----------------------------
INSERT INTO `sys_logininfor` VALUES (100, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-04-27 02:14:22');
INSERT INTO `sys_logininfor` VALUES (101, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-05-13 07:16:40');
INSERT INTO `sys_logininfor` VALUES (102, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-07-11 01:19:05');
INSERT INTO `sys_logininfor` VALUES (103, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-07-11 06:03:09');
INSERT INTO `sys_logininfor` VALUES (104, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-07-11 07:08:20');
INSERT INTO `sys_logininfor` VALUES (105, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-07-20 00:52:08');
INSERT INTO `sys_logininfor` VALUES (106, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-07-21 08:29:27');
INSERT INTO `sys_logininfor` VALUES (107, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '1', '验证码错误', '2022-07-21 09:20:15');
INSERT INTO `sys_logininfor` VALUES (108, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-07-21 09:20:21');
INSERT INTO `sys_logininfor` VALUES (109, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '退出成功', '2022-07-21 09:30:15');
INSERT INTO `sys_logininfor` VALUES (110, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-07-21 09:30:22');
INSERT INTO `sys_logininfor` VALUES (111, 'admin', '127.0.0.1', '内网IP', 'Chrome 10', 'Windows 10', '0', '登录成功', '2022-07-21 11:05:38');

-- ----------------------------
-- Table structure for sys_notice
-- ----------------------------
DROP TABLE IF EXISTS `sys_notice`;
CREATE TABLE `sys_notice`  (
  `notice_id` int(4) NOT NULL AUTO_INCREMENT COMMENT '公告ID',
  `notice_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '公告标题',
  `notice_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '公告类型（1通知 2公告）',
  `notice_content` longblob NULL COMMENT '公告内容',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '公告状态（0正常 1关闭）',
  `create_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '创建者',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '更新者',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`notice_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '通知公告表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_notice
-- ----------------------------

-- ----------------------------
-- Table structure for sys_oper_log
-- ----------------------------
DROP TABLE IF EXISTS `sys_oper_log`;
CREATE TABLE `sys_oper_log`  (
  `oper_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '日志主键',
  `title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '模块标题',
  `business_type` int(2) NULL DEFAULT 0 COMMENT '业务类型（0其它 1新增 2修改 3删除）',
  `method` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '方法名称',
  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '请求方式',
  `operator_type` int(1) NULL DEFAULT 0 COMMENT '操作类别（0其它 1后台用户 2手机端用户）',
  `oper_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '操作人员',
  `dept_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '部门名称',
  `oper_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '请求URL',
  `oper_ip` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '主机地址',
  `oper_location` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '操作地点',
  `oper_param` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '请求参数',
  `json_result` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '返回参数',
  `status` int(1) NULL DEFAULT 0 COMMENT '操作状态（0正常 1异常）',
  `error_msg` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '错误消息',
  `oper_time` datetime NULL DEFAULT NULL COMMENT '操作时间',
  PRIMARY KEY (`oper_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 218 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '操作日志记录' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_oper_log
-- ----------------------------
INSERT INTO `sys_oper_log` VALUES (1, '操作日志', 9, 'com.jzj.vblog.web.controller.admin.SysOperLogController.clean()', 'DELETE', 1, 'admin', NULL, '/monitor/operlog/clean', '127.0.0.1', '内网IP', '{}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-25 19:49:45');
INSERT INTO `sys_oper_log` VALUES (2, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/5bce8eaf8da046d0a6a3fa9cb3bd7d73.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:18:51');
INSERT INTO `sys_oper_log` VALUES (3, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/18402bdab80543b5b73a7185e0e95f07.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:19:47');
INSERT INTO `sys_oper_log` VALUES (4, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d629efc794464f7f9b4684e87b7e3248.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:20:07');
INSERT INTO `sys_oper_log` VALUES (5, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/f88271f5e6e5490e86323f6065d01995.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:21:22');
INSERT INTO `sys_oper_log` VALUES (6, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4f8eb2f9256b4e369aaf5d60ecfca784.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:21:47');
INSERT INTO `sys_oper_log` VALUES (7, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（一）\",\"introduce\":\"阿里云OSS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/5bce8eaf8da046d0a6a3fa9cb3bd7d73.jpg\",\"sort\":0,\"content\":\"# 一、使用SDK\\n在OSS的概览页右下角找到“Bucket管理”，点击“OSS学习路径”\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/18402bdab80543b5b73a7185e0e95f07.png)\\n点击“Java SDK”进入SDK开发文档\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d629efc794464f7f9b4684e87b7e3248.png)\\n# 二、创建测试项目\\n## 1、创建Maven项目\\ncom.jzj\\naliyun-oss\\n## 2、配置pom\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/f88271f5e6e5490e86323f6065d01995.png)\\n```java\\n<dependencies>\\n    <!--aliyunOSS-->\\n    <dependency>\\n        <groupId>com.aliyun.oss</groupId>\\n        <artifactId>aliyun-sdk-oss</artifactId>\\n        <version>3.10.2</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>junit</groupId>\\n        <artifactId>junit</artifactId>\\n        <version>4.12</version>\\n    </dependency>\\n</dependencies>\\n```\\n# 三、测试用例\\n## 1、创建Bucket\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4f8eb2f9256b4e369aaf5d60ecfca784.png)\\n```java\\npackage com.atguigu.aliyunoss;\\npublic class OSSTest {\\n    // Endpoint以杭州为例，其它Region请按实际情况填写。\\n    String endpoint = \\\"your endpoint\\\";\\n    // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。\\n    String accessKeyId = \\\"your accessKeyId\\\";\\n    String accessKeySecret = \\\"your accessKeySecret\\\";\\n    String bucketName = \\\"srb-file\\\";\\n    @Test\\n    public void testCreateBucket() {\\n        \\n        // 创建OSSClient实例。\\n        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\\n        // 创建存储空间。\\n        ossClient.createBucket(bucketName);\\n        // 关闭OSSClient。\\n        ossClient.shutdown();\\n    }\\n}\\n```\\n## 2、判断bucket是否存在\\n```java\\n@Test\\npublic void testExist() {\\n    // 创建OSSClient实例。\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:21:55');
INSERT INTO `sys_oper_log` VALUES (8, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（一）\",\"introduce\":\"阿里云OSS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/5bce8eaf8da046d0a6a3fa9cb3bd7d73.jpg\",\"sort\":0,\"content\":\"# 一、使用SDK\\n在OSS的概览页右下角找到“Bucket管理”，点击“OSS学习路径”\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/18402bdab80543b5b73a7185e0e95f07.png)\\n点击“Java SDK”进入SDK开发文档\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d629efc794464f7f9b4684e87b7e3248.png)\\n# 二、创建测试项目\\n## 1、创建Maven项目\\ncom.jzj\\naliyun-oss\\n## 2、配置pom\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/f88271f5e6e5490e86323f6065d01995.png)\\n```java\\n<dependencies>\\n    <!--aliyunOSS-->\\n    <dependency>\\n        <groupId>com.aliyun.oss</groupId>\\n        <artifactId>aliyun-sdk-oss</artifactId>\\n        <version>3.10.2</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>junit</groupId>\\n        <artifactId>junit</artifactId>\\n        <version>4.12</version>\\n    </dependency>\\n</dependencies>\\n```\\n# 三、测试用例\\n## 1、创建Bucket\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4f8eb2f9256b4e369aaf5d60ecfca784.png)\\n```java\\npackage com.atguigu.aliyunoss;\\npublic class OSSTest {\\n    // Endpoint以杭州为例，其它Region请按实际情况填写。\\n    String endpoint = \\\"your endpoint\\\";\\n    // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。\\n    String accessKeyId = \\\"your accessKeyId\\\";\\n    String accessKeySecret = \\\"your accessKeySecret\\\";\\n    String bucketName = \\\"srb-file\\\";\\n    @Test\\n    public void testCreateBucket() {\\n        \\n        // 创建OSSClient实例。\\n        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\\n        // 创建存储空间。\\n        ossClient.createBucket(bucketName);\\n        // 关闭OSSClient。\\n        ossClient.shutdown();\\n    }\\n}\\n```\\n## 2、判断bucket是否存在\\n```java\\n@Test\\npublic void testExist() {\\n    // 创建OSSClient实例。\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:25:49');
INSERT INTO `sys_oper_log` VALUES (9, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/e5a630491c4c4eabb9b0f6cd408afcbb.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:57:17');
INSERT INTO `sys_oper_log` VALUES (10, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:59:08');
INSERT INTO `sys_oper_log` VALUES (11, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:59:29');
INSERT INTO `sys_oper_log` VALUES (12, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/0661850ad85d44138f0ac025e82f31ea.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 09:59:31');
INSERT INTO `sys_oper_log` VALUES (13, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:00:33');
INSERT INTO `sys_oper_log` VALUES (14, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:00:53');
INSERT INTO `sys_oper_log` VALUES (15, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:01:02');
INSERT INTO `sys_oper_log` VALUES (16, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:01:12');
INSERT INTO `sys_oper_log` VALUES (17, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/73916e75a24b4af093231601451c2a98.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:01:25');
INSERT INTO `sys_oper_log` VALUES (18, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:01:32');
INSERT INTO `sys_oper_log` VALUES (19, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（二）\",\"introduce\":\"阿里云OSS（二）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/e5a630491c4c4eabb9b0f6cd408afcbb.jpg\",\"sort\":0,\"content\":\"# 一、开通“对象存储OSS”服务\\n为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。 \\n## 1、开通“对象存储OSS”服务\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png)\\n![image.png](2)\\n## 2、进入管理控制台\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png)\\n# 二、控制台使用\\n## 1、创建Bucket\\n命名：vblog-file\\n读写权限：公共读\\n## 2、上传默认头像\\n创建文件夹avatar，上传默认的用户头像\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png)\\n三、使用RAM子用户\\n## 三、使用RAM子用户\\n## 1、进入子用户管理页面\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png)\\n## 2、添加用户\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png)\\n## 3、获取子用户key\\nAccessKeyId, AccessKeySecret\\n\\n## 4、设置用户权限\\nAliyunOSSFullAccess\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png)\\n\",\"commentStatus\":\"0\",\"htmlContent\":\"<h1><a id=\\\"OSS_0\\\"></a>一、开通“对象存储OSS”服务</h1>\\n<p>为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。</p>\\n<h2><a id=\\\"1OSS_2\\\"></a>1、开通“对象存储OSS”服务</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png\\\" alt=\\\"image.png\\\" /><br />\\n<img src=\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArkAAAEvCAYAAABBidl3AAAgAElEQVR4nOy9aaxl13Xn91t7n3Pu8OYaWSOrSFaJk8RREilRoiR6Usuttt2W43Y77TaMIEijA3SCJGggyfd86CDoIDASBGgbHjppqANY1mDLkjVL1ECRFGeKLLI411xvfvfec/Ze+bD3ufc+klI32aZVrlo/4bHeu8M5++yrD/+7zn/9l6iqYhiGYRiGYRiXEe5nvQDDMAzDMAzD+JvGRK5hGIZhGIZx2WEi1zAMwzAMw7jsMJF', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:01:37');
INSERT INTO `sys_oper_log` VALUES (20, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（1）\",\"introduce\":\"阿里云OSS（二）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/e5a630491c4c4eabb9b0f6cd408afcbb.jpg\",\"sort\":0,\"content\":\"# 一、开通“对象存储OSS”服务\\n为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。 \\n## 1、开通“对象存储OSS”服务\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png)\\n![image.png](2)\\n## 2、进入管理控制台\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png)\\n# 二、控制台使用\\n## 1、创建Bucket\\n命名：vblog-file\\n读写权限：公共读\\n## 2、上传默认头像\\n创建文件夹avatar，上传默认的用户头像\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png)\\n三、使用RAM子用户\\n## 三、使用RAM子用户\\n## 1、进入子用户管理页面\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png)\\n## 2、添加用户\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png)\\n## 3、获取子用户key\\nAccessKeyId, AccessKeySecret\\n\\n## 4、设置用户权限\\nAliyunOSSFullAccess\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png)\\n\",\"commentStatus\":\"0\",\"htmlContent\":\"<h1><a id=\\\"OSS_0\\\"></a>一、开通“对象存储OSS”服务</h1>\\n<p>为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。</p>\\n<h2><a id=\\\"1OSS_2\\\"></a>1、开通“对象存储OSS”服务</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png\\\" alt=\\\"image.png\\\" /><br />\\n<img src=\\\"2\\\" alt=\\\"image.png\\\" /></p>\\n<h2><a id=\\\"2_5\\\"></a>2、进入管理控制台</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png\\\" alt=\\\"image.png\\\" /></p>\\n<h1><a id=\\\"_7\\\"></a>二、控制台使用</h1>\\n<h2><a id=\\\"1Bucket_8\\\"></a>1、创建Bucket</h2>\\n<p>命名：vblog-file<br ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:01:49');
INSERT INTO `sys_oper_log` VALUES (21, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（二）\",\"introduce\":\"阿里云OSS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/5bce8eaf8da046d0a6a3fa9cb3bd7d73.jpg\",\"sort\":0,\"content\":\"# 一、使用SDK\\n在OSS的概览页右下角找到“Bucket管理”，点击“OSS学习路径”\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/18402bdab80543b5b73a7185e0e95f07.png)\\n点击“Java SDK”进入SDK开发文档\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d629efc794464f7f9b4684e87b7e3248.png)\\n# 二、创建测试项目\\n## 1、创建Maven项目\\ncom.jzj\\naliyun-oss\\n## 2、配置pom\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/f88271f5e6e5490e86323f6065d01995.png)\\n```java\\n<dependencies>\\n    <!--aliyunOSS-->\\n    <dependency>\\n        <groupId>com.aliyun.oss</groupId>\\n        <artifactId>aliyun-sdk-oss</artifactId>\\n        <version>3.10.2</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>junit</groupId>\\n        <artifactId>junit</artifactId>\\n        <version>4.12</version>\\n    </dependency>\\n</dependencies>\\n```\\n# 三、测试用例\\n## 1、创建Bucket\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4f8eb2f9256b4e369aaf5d60ecfca784.png)\\n```java\\npackage com.atguigu.aliyunoss;\\npublic class OSSTest {\\n    // Endpoint以杭州为例，其它Region请按实际情况填写。\\n    String endpoint = \\\"your endpoint\\\";\\n    // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。\\n    String accessKeyId = \\\"your accessKeyId\\\";\\n    String accessKeySecret = \\\"your accessKeySecret\\\";\\n    String bucketName = \\\"srb-file\\\";\\n    @Test\\n    public void testCreateBucket() {\\n        \\n        // 创建OSSClient实例。\\n        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\\n        // 创建存储空间。\\n        ossClient.createBucket(bucketName);\\n        // 关闭OSSClient。\\n        ossClient.shutdown();\\n    }\\n}\\n```\\n## 2、判断bucket是否存在\\n```java\\n@Test\\npublic void testExist() {\\n    // 创建OSSClient实例。\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:01:56');
INSERT INTO `sys_oper_log` VALUES (22, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（一）\",\"introduce\":\"阿里云OSS（二）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/e5a630491c4c4eabb9b0f6cd408afcbb.jpg\",\"sort\":0,\"content\":\"# 一、开通“对象存储OSS”服务\\n为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。 \\n## 1、开通“对象存储OSS”服务\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png)\\n![image.png](2)\\n## 2、进入管理控制台\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png)\\n# 二、控制台使用\\n## 1、创建Bucket\\n命名：vblog-file\\n读写权限：公共读\\n## 2、上传默认头像\\n创建文件夹avatar，上传默认的用户头像\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png)\\n三、使用RAM子用户\\n## 三、使用RAM子用户\\n## 1、进入子用户管理页面\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png)\\n## 2、添加用户\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png)\\n## 3、获取子用户key\\nAccessKeyId, AccessKeySecret\\n\\n## 4、设置用户权限\\nAliyunOSSFullAccess\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png)\\n\",\"commentStatus\":\"0\",\"htmlContent\":\"<h1><a id=\\\"OSS_0\\\"></a>一、开通“对象存储OSS”服务</h1>\\n<p>为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。</p>\\n<h2><a id=\\\"1OSS_2\\\"></a>1、开通“对象存储OSS”服务</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png\\\" alt=\\\"image.png\\\" /><br />\\n<img src=\\\"2\\\" alt=\\\"image.png\\\" /></p>\\n<h2><a id=\\\"2_5\\\"></a>2、进入管理控制台</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png\\\" alt=\\\"image.png\\\" /></p>\\n<h1><a id=\\\"_7\\\"></a>二、控制台使用</h1>\\n<h2><a id=\\\"1Bucket_8\\\"></a>1、创建Bucket</h2>\\n<p>命名：vblog-file<br ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:02:02');
INSERT INTO `sys_oper_log` VALUES (23, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:02:30');
INSERT INTO `sys_oper_log` VALUES (24, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（一）\",\"introduce\":\"阿里云OSS（二）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/e5a630491c4c4eabb9b0f6cd408afcbb.jpg\",\"sort\":0,\"content\":\"# 一、开通“对象存储OSS”服务\\n为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。 \\n## 1、开通“对象存储OSS”服务\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png)\\n## 2、进入管理控制台\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png)\\n# 二、控制台使用\\n## 1、创建Bucket\\n命名：vblog-file\\n读写权限：公共读\\n## 2、上传默认头像\\n创建文件夹avatar，上传默认的用户头像\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png)\\n三、使用RAM子用户\\n## 三、使用RAM子用户\\n## 1、进入子用户管理页面\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png)\\n## 2、添加用户\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png)\\n## 3、获取子用户key\\nAccessKeyId, AccessKeySecret\\n\\n## 4、设置用户权限\\nAliyunOSSFullAccess\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png)\\n\",\"commentStatus\":\"0\",\"htmlContent\":\"<h1><a id=\\\"OSS_0\\\"></a>一、开通“对象存储OSS”服务</h1>\\n<p>为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。</p>\\n<h2><a id=\\\"1OSS_2\\\"></a>1、开通“对象存储OSS”服务</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png\\\" alt=\\\"image.png\\\" /><br />\\n<img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png\\\" alt=\\\"image.png\\\" /></p>\\n<h2><a id=\\\"2_5\\\"></a>2、进入管理控制台</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shen', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:02:40');
INSERT INTO `sys_oper_log` VALUES (25, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleSummary', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/26/03b075772ba346ecbe91110f6fd9b4f4.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:02:57');
INSERT INTO `sys_oper_log` VALUES (26, '归档管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleSummaryController.add()', 'POST', 1, 'admin', NULL, '/article/summary', '127.0.0.1', '内网IP', '{\"createTime\":1664157778736,\"author\":\"漫漫长路\",\"name\":\"阿里云OSS\",\"banner\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/26/03b075772ba346ecbe91110f6fd9b4f4.jpg\",\"updateTime\":1664157778736,\"id\":\"09d7c62e8f9d0348782c6381e2c0b6c0\",\"params\":{},\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:02:58');
INSERT INTO `sys_oper_log` VALUES (27, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateSummaryById()', 'PUT', 1, 'admin', NULL, '/article/inform/updateSummaryById/0ae360525f681ccd6c35c0cda7bc87c2,7d9a6f525ea2d6778e3b2a58a2d985a7/09d7c62e8f9d0348782c6381e2c0b6c0/1', '127.0.0.1', '内网IP', '0ae360525f681ccd6c35c0cda7bc87c2,7d9a6f525ea2d6778e3b2a58a2d985a7 09d7c62e8f9d0348782c6381e2c0b6c0 1', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:03:07');
INSERT INTO `sys_oper_log` VALUES (28, '字典类型', 9, 'com.jzj.vblog.web.controller.admin.SysDictTypeController.refreshCache()', 'DELETE', 1, 'admin', NULL, '/system/dict/type/refreshCache', '127.0.0.1', '内网IP', '{}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:05:53');
INSERT INTO `sys_oper_log` VALUES (29, '字典类型', 1, 'com.jzj.vblog.web.controller.admin.SysDictDataController.add()', 'POST', 1, 'admin', NULL, '/system/dict/data', '127.0.0.1', '内网IP', '{\"dictValue\":\"7\",\"listClass\":\"primary\",\"dictSort\":0,\"remark\":\"OSS\",\"updateTime\":1664157997802,\"params\":{},\"dictType\":\"sys_article_tag\",\"dictLabel\":\"OSS\",\"createBy\":\"admin\",\"createTime\":1664157997802,\"status\":\"0\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:06:37');
INSERT INTO `sys_oper_log` VALUES (30, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（一）\",\"introduce\":\"阿里云OSS（二）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/e5a630491c4c4eabb9b0f6cd408afcbb.jpg\",\"sort\":0,\"content\":\"# 一、开通“对象存储OSS”服务\\n为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。 \\n## 1、开通“对象存储OSS”服务\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png)\\n## 2、进入管理控制台\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png)\\n# 二、控制台使用\\n## 1、创建Bucket\\n命名：vblog-file\\n读写权限：公共读\\n## 2、上传默认头像\\n创建文件夹avatar，上传默认的用户头像\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png)\\n三、使用RAM子用户\\n## 三、使用RAM子用户\\n## 1、进入子用户管理页面\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png)\\n## 2、添加用户\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png)\\n## 3、获取子用户key\\nAccessKeyId, AccessKeySecret\\n\\n## 4、设置用户权限\\nAliyunOSSFullAccess\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png)\\n\",\"commentStatus\":\"0\",\"htmlContent\":\"<h1><a id=\\\"OSS_0\\\"></a>一、开通“对象存储OSS”服务</h1>\\n<p>为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。</p>\\n<h2><a id=\\\"1OSS_2\\\"></a>1、开通“对象存储OSS”服务</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png\\\" alt=\\\"image.png\\\" /><br />\\n<img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png\\\" alt=\\\"image.png\\\" /></p>\\n<h2><a id=\\\"2_5\\\"></a>2、进入管理控制台</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shen', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:06:50');
INSERT INTO `sys_oper_log` VALUES (31, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（二）\",\"introduce\":\"阿里云OSS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/5bce8eaf8da046d0a6a3fa9cb3bd7d73.jpg\",\"sort\":0,\"content\":\"# 一、使用SDK\\n在OSS的概览页右下角找到“Bucket管理”，点击“OSS学习路径”\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/18402bdab80543b5b73a7185e0e95f07.png)\\n点击“Java SDK”进入SDK开发文档\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d629efc794464f7f9b4684e87b7e3248.png)\\n# 二、创建测试项目\\n## 1、创建Maven项目\\ncom.jzj\\naliyun-oss\\n## 2、配置pom\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/f88271f5e6e5490e86323f6065d01995.png)\\n```java\\n<dependencies>\\n    <!--aliyunOSS-->\\n    <dependency>\\n        <groupId>com.aliyun.oss</groupId>\\n        <artifactId>aliyun-sdk-oss</artifactId>\\n        <version>3.10.2</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>junit</groupId>\\n        <artifactId>junit</artifactId>\\n        <version>4.12</version>\\n    </dependency>\\n</dependencies>\\n```\\n# 三、测试用例\\n## 1、创建Bucket\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4f8eb2f9256b4e369aaf5d60ecfca784.png)\\n```java\\npackage com.atguigu.aliyunoss;\\npublic class OSSTest {\\n    // Endpoint以杭州为例，其它Region请按实际情况填写。\\n    String endpoint = \\\"your endpoint\\\";\\n    // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。\\n    String accessKeyId = \\\"your accessKeyId\\\";\\n    String accessKeySecret = \\\"your accessKeySecret\\\";\\n    String bucketName = \\\"srb-file\\\";\\n    @Test\\n    public void testCreateBucket() {\\n        \\n        // 创建OSSClient实例。\\n        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\\n        // 创建存储空间。\\n        ossClient.createBucket(bucketName);\\n        // 关闭OSSClient。\\n        ossClient.shutdown();\\n    }\\n}\\n```\\n## 2、判断bucket是否存在\\n```java\\n@Test\\npublic void testExist() {\\n    // 创建OSSClient实例。\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:07:00');
INSERT INTO `sys_oper_log` VALUES (32, '前台评论', 1, 'com.jzj.vblog.web.controller.front.CommentController.saveMessage()', 'POST', 1, 'admin', NULL, '/front/comment/insert/message', '127.0.0.1', '内网IP', '{\"city\":\"未知地址\",\"nickName\":\"刘德华\",\"ip\":\"127.0.0.1\",\"parentStatus\":\"1\",\"articleId\":\"0ae360525f681ccd6c35c0cda7bc87c2\",\"updateTime\":1664158856687,\"avatar\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/09/19/1b0d32a2d72e4ed58b7cc6ede72621b0.png\",\"params\":{},\"content\":\"写得真好\",\"createTime\":1664158856687,\"commentType\":\"1\",\"auditStatus\":\"0\",\"id\":\"012f43a6d3a8c9cd9aec4c0eab24dcc8\",\"email\":\"946232976@qq.com\",\"status\":\"0\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:20:56');
INSERT INTO `sys_oper_log` VALUES (33, '评论管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleCommentController.audit()', 'PUT', 1, 'admin', NULL, '/article/comment/012f43a6d3a8c9cd9aec4c0eab24dcc8/1', '127.0.0.1', '内网IP', '[\"012f43a6d3a8c9cd9aec4c0eab24dcc8\"] 1', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:21:30');
INSERT INTO `sys_oper_log` VALUES (34, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/5166c9a5fc894614a8e6e64d5703de42.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:38:15');
INSERT INTO `sys_oper_log` VALUES (35, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Vue MarkDown插件\",\"introduce\":\"markdown插件\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/5166c9a5fc894614a8e6e64d5703de42.jpg\",\"sort\":0,\"content\":\"\\n\\n### 前言\\n\\n> 闲来无事，想自己开发一个简单的Vue懒加载插件，能力的提升我觉得是可以通过编写插件实现，研究了一下官网的[Vue插件](https://cn.vuejs.org/v2/guide/plugins.html)编写。马上自己独立开始编写懒加载插件。\\n\\n### 一、写在前面\\n\\n在这阐述一下本人的观念，我一直推崇一些高度定制化的插件，一些小Demo，是需要自己写的，不能崇尚“拿来主义”。有些插件网上都有，但是你用了会发现谁都会用，而且有时候对于自己的需求又不够贴合。\\n\\n等到自己需要写一个插件的时候，却无从下手。但是如果你练习了插件编写后，收获往小了讲，就是可以自己写一个小插件，往大了讲，你能力到达一定地步你是可以写一个框架的。\\n\\n所以，练习写插件和小框架能力非常重要！也就基本注定了你的代码生涯。\\n\\n### 二、前期准备\\n\\n#### 2.1 选择合适的打包工具\\n\\n合适的打包工具可以达到事半功倍的效果。一开始我的首选有两个，一个是webpack，一个是rollup。下面简单介绍一下我为什么选择了rollup。\\n\\n众所周知，webpack是一个几乎囊括了所有**静态资源**，可以**动态按需加载**的一个包工具。而rollup也是一个模块打包器，可以把一个大块复杂的代码拆分成各个小模块。\\n\\n深思熟虑后，我觉得webpack也可以打包，但是首先，有点“杀鸡焉用牛刀”的感觉。而我的这个懒加载插件则需要提供给别人使用，同时又要保证整个插件的“轻量性”（打包完大概6KB，而webpack则比较大），不喜欢像webpack那样在这插件上臃肿的表现。\\n\\n对于非应用级的程序，我比较倾向于使用rollup.js。\\n\\n#### 2.2 确认项目结构\\n\\n```json\\n|——package.json\\n|——config\\n|\\t|——rollup.config.js\\n|——dist\\n|\\t|——bundle.js\\n|——src\\n|\\t|——index.js\\n|\\t|——directive.js\\n|\\t|——mixin.js\\n|\\t|——utils\\n|\\t|\\t|——utils.js\\n|\\t|——cores\\n|\\t\\t|——lazyload.js\\n|\\t\\t|——imagebox.js\\n```\\n\\nconfig文件夹下放置rollup的配置文件。src为源文件夹，cores下面的文件夹为主要的模块，utils为工具类，主要是一些可以通用的模块方法。大概的结构就是这样。\\n\\n#### 2.3 编写思路\\n\\n懒加载的实现过程，我们这里先精简化。具体思路如下：\\n\\n=》**把所有用指令绑定的元素添加数组初始化** \\n\\n=》**监听滚动条滚动**\\t\\n\\n=》**判断元素是否进入可视范围** \\n\\n=》**如果进入可视范围，进行src预加载（存入缓存数组）** \\n\\n=》**对于pending的图片，进行正在加载赋值，对于finsh完的图片，加载预加载src里面的值，对于error的图片，进行错误图片src赋值**\\n\\n### 三、主要代码的编写\\n\\n#### 3.1 确认入口文件\\n\\n[Vue](https://cn.vuejs.org/v2/guide/plugins.html)插件里面介绍是这样的\\n\\n```javascript\\nMyPlugin.install = function (Vue, options) {\\n  // 1. 添加全局方法或属性\\n  Vue.myGlobalMethod = function () {\\n    // 逻辑...\\n  }\\n\\n  // 2. 添加全局资源\\n  Vue.directive(\'my-directive\', {\\n    bind (el, binding, vnode, oldVnode) {\\n      // 逻辑...\\n    }\\n    ...\\n  })\\n\\n  // 3. 注入组件\\n  Vue.mixin({\\n    created: function () {\\n      // 逻辑...\\n    }\\n    ...\\n  })\\n\\n  // 4. 添加实', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:38:26');
INSERT INTO `sys_oper_log` VALUES (36, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateSummaryById()', 'PUT', 1, 'admin', NULL, '/article/inform/updateSummaryById/7a32054bfad35678eac9d315996bd48d/09d7c62e8f9d0348782c6381e2c0b6c0/0', '127.0.0.1', '内网IP', '7a32054bfad35678eac9d315996bd48d 09d7c62e8f9d0348782c6381e2c0b6c0 0', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:40:26');
INSERT INTO `sys_oper_log` VALUES (37, '网站信息', 2, 'com.jzj.vblog.web.controller.admin.SysWebInformationController.edit()', 'PUT', 1, 'admin', NULL, '/sys/web/information/', '127.0.0.1', '内网IP', '{\"qq\":\"946232976\",\"github\":\"https://github.com/Jzjzzzz\",\"webDetails\":\"<p>长路漫漫，吾将上下而求索。</p>\",\"wechat\":\"fr946232976\",\"homeBanner\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/08/09/a108c42fa21a43a4940c3e08cfd33c4f.jpg\",\"updateTime\":1664160979524,\"params\":{},\"webAvatar\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/09/16/de051c412f2f46ba92de7817496cb605.jpg\",\"gitee\":\"https://gitee.com/jzjzz\",\"wechatImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/09/08/f2330c187a6040ed8a74df5aae1cb763.jpg\",\"commentImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/09/19/1b0d32a2d72e4ed58b7cc6ede72621b0.png\",\"articleBanner\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/08/10/9d26abe18ec84eadbaa8b9f180fefee6.jpg\",\"createTime\":1659010573000,\"webName\":\"漫漫前路\",\"id\":1,\"email\":\"946232976@qq.com\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:56:19');
INSERT INTO `sys_oper_log` VALUES (38, '网站信息', 9, 'com.jzj.vblog.web.controller.admin.SysWebInformationController.refreshCache()', 'DELETE', 1, 'admin', NULL, '/sys/web/information/refreshCache', '127.0.0.1', '内网IP', '{}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 10:56:24');
INSERT INTO `sys_oper_log` VALUES (39, '定时任务', 2, 'com.jzj.vblog.web.controller.admin.SysJobController.cronJob()', 'PUT', 1, 'admin', NULL, '/system/job/update', '127.0.0.1', '内网IP', '{\"cronExpression\":\"0 0/2 * * * ?\",\"jobGroupName\":\"Article\",\"jobClassName\":\"com.jzj.vblog.job.ArticleCountJob\"}', '{\"code\":20000,\"data\":\"修改成功\",\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 11:07:20');
INSERT INTO `sys_oper_log` VALUES (40, '前台评论', 1, 'com.jzj.vblog.web.controller.front.CommentController.saveMessage()', 'POST', 1, 'admin', NULL, '/front/comment/insert/message', '127.0.0.1', '内网IP', '{\"city\":\"未知地址\",\"nickName\":\"刘德华\",\"ip\":\"127.0.0.1\",\"parentStatus\":\"1\",\"updateTime\":1664162113808,\"avatar\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/09/19/1b0d32a2d72e4ed58b7cc6ede72621b0.png\",\"params\":{},\"content\":\"路过\",\"createTime\":1664162113808,\"commentType\":\"0\",\"auditStatus\":\"0\",\"id\":\"b1ceb696b5926871ceae7701d87a89e4\",\"email\":\"946232976@qq.com\",\"status\":\"0\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 11:15:13');
INSERT INTO `sys_oper_log` VALUES (41, '评论管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleCommentController.audit()', 'PUT', 1, 'admin', NULL, '/article/comment/b1ceb696b5926871ceae7701d87a89e4/1', '127.0.0.1', '内网IP', '[\"b1ceb696b5926871ceae7701d87a89e4\"] 1', NULL, 1, '', '2022-09-26 11:15:24');
INSERT INTO `sys_oper_log` VALUES (42, '评论管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleCommentController.audit()', 'PUT', 1, 'admin', NULL, '/article/comment/b1ceb696b5926871ceae7701d87a89e4/1', '127.0.0.1', '内网IP', '[\"b1ceb696b5926871ceae7701d87a89e4\"] 1', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 11:19:06');
INSERT INTO `sys_oper_log` VALUES (43, '评论管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleCommentController.reply()', 'POST', 1, 'admin', NULL, '/article/comment', '127.0.0.1', '内网IP', '{\"nickName\":\"刘德华\",\"id\":\"b1ceb696b5926871ceae7701d87a89e4\",\"reply\":\"回复你了\",\"content\":\"路过\",\"email\":\"946232976@qq.com\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 11:19:32');
INSERT INTO `sys_oper_log` VALUES (44, '评论管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleCommentController.reply()', 'POST', 1, 'admin', NULL, '/article/comment', '127.0.0.1', '内网IP', '{\"articleName\":\"阿里云OSS（一）\",\"nickName\":\"刘德华\",\"id\":\"012f43a6d3a8c9cd9aec4c0eab24dcc8\",\"reply\":\"回复你了\",\"content\":\"写得真好\",\"email\":\"946232976@qq.com\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 11:19:38');
INSERT INTO `sys_oper_log` VALUES (45, '备忘录', 3, 'com.jzj.vblog.web.controller.admin.SysTodoController.remove()', 'DELETE', 1, 'admin', NULL, '/sys/todo/36b25f306cd7ce2bd1f69e5a813d494b', '127.0.0.1', '内网IP', '{id=36b25f306cd7ce2bd1f69e5a813d494b}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:19:39');
INSERT INTO `sys_oper_log` VALUES (46, '备忘录', 1, 'com.jzj.vblog.web.controller.admin.SysTodoController.add()', 'POST', 1, 'admin', NULL, '/sys/todo/%E7%AD%89%E4%B8%8B%E4%B9%B0%E6%89%8B%E6%9C%BA', '127.0.0.1', '内网IP', '等下买手机', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:19:55');
INSERT INTO `sys_oper_log` VALUES (47, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"updateTime\":1664173200656,\"text\":\"等下买手机\",\"params\":{},\"done\":true}', '{\"code\":20001,\"msg\":\"操作失败\",\"success\":false}', 0, NULL, '2022-09-26 14:20:00');
INSERT INTO `sys_oper_log` VALUES (48, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"updateTime\":1664173201172,\"text\":\"等下买手机\",\"params\":{},\"done\":true}', '{\"code\":20001,\"msg\":\"操作失败\",\"success\":false}', 0, NULL, '2022-09-26 14:20:01');
INSERT INTO `sys_oper_log` VALUES (49, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"updateTime\":1664173202468,\"text\":\"等下买手机\",\"params\":{},\"done\":true}', '{\"code\":20001,\"msg\":\"操作失败\",\"success\":false}', 0, NULL, '2022-09-26 14:20:02');
INSERT INTO `sys_oper_log` VALUES (50, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"updateTime\":1664173203068,\"text\":\"等下买手机\",\"params\":{},\"done\":true}', '{\"code\":20001,\"msg\":\"操作失败\",\"success\":false}', 0, NULL, '2022-09-26 14:20:03');
INSERT INTO `sys_oper_log` VALUES (51, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1664173206431,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:06');
INSERT INTO `sys_oper_log` VALUES (52, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1664173207173,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:07');
INSERT INTO `sys_oper_log` VALUES (53, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470378000,\"updateTime\":1664173207844,\"id\":\"51f1a28c08365c0112c07addfcd5114e\",\"text\":\"等下吃饭\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:07');
INSERT INTO `sys_oper_log` VALUES (54, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173196000,\"updateTime\":1664173208221,\"id\":\"355b1d478127fec7552a08d50d906608\",\"text\":\"等下买手机\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:08');
INSERT INTO `sys_oper_log` VALUES (55, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470378000,\"updateTime\":1664173208700,\"id\":\"51f1a28c08365c0112c07addfcd5114e\",\"text\":\"等下吃饭\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:08');
INSERT INTO `sys_oper_log` VALUES (56, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173196000,\"updateTime\":1664173209036,\"id\":\"355b1d478127fec7552a08d50d906608\",\"text\":\"等下买手机\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:09');
INSERT INTO `sys_oper_log` VALUES (57, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173196000,\"updateTime\":1664173211749,\"id\":\"355b1d478127fec7552a08d50d906608\",\"text\":\"等下买手机\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:11');
INSERT INTO `sys_oper_log` VALUES (58, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173196000,\"updateTime\":1664173212309,\"id\":\"355b1d478127fec7552a08d50d906608\",\"text\":\"等下买手机\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:12');
INSERT INTO `sys_oper_log` VALUES (59, '备忘录', 1, 'com.jzj.vblog.web.controller.admin.SysTodoController.add()', 'POST', 1, 'admin', NULL, '/sys/todo/%E5%90%83%E9%A5%AD', '127.0.0.1', '内网IP', '吃饭', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:18');
INSERT INTO `sys_oper_log` VALUES (60, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"updateTime\":1664173219324,\"text\":\"吃饭\",\"params\":{},\"done\":true}', '{\"code\":20001,\"msg\":\"操作失败\",\"success\":false}', 0, NULL, '2022-09-26 14:20:19');
INSERT INTO `sys_oper_log` VALUES (61, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"updateTime\":1664173220588,\"text\":\"吃饭\",\"params\":{},\"done\":true}', '{\"code\":20001,\"msg\":\"操作失败\",\"success\":false}', 0, NULL, '2022-09-26 14:20:20');
INSERT INTO `sys_oper_log` VALUES (62, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1664173222421,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:22');
INSERT INTO `sys_oper_log` VALUES (63, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1664173223148,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:23');
INSERT INTO `sys_oper_log` VALUES (64, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470423000,\"updateTime\":1664173223700,\"id\":\"5968d94f9d2d78f383c9cb8ee0595756\",\"text\":\"好好好学习天天向上\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:23');
INSERT INTO `sys_oper_log` VALUES (65, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470423000,\"updateTime\":1664173224083,\"id\":\"5968d94f9d2d78f383c9cb8ee0595756\",\"text\":\"好好好学习天天向上\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:24');
INSERT INTO `sys_oper_log` VALUES (66, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470378000,\"updateTime\":1664173224428,\"id\":\"51f1a28c08365c0112c07addfcd5114e\",\"text\":\"等下吃饭\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:24');
INSERT INTO `sys_oper_log` VALUES (67, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470378000,\"updateTime\":1664173224796,\"id\":\"51f1a28c08365c0112c07addfcd5114e\",\"text\":\"等下吃饭\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:24');
INSERT INTO `sys_oper_log` VALUES (68, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173196000,\"updateTime\":1664173225132,\"id\":\"355b1d478127fec7552a08d50d906608\",\"text\":\"等下买手机\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:25');
INSERT INTO `sys_oper_log` VALUES (69, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173196000,\"updateTime\":1664173225669,\"id\":\"355b1d478127fec7552a08d50d906608\",\"text\":\"等下买手机\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:20:25');
INSERT INTO `sys_oper_log` VALUES (70, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"updateTime\":1664173226404,\"text\":\"吃饭\",\"params\":{},\"done\":true}', '{\"code\":20001,\"msg\":\"操作失败\",\"success\":false}', 0, NULL, '2022-09-26 14:20:26');
INSERT INTO `sys_oper_log` VALUES (71, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"updateTime\":1664173227228,\"text\":\"吃饭\",\"params\":{},\"done\":true}', '{\"code\":20001,\"msg\":\"操作失败\",\"success\":false}', 0, NULL, '2022-09-26 14:20:27');
INSERT INTO `sys_oper_log` VALUES (72, '备忘录', 1, 'com.jzj.vblog.web.controller.admin.SysTodoController.add()', 'POST', 1, 'admin', NULL, '/sys/todo/1', '127.0.0.1', '内网IP', '1', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:27');
INSERT INTO `sys_oper_log` VALUES (73, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173348000,\"updateTime\":1664173348708,\"id\":\"bb8b2da902a9b5a6f7b7f7ff1549efbb\",\"text\":\"1\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:28');
INSERT INTO `sys_oper_log` VALUES (74, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173348000,\"updateTime\":1664173349452,\"id\":\"bb8b2da902a9b5a6f7b7f7ff1549efbb\",\"text\":\"1\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:29');
INSERT INTO `sys_oper_log` VALUES (75, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173348000,\"updateTime\":1664173350028,\"id\":\"bb8b2da902a9b5a6f7b7f7ff1549efbb\",\"text\":\"1\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:30');
INSERT INTO `sys_oper_log` VALUES (76, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173348000,\"updateTime\":1664173350364,\"id\":\"bb8b2da902a9b5a6f7b7f7ff1549efbb\",\"text\":\"1\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:30');
INSERT INTO `sys_oper_log` VALUES (77, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173348000,\"updateTime\":1664173350716,\"id\":\"bb8b2da902a9b5a6f7b7f7ff1549efbb\",\"text\":\"1\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:30');
INSERT INTO `sys_oper_log` VALUES (78, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173348000,\"updateTime\":1664173350964,\"id\":\"bb8b2da902a9b5a6f7b7f7ff1549efbb\",\"text\":\"1\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:30');
INSERT INTO `sys_oper_log` VALUES (79, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173218000,\"updateTime\":1664173352100,\"id\":\"6be13dbb4f0ccb96310f3d7cebe4ff7c\",\"text\":\"吃饭\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:32');
INSERT INTO `sys_oper_log` VALUES (80, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173218000,\"updateTime\":1664173352428,\"id\":\"6be13dbb4f0ccb96310f3d7cebe4ff7c\",\"text\":\"吃饭\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:32');
INSERT INTO `sys_oper_log` VALUES (81, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173348000,\"updateTime\":1664173353044,\"id\":\"bb8b2da902a9b5a6f7b7f7ff1549efbb\",\"text\":\"1\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:33');
INSERT INTO `sys_oper_log` VALUES (82, '备忘录', 3, 'com.jzj.vblog.web.controller.admin.SysTodoController.remove()', 'DELETE', 1, 'admin', NULL, '/sys/todo/bb8b2da902a9b5a6f7b7f7ff1549efbb', '127.0.0.1', '内网IP', '{id=bb8b2da902a9b5a6f7b7f7ff1549efbb}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:33');
INSERT INTO `sys_oper_log` VALUES (83, '备忘录', 3, 'com.jzj.vblog.web.controller.admin.SysTodoController.remove()', 'DELETE', 1, 'admin', NULL, '/sys/todo/6be13dbb4f0ccb96310f3d7cebe4ff7c', '127.0.0.1', '内网IP', '{id=6be13dbb4f0ccb96310f3d7cebe4ff7c}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:36');
INSERT INTO `sys_oper_log` VALUES (84, '备忘录', 3, 'com.jzj.vblog.web.controller.admin.SysTodoController.remove()', 'DELETE', 1, 'admin', NULL, '/sys/todo/51f1a28c08365c0112c07addfcd5114e', '127.0.0.1', '内网IP', '{id=51f1a28c08365c0112c07addfcd5114e}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:37');
INSERT INTO `sys_oper_log` VALUES (85, '备忘录', 3, 'com.jzj.vblog.web.controller.admin.SysTodoController.remove()', 'DELETE', 1, 'admin', NULL, '/sys/todo/355b1d478127fec7552a08d50d906608', '127.0.0.1', '内网IP', '{id=355b1d478127fec7552a08d50d906608}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:38');
INSERT INTO `sys_oper_log` VALUES (86, '备忘录', 1, 'com.jzj.vblog.web.controller.admin.SysTodoController.add()', 'POST', 1, 'admin', NULL, '/sys/todo/%E4%B9%B0%E6%89%8B%E6%9C%BA', '127.0.0.1', '内网IP', '买手机', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:48');
INSERT INTO `sys_oper_log` VALUES (87, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173369000,\"updateTime\":1664173369868,\"id\":\"d03d1664f7f5ac853cb5b3a37770bbb6\",\"text\":\"买手机\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:22:49');
INSERT INTO `sys_oper_log` VALUES (88, '文章管理', 3, 'com.jzj.vblog.web.controller.admin.ArticleInformController.deleteBthById()', 'DELETE', 1, 'admin', NULL, '/article/inform/7a32054bfad35678eac9d315996bd48d', '127.0.0.1', '内网IP', '{ids=7a32054bfad35678eac9d315996bd48d}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:41:37');
INSERT INTO `sys_oper_log` VALUES (89, '评论管理', 3, 'com.jzj.vblog.web.controller.admin.ArticleCommentController.remove()', 'DELETE', 1, 'admin', NULL, '/article/comment/b1ceb696b5926871ceae7701d87a89e4,012f43a6d3a8c9cd9aec4c0eab24dcc8', '127.0.0.1', '内网IP', '{ids=b1ceb696b5926871ceae7701d87a89e4,012f43a6d3a8c9cd9aec4c0eab24dcc8}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:45:18');
INSERT INTO `sys_oper_log` VALUES (90, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/ef56bf3ce3fc4f77a2435d7d33a408c5.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:46:00');
INSERT INTO `sys_oper_log` VALUES (91, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（三）\",\"introduce\":\"阿里云OSS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/ef56bf3ce3fc4f77a2435d7d33a408c5.jpg\",\"sort\":0,\"content\":\"# 一、新建云存储微服务\\n## 1、创建模块\\nservice-oss\\n## 2、配置pom.xml\\n```java\\n<dependencies>\\n    <dependency>\\n        <groupId>com.atguigu</groupId>\\n        <artifactId>service-base</artifactId>\\n        <version>0.0.1-SNAPSHOT</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-web</artifactId>\\n    </dependency>\\n    \\n    <!--lombok用来简化实体类：需要安装lombok插件-->\\n    <dependency>\\n        <groupId>org.projectlombok</groupId>\\n        <artifactId>lombok</artifactId>\\n    </dependency>\\n    <!--aliyunOSS-->\\n    <dependency>\\n        <groupId>com.aliyun.oss</groupId>\\n        <artifactId>aliyun-sdk-oss</artifactId>\\n        <version>3.1.0</version>\\n    </dependency>\\n    <!-- 日期工具栏依赖 -->\\n    <dependency>\\n        <groupId>joda-time</groupId>\\n        <artifactId>joda-time</artifactId>\\n        <version>2.10.1</version>\\n    </dependency>\\n    <!--让自定义的配置在application.yaml进行自动提示-->\\n    <dependency>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-configuration-processor</artifactId>\\n        <optional>true</optional>\\n    </dependency>\\n</dependencies>\\n```\\n## 3、配置application.yml\\n```java\\nserver:\\n  port: 8130 # 服务端口\\nspring:\\n  profiles:\\n    active: dev # 环境设置\\n  application:\\n    name: service-oss # 服务名\\naliyun:\\n  oss:\\n    endpoint: 你的endponit\\n    keyId: 你的阿里云keyid\\n    keySecret: 你的阿里云keysecret\\n    bucketName: srb-file\\n```\\n## 4、logback-spring.xml\\n修改日志路径为 srb_log/oss\\n## 5、创建启动类\\n创建ServiceOssApplication.java\\n```java\\npackage com.atguigu.srb.oss;\\n@SpringBootApplication\\n@ComponentScan({\\\"com.atguigu.srb\\\", \\\"com.atguigu.common\\\"})\\npublic class ServiceOssApplication {\\n    public static void main(String[] args) {\\n        SpringApplication.run(ServiceOssApplicatio', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:47:31');
INSERT INTO `sys_oper_log` VALUES (92, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/0ea5e436796e46c897c21ae1055a05c8.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:48:55');
INSERT INTO `sys_oper_log` VALUES (93, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"1\",\"introduce\":\"dsadsa\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/0ea5e436796e46c897c21ae1055a05c8.jpg\",\"sort\":0,\"content\":\"# 师大第三\\n\\n\\ndfdsf\\n\\nd\\nd\\n\\n\\n\\ndd\\ns\\ns\\ns\\ns\\ns\\nss\\ns\\ns\\n\\ns\\ns\\ns\\ns\\n\\n\\n\\n\\n\\n\\n\\n\\nss\\ns\\ns\\ns\\ns\\ns\\ns\\ns\\ns\\ns\\ns\\n\\ns\\nss\\ns\\ns\\ns\\ns\\ns\\ns\\n\\ns\\ns\\n\\n## 二级标题\\n\\n## 二级标题\\n\\n## 二级标题\\n### 三级标题\\n\\n# 一级标题\",\"commentStatus\":\"0\",\"htmlContent\":\"<h1><a id=\\\"_0\\\"></a>师大第三</h1>\\n<p>dfdsf</p>\\n<p>d<br />\\nd</p>\\n<p>dd<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\nss<br />\\ns<br />\\ns</p>\\n<p>s<br />\\ns<br />\\ns<br />\\ns</p>\\n<p>ss<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns</p>\\n<p>s<br />\\nss<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns<br />\\ns</p>\\n<p>s<br />\\ns</p>\\n<h2><a id=\\\"_56\\\"></a>二级标题</h2>\\n<h2><a id=\\\"_58\\\"></a>二级标题</h2>\\n<h2><a id=\\\"_60\\\"></a>二级标题</h2>\\n<h3><a id=\\\"_61\\\"></a>三级标题</h3>\\n<h1><a id=\\\"_63\\\"></a>一级标题</h1>\\n\",\"articleTag\":\"0\",\"aggregateId\":\"09d7c62e8f9d0348782c6381e2c0b6c0\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"0\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:50:10');
INSERT INTO `sys_oper_log` VALUES (94, '文章管理', 3, 'com.jzj.vblog.web.controller.admin.ArticleInformController.deleteBthById()', 'DELETE', 1, 'admin', NULL, '/article/inform/bde89918a8adad4310d112f995bad7ab', '127.0.0.1', '内网IP', '{ids=bde89918a8adad4310d112f995bad7ab}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:50:36');
INSERT INTO `sys_oper_log` VALUES (95, '字典类型', 1, 'com.jzj.vblog.web.controller.admin.SysDictDataController.add()', 'POST', 1, 'admin', NULL, '/system/dict/data', '127.0.0.1', '内网IP', '{\"dictValue\":\"9\",\"listClass\":\"primary\",\"dictSort\":0,\"remark\":\"短信\",\"updateTime\":1664175092158,\"params\":{},\"dictType\":\"sys_article_tag\",\"dictLabel\":\"短信\",\"createBy\":\"admin\",\"createTime\":1664175092158,\"status\":\"0\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:51:32');
INSERT INTO `sys_oper_log` VALUES (96, '字典类型', 9, 'com.jzj.vblog.web.controller.admin.SysDictTypeController.refreshCache()', 'DELETE', 1, 'admin', NULL, '/system/dict/type/refreshCache', '127.0.0.1', '内网IP', '{}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:51:36');
INSERT INTO `sys_oper_log` VALUES (97, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（三）\",\"introduce\":\"阿里云OSS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/ef56bf3ce3fc4f77a2435d7d33a408c5.jpg\",\"sort\":0,\"content\":\"# 一、新建云存储微服务\\n## 1、创建模块\\nservice-oss\\n## 2、配置pom.xml\\n```java\\n<dependencies>\\n    <dependency>\\n        <groupId>com.atguigu</groupId>\\n        <artifactId>service-base</artifactId>\\n        <version>0.0.1-SNAPSHOT</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-web</artifactId>\\n    </dependency>\\n    \\n    <!--lombok用来简化实体类：需要安装lombok插件-->\\n    <dependency>\\n        <groupId>org.projectlombok</groupId>\\n        <artifactId>lombok</artifactId>\\n    </dependency>\\n    <!--aliyunOSS-->\\n    <dependency>\\n        <groupId>com.aliyun.oss</groupId>\\n        <artifactId>aliyun-sdk-oss</artifactId>\\n        <version>3.1.0</version>\\n    </dependency>\\n    <!-- 日期工具栏依赖 -->\\n    <dependency>\\n        <groupId>joda-time</groupId>\\n        <artifactId>joda-time</artifactId>\\n        <version>2.10.1</version>\\n    </dependency>\\n    <!--让自定义的配置在application.yaml进行自动提示-->\\n    <dependency>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-configuration-processor</artifactId>\\n        <optional>true</optional>\\n    </dependency>\\n</dependencies>\\n```\\n## 3、配置application.yml\\n```java\\nserver:\\n  port: 8130 # 服务端口\\nspring:\\n  profiles:\\n    active: dev # 环境设置\\n  application:\\n    name: service-oss # 服务名\\naliyun:\\n  oss:\\n    endpoint: 你的endponit\\n    keyId: 你的阿里云keyid\\n    keySecret: 你的阿里云keysecret\\n    bucketName: srb-file\\n```\\n## 4、logback-spring.xml\\n修改日志路径为 srb_log/oss\\n## 5、创建启动类\\n创建ServiceOssApplication.java\\n```java\\npackage com.atguigu.srb.oss;\\n@SpringBootApplication\\n@ComponentScan({\\\"com.atguigu.srb\\\", \\\"com.atguigu.common\\\"})\\npublic class ServiceOssApplication {\\n    public static void main(String[] args) {\\n        SpringApplication.run(ServiceOssApplicatio', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:51:45');
INSERT INTO `sys_oper_log` VALUES (98, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（一）\",\"introduce\":\"阿里云OSS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/e5a630491c4c4eabb9b0f6cd408afcbb.jpg\",\"sort\":0,\"content\":\"# 一、开通“对象存储OSS”服务\\n为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。 \\n## 1、开通“对象存储OSS”服务\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png)\\n## 2、进入管理控制台\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/99148798ab0a4d16823b2611006e5c5f.png)\\n# 二、控制台使用\\n## 1、创建Bucket\\n命名：vblog-file\\n读写权限：公共读\\n## 2、上传默认头像\\n创建文件夹avatar，上传默认的用户头像\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/26b3d28acc464bbcb51dbbddc4efb589.png)\\n三、使用RAM子用户\\n## 三、使用RAM子用户\\n## 1、进入子用户管理页面\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/45410834506a48a3818df160ac3fb570.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/4e989444c6114e4bb3a173ac5de48eb7.png)\\n## 2、添加用户\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/5ef618473c1f46bd84bfcc19c54af423.png)\\n## 3、获取子用户key\\nAccessKeyId, AccessKeySecret\\n\\n## 4、设置用户权限\\nAliyunOSSFullAccess\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a5eb04ca6ee44d92b974a0811dd66558.png)\\n\",\"commentStatus\":\"0\",\"htmlContent\":\"<h1><a id=\\\"OSS_0\\\"></a>一、开通“对象存储OSS”服务</h1>\\n<p>为了解决海量数据存储与弹性扩容，项目中我们采用云存储的解决方案- 阿里云OSS。</p>\\n<h2><a id=\\\"1OSS_2\\\"></a>1、开通“对象存储OSS”服务</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/db19f0efd8cb436eafff8dd2ab38d44e.png\\\" alt=\\\"image.png\\\" /><br />\\n<img src=\\\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/67a7045566eb41a0a6e3d467f498bbaf.png\\\" alt=\\\"image.png\\\" /></p>\\n<h2><a id=\\\"2_5\\\"></a>2、进入管理控制台</h2>\\n<p><img src=\\\"https://vue-vblog.oss-cn-shenzhe', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:54:22');
INSERT INTO `sys_oper_log` VALUES (99, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/3e2924038d9f4b3cbace962ab5d8f938.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:55:08');
INSERT INTO `sys_oper_log` VALUES (100, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a3b11520c7ed4b298d21c4dd5979d19c.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:55:49');
INSERT INTO `sys_oper_log` VALUES (101, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/7feac028c2944636b246bc0a5eaf114a.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:56:12');
INSERT INTO `sys_oper_log` VALUES (102, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d8fbecd8be214a94bab3c53c73b47d30.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:56:37');
INSERT INTO `sys_oper_log` VALUES (103, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/98f0e0e797d940ea814f1516061ed5eb.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:56:44');
INSERT INTO `sys_oper_log` VALUES (104, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/593d6ff8b053478da6e65d2c71066709.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:57:07');
INSERT INTO `sys_oper_log` VALUES (105, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/579b19fc27d1412197f000642158315d.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:57:22');
INSERT INTO `sys_oper_log` VALUES (106, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"腾讯云短信服务\",\"introduce\":\"腾讯云短信服务\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/3e2924038d9f4b3cbace962ab5d8f938.jpg\",\"sort\":0,\"content\":\"### 1.在腾讯云短信服务上新建短信签名\\n[https://console.cloud.tencent.com/smsv2/guide](https://console.cloud.tencent.com/smsv2/guide)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/a3b11520c7ed4b298d21c4dd5979d19c.png)\\n### 2.新建短信模板\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/7feac028c2944636b246bc0a5eaf114a.png)\\n### 3.获取腾讯云的API秘钥\\n[https://console.cloud.tencent.com/cam/capi](https://console.cloud.tencent.com/cam/capi)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/d8fbecd8be214a94bab3c53c73b47d30.png)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/98f0e0e797d940ea814f1516061ed5eb.png)\\n### 4.开发指南\\n[https://cloud.tencent.com/document/product/382/38778](https://cloud.tencent.com/document/product/382/38778)\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/26/593d6ff8b053478da6e65d2c71066709.png)\\n可通过改控制台实时调试\\n### 5.新建SMS微服务service-sms\\n\\n- POM\\n```java\\n    <dependencies>\\n\\n        <dependency>\\n            <groupId>com.jzj</groupId>\\n            <artifactId>service-base</artifactId>\\n            <version>${project.version}</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <!--lombok用来简化实体类：需要安装lombok插件-->\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n        </dependency>\\n        <!--腾讯云短信-->\\n        <dependency>\\n            <groupId>com.tencentcloudapi</groupId>\\n            <artifactId>tencentcloud-sdk-java-common</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>com.tencentcloudap', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 14:58:03');
INSERT INTO `sys_oper_log` VALUES (107, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/434f3e2fc8a94f3c9001bd743f9fcf88.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 15:00:46');
INSERT INTO `sys_oper_log` VALUES (108, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里巴巴EasyExcel的使用\",\"introduce\":\"阿里巴巴EasyExcel的使用\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/434f3e2fc8a94f3c9001bd743f9fcf88.jpg\",\"sort\":0,\"content\":\"## 1、官方网站\\n[https://github.com/alibaba/easyexcel](https://github.com/alibaba/easyexcel)\\n\\n[快速开始：https://www.yuque.com/easyexcel/doc/easyexcel](https://www.yuque.com/easyexcel/doc/easyexcel)\",\"commentStatus\":\"0\",\"htmlContent\":\"<h2><a id=\\\"1_0\\\"></a>1、官方网站</h2>\\n<p><a href=\\\"https://github.com/alibaba/easyexcel\\\" target=\\\"_blank\\\">https://github.com/alibaba/easyexcel</a></p>\\n<p><a href=\\\"https://www.yuque.com/easyexcel/doc/easyexcel\\\" target=\\\"_blank\\\">快速开始：https://www.yuque.com/easyexcel/doc/easyexcel</a></p>\\n\",\"articleTag\":\"0\",\"aggregateId\":\"\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"0\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 15:03:35');
INSERT INTO `sys_oper_log` VALUES (109, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里巴巴EasyExcel的使用\",\"introduce\":\"阿里巴巴EasyExcel的使用\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/434f3e2fc8a94f3c9001bd743f9fcf88.jpg\",\"sort\":0,\"content\":\"### 1、官方网站\\n[https://github.com/alibaba/easyexcel](https://github.com/alibaba/easyexcel)\\n\\n[快速开始：https://www.yuque.com/easyexcel/doc/easyexcel](https://www.yuque.com/easyexcel/doc/easyexcel)\",\"commentStatus\":\"0\",\"htmlContent\":\"<h3><a id=\\\"1_0\\\"></a>1、官方网站</h3>\\n<p><a href=\\\"https://github.com/alibaba/easyexcel\\\" target=\\\"_blank\\\">https://github.com/alibaba/easyexcel</a></p>\\n<p><a href=\\\"https://www.yuque.com/easyexcel/doc/easyexcel\\\" target=\\\"_blank\\\">快速开始：https://www.yuque.com/easyexcel/doc/easyexcel</a></p>\\n\",\"articleTag\":\"0\",\"aggregateId\":\"\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"0\",\"id\":\"c2317a9079991be3273a65254f263441\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 15:03:57');
INSERT INTO `sys_oper_log` VALUES (110, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里云OSS（三）\",\"introduce\":\"阿里云OSS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/ef56bf3ce3fc4f77a2435d7d33a408c5.jpg\",\"sort\":0,\"content\":\"# 一、新建云存储微服务\\n## 1、创建模块\\nservice-oss\\n## 2、配置pom.xml\\n```java\\n<dependencies>\\n    <dependency>\\n        <groupId>com.atguigu</groupId>\\n        <artifactId>service-base</artifactId>\\n        <version>0.0.1-SNAPSHOT</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-web</artifactId>\\n    </dependency>\\n    \\n    <!--lombok用来简化实体类：需要安装lombok插件-->\\n    <dependency>\\n        <groupId>org.projectlombok</groupId>\\n        <artifactId>lombok</artifactId>\\n    </dependency>\\n    <!--aliyunOSS-->\\n    <dependency>\\n        <groupId>com.aliyun.oss</groupId>\\n        <artifactId>aliyun-sdk-oss</artifactId>\\n        <version>3.1.0</version>\\n    </dependency>\\n    <!-- 日期工具栏依赖 -->\\n    <dependency>\\n        <groupId>joda-time</groupId>\\n        <artifactId>joda-time</artifactId>\\n        <version>2.10.1</version>\\n    </dependency>\\n    <!--让自定义的配置在application.yaml进行自动提示-->\\n    <dependency>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-configuration-processor</artifactId>\\n        <optional>true</optional>\\n    </dependency>\\n</dependencies>\\n```\\n## 3、配置application.yml\\n```java\\nserver:\\n  port: 8130 # 服务端口\\nspring:\\n  profiles:\\n    active: dev # 环境设置\\n  application:\\n    name: service-oss # 服务名\\naliyun:\\n  oss:\\n    endpoint: 你的endponit\\n    keyId: 你的阿里云keyid\\n    keySecret: 你的阿里云keysecret\\n    bucketName: srb-file\\n```\\n## 4、logback-spring.xml\\n修改日志路径为 srb_log/oss\\n## 5、创建启动类\\n创建ServiceOssApplication.java\\n```java\\npackage com.atguigu.srb.oss;\\n@SpringBootApplication\\n@ComponentScan({\\\"com.atguigu.srb\\\", \\\"com.atguigu.common\\\"})\\npublic class ServiceOssApplication {\\n    public static void main(String[] args) {\\n        SpringApplication.run(ServiceOssApplicatio', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-26 15:26:15');
INSERT INTO `sys_oper_log` VALUES (111, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"阿里巴巴EasyExcel的使用\",\"introduce\":\"阿里巴巴EasyExcel的使用\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/26/434f3e2fc8a94f3c9001bd743f9fcf88.jpg\",\"sort\":0,\"content\":\"\\n\\n### 前言\\n\\n> 闲来无事，想自己开发一个简单的Vue懒加载插件，能力的提升我觉得是可以通过编写插件实现，研究了一下官网的[Vue插件](https://cn.vuejs.org/v2/guide/plugins.html)编写。马上自己独立开始编写懒加载插件。\\n\\n### 一、写在前面\\n\\n在这阐述一下本人的观念，我一直推崇一些高度定制化的插件，一些小Demo，是需要自己写的，不能崇尚“拿来主义”。有些插件网上都有，但是你用了会发现谁都会用，而且有时候对于自己的需求又不够贴合。\\n\\n等到自己需要写一个插件的时候，却无从下手。但是如果你练习了插件编写后，收获往小了讲，就是可以自己写一个小插件，往大了讲，你能力到达一定地步你是可以写一个框架的。\\n\\n所以，练习写插件和小框架能力非常重要！也就基本注定了你的代码生涯。\\n\\n### 二、前期准备\\n\\n#### 2.1 选择合适的打包工具\\n\\n合适的打包工具可以达到事半功倍的效果。一开始我的首选有两个，一个是webpack，一个是rollup。下面简单介绍一下我为什么选择了rollup。\\n\\n众所周知，webpack是一个几乎囊括了所有**静态资源**，可以**动态按需加载**的一个包工具。而rollup也是一个模块打包器，可以把一个大块复杂的代码拆分成各个小模块。\\n\\n深思熟虑后，我觉得webpack也可以打包，但是首先，有点“杀鸡焉用牛刀”的感觉。而我的这个懒加载插件则需要提供给别人使用，同时又要保证整个插件的“轻量性”（打包完大概6KB，而webpack则比较大），不喜欢像webpack那样在这插件上臃肿的表现。\\n\\n对于非应用级的程序，我比较倾向于使用rollup.js。\\n\\n#### 2.2 确认项目结构\\n\\n```json\\n|——package.json\\n|——config\\n|\\t|——rollup.config.js\\n|——dist\\n|\\t|——bundle.js\\n|——src\\n|\\t|——index.js\\n|\\t|——directive.js\\n|\\t|——mixin.js\\n|\\t|——utils\\n|\\t|\\t|——utils.js\\n|\\t|——cores\\n|\\t\\t|——lazyload.js\\n|\\t\\t|——imagebox.js\\n```\\n\\nconfig文件夹下放置rollup的配置文件。src为源文件夹，cores下面的文件夹为主要的模块，utils为工具类，主要是一些可以通用的模块方法。大概的结构就是这样。\\n\\n#### 2.3 编写思路\\n\\n懒加载的实现过程，我们这里先精简化。具体思路如下：\\n\\n=》**把所有用指令绑定的元素添加数组初始化** \\n\\n=》**监听滚动条滚动**\\t\\n\\n=》**判断元素是否进入可视范围** \\n\\n=》**如果进入可视范围，进行src预加载（存入缓存数组）** \\n\\n=》**对于pending的图片，进行正在加载赋值，对于finsh完的图片，加载预加载src里面的值，对于error的图片，进行错误图片src赋值**\\n\\n### 三、主要代码的编写\\n\\n#### 3.1 确认入口文件\\n\\n[Vue](https://cn.vuejs.org/v2/guide/plugins.html)插件里面介绍是这样的\\n\\n```javascript\\nMyPlugin.install = function (Vue, options) {\\n  // 1. 添加全局方法或属性\\n  Vue.myGlobalMethod = function () {\\n    // 逻辑...\\n  }\\n\\n  // 2. 添加全局资源\\n  Vue.directive(\'my-directive\', {\\n    bind (el, binding, vnode, oldVnode) {\\n      // 逻辑...\\n    }\\n    ...\\n  })\\n\\n  // 3. 注入组件\\n  Vue.mixin({\\n    created: function () {\\n      // 逻辑...\\n    }\\n    ...\\n  })\\n\\n  /', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-27 14:51:01');
INSERT INTO `sys_oper_log` VALUES (112, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/27/21c5a305f8a649759d3a3eeb36beb4b8.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-27 14:52:24');
INSERT INTO `sys_oper_log` VALUES (113, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"1\",\"introduce\":\"1\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/27/21c5a305f8a649759d3a3eeb36beb4b8.jpg\",\"sort\":0,\"content\":\"### 三级标题\\n1\\n1\\n1\\n1\\n1\\n1\\n\\n1\\n1\\n1\\n1\\n1\\n1\\n\\n1\\n1\\n1\\n\\n1\\n### 三级标题\\n\\n#### 四级标题\\n\\n#### 四级标题\\n\\n##### 五级标题\\n\\n###### 六级标题\",\"commentStatus\":\"0\",\"htmlContent\":\"<h3><a id=\\\"_0\\\"></a>三级标题</h3>\\n<p>1<br />\\n1<br />\\n1<br />\\n1<br />\\n1<br />\\n1</p>\\n<p>1<br />\\n1<br />\\n1<br />\\n1<br />\\n1<br />\\n1</p>\\n<p>1<br />\\n1<br />\\n1</p>\\n<p>1</p>\\n<h3><a id=\\\"_20\\\"></a>三级标题</h3>\\n<h4><a id=\\\"_22\\\"></a>四级标题</h4>\\n<h4><a id=\\\"_24\\\"></a>四级标题</h4>\\n<h5><a id=\\\"_26\\\"></a>五级标题</h5>\\n<h6><a id=\\\"_28\\\"></a>六级标题</h6>\\n\",\"articleTag\":\"0,1\",\"aggregateId\":\"\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"0\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-27 14:53:16');
INSERT INTO `sys_oper_log` VALUES (114, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/29/6faa916742be4eb09c15a1fbb36ff4a4.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-29 09:35:41');
INSERT INTO `sys_oper_log` VALUES (115, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"JUC-CAS\",\"introduce\":\"尚硅谷JUC系列课程CAS\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/29/6faa916742be4eb09c15a1fbb36ff4a4.jpg\",\"sort\":0,\"content\":\"\",\"commentStatus\":\"0\",\"htmlContent\":\"\",\"articleTag\":\"6,0\",\"aggregateId\":\"\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"0\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-29 09:36:02');
INSERT INTO `sys_oper_log` VALUES (116, '文章管理', 3, 'com.jzj.vblog.web.controller.admin.ArticleInformController.deleteBthById()', 'DELETE', 1, 'admin', NULL, '/article/inform/8849fc446678a01ba02d501832ee5f23,b26ac9cb46447b07b72f25ab56e95761', '127.0.0.1', '内网IP', '{ids=8849fc446678a01ba02d501832ee5f23,b26ac9cb46447b07b72f25ab56e95761}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:44:22');
INSERT INTO `sys_oper_log` VALUES (117, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/dfae8c0b0a2b4577aa268401bf0c60e4.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:04');
INSERT INTO `sys_oper_log` VALUES (118, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO\",\"introduce\":\"Java 网络编程系列之 NIO\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/dfae8c0b0a2b4577aa268401bf0c60e4.jpg\",\"sort\":0,\"content\":\"\",\"commentStatus\":\"0\",\"htmlContent\":\"\",\"articleTag\":\"0\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"0\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:14');
INSERT INTO `sys_oper_log` VALUES (119, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'gallery', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/6d8895578d8d43d9ad6771b1f5630a70.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:26');
INSERT INTO `sys_oper_log` VALUES (120, '图片管理', 1, 'com.jzj.vblog.web.controller.admin.GalleryController.add()', 'POST', 1, 'admin', NULL, '/gallery', '127.0.0.1', '内网IP', '{\"createTime\":1664520328127,\"imgAddress\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/6d8895578d8d43d9ad6771b1f5630a70.jpg\",\"updateTime\":1664520328127,\"id\":\"b9d7fcea75c0cc18c5e7c04ef5968dd1\",\"params\":{},\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:28');
INSERT INTO `sys_oper_log` VALUES (121, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'gallery', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/45b13c6c457a41bcacf5b2ec962ec190.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:32');
INSERT INTO `sys_oper_log` VALUES (122, '图片管理', 1, 'com.jzj.vblog.web.controller.admin.GalleryController.add()', 'POST', 1, 'admin', NULL, '/gallery', '127.0.0.1', '内网IP', '{\"createTime\":1664520332691,\"imgAddress\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/45b13c6c457a41bcacf5b2ec962ec190.jpg\",\"updateTime\":1664520332691,\"id\":\"768b183cdbb975413bfbe9cc5d7d4ba4\",\"params\":{},\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:32');
INSERT INTO `sys_oper_log` VALUES (123, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'gallery', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/96e53ccf50044613b931282b1a8c6765.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:39');
INSERT INTO `sys_oper_log` VALUES (124, '图片管理', 1, 'com.jzj.vblog.web.controller.admin.GalleryController.add()', 'POST', 1, 'admin', NULL, '/gallery', '127.0.0.1', '内网IP', '{\"createTime\":1664520340315,\"imgAddress\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/96e53ccf50044613b931282b1a8c6765.jpg\",\"updateTime\":1664520340315,\"id\":\"1d6ac129b136aa5f3cfb8499da523010\",\"params\":{},\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:40');
INSERT INTO `sys_oper_log` VALUES (125, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'gallery', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/456dc869a1cf4898b12f3cf5db848d01.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:47');
INSERT INTO `sys_oper_log` VALUES (126, '图片管理', 1, 'com.jzj.vblog.web.controller.admin.GalleryController.add()', 'POST', 1, 'admin', NULL, '/gallery', '127.0.0.1', '内网IP', '{\"createTime\":1664520347859,\"imgAddress\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/gallery/2022/09/30/456dc869a1cf4898b12f3cf5db848d01.jpg\",\"updateTime\":1664520347859,\"id\":\"a79d7c800d159273df96311ece81dd59\",\"params\":{},\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:45:47');
INSERT INTO `sys_oper_log` VALUES (127, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/6881723598654f4da1afd72eed1982aa.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:55:52');
INSERT INTO `sys_oper_log` VALUES (128, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/86e940e7fb5e478aa334c15a9d8d8e8e.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:56:00');
INSERT INTO `sys_oper_log` VALUES (129, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/33ee136a8a2d491887385a59a60c952a.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:57:02');
INSERT INTO `sys_oper_log` VALUES (130, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/d1b2113f954049099c4d15c671d7389c.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:57:35');
INSERT INTO `sys_oper_log` VALUES (131, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/bfd0b9ea9f8f4e72bdace86e7596c0ef.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:57:40');
INSERT INTO `sys_oper_log` VALUES (132, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/c1b3c7c99b8c4c70bacebc1db33a3b07.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 14:58:00');
INSERT INTO `sys_oper_log` VALUES (133, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/917086f4944c4bb1b15cc4e756622905.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:03:12');
INSERT INTO `sys_oper_log` VALUES (134, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/0209d1cac2b74cf5bd7345fd87888c9b.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:03:28');
INSERT INTO `sys_oper_log` VALUES (135, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO\",\"introduce\":\"Java 网络编程系列之 NIO\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/dfae8c0b0a2b4577aa268401bf0c60e4.jpg\",\"sort\":0,\"content\":\"### 1 NIO概述\\n\\n#### 1.1 IO概述\\nIO 的操作方式通常分为几种：同步阻塞 BIO、同步非阻塞 NIO、异步非阻塞 AIO。\\n\\n- 在 JDK1.4 之前，我们建立网络连接的时候采用的是 BIO 模式。\\n- Java NIO（New IO 或 Non Blocking IO）是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API。NIO 支持面向缓冲区的、基于通道的 IO 操作。 NIO 将以更加高效的方式进行文件的读写操作。BIO 与 NIO 一个比较重要的不同是， 我们使用 BIO 的时候往往会引入多线程，每个连接对应一个单独的线程；而 NIO 则是 使用单线程或者只使用少量的多线程，让连接共用一个线程。\\n- AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。\\n\\n\\n下面我们来详细介绍这几种 IO 方式\\n\\n#### 1.2 阻塞 IO (BIO)\\n阻塞 IO（BIO）是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，直至 有可供读取的数据或者数据能够写入。\\n\\n- 在 BIO 模式中，服务器会为每个客户端请求建立一个线程，由该线程单独负责 处理一个客户请求，这种模式虽然简单方便，但由于服务器为每个客户端的连接都采 用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，如果再有 用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。\\n- 大多数情况下为了避免上述问题，都采用了线程池模型。也就是创建一个固定大 小的线程池，如果有客户端请求，就从线程池中取一个空闲线程来处理，当客户端处 理完操作之后，就会释放对线程的占用。因此这样就避免为每一个客户端都要创建线 程带来的资源浪费，使得线程可以重用。但线程池也有它的弊端，如果连接大多是长 连接，可能会导致在一段时间内，线程池中的线程都被占用，那么当再有客户端请求 连接时，由于没有空闲线程来处理，就会导致客户端连接失败。传统的 BIO 模式如下 图所示：\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/86e940e7fb5e478aa334c15a9d8d8e8e.png)\\n\\n#### 1.3 非阻塞 IO(NIO)\\n基于 BIO 的各种弊端，在 JDK1.4 开始出现了高性能 IO 设计模式非阻塞 IO（NIO）。\\n\\n- NIO 采用非阻塞模式，基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，它 的实现过程是：会先对每个客户端注册感兴趣的事件，然后有一个线程专门去轮询每 个客户端是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理 完之后，便再转去继续轮询。如下图所示：\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/33ee136a8a2d491887385a59a60c952a.png)\\n\\n- NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的事件， 如下图所示：\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/bfd0b9ea9f8f4e72bdace86e7596c0ef.png)\\n\\n- NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被 注册到多路复用器上面，一个选择器线程可以同时处理成千上万个连接，系统不必创 建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/c1b3c7c99b8c4c70baceb', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:03:41');
INSERT INTO `sys_oper_log` VALUES (136, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO\",\"introduce\":\"Java 网络编程系列之 NIO\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/dfae8c0b0a2b4577aa268401bf0c60e4.jpg\",\"sort\":0,\"content\":\"### 1 NIO概述\\n\\n#### 1.1 IO概述\\nIO 的操作方式通常分为几种：同步阻塞 BIO、同步非阻塞 NIO、异步非阻塞 AIO。\\n\\n- 在 JDK1.4 之前，我们建立网络连接的时候采用的是 BIO 模式。\\n- Java NIO（New IO 或 Non Blocking IO）是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API。NIO 支持面向缓冲区的、基于通道的 IO 操作。 NIO 将以更加高效的方式进行文件的读写操作。BIO 与 NIO 一个比较重要的不同是， 我们使用 BIO 的时候往往会引入多线程，每个连接对应一个单独的线程；而 NIO 则是 使用单线程或者只使用少量的多线程，让连接共用一个线程。\\n- AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。\\n\\n\\n下面我们来详细介绍这几种 IO 方式\\n\\n#### 1.2 阻塞 IO (BIO)\\n阻塞 IO（BIO）是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，直至 有可供读取的数据或者数据能够写入。\\n\\n- 在 BIO 模式中，服务器会为每个客户端请求建立一个线程，由该线程单独负责 处理一个客户请求，这种模式虽然简单方便，但由于服务器为每个客户端的连接都采 用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，如果再有 用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。\\n- 大多数情况下为了避免上述问题，都采用了线程池模型。也就是创建一个固定大 小的线程池，如果有客户端请求，就从线程池中取一个空闲线程来处理，当客户端处 理完操作之后，就会释放对线程的占用。因此这样就避免为每一个客户端都要创建线 程带来的资源浪费，使得线程可以重用。但线程池也有它的弊端，如果连接大多是长 连接，可能会导致在一段时间内，线程池中的线程都被占用，那么当再有客户端请求 连接时，由于没有空闲线程来处理，就会导致客户端连接失败。传统的 BIO 模式如下 图所示：\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/86e940e7fb5e478aa334c15a9d8d8e8e.png)\\n\\n#### 1.3 非阻塞 IO(NIO)\\n基于 BIO 的各种弊端，在 JDK1.4 开始出现了高性能 IO 设计模式非阻塞 IO（NIO）。\\n\\n- NIO 采用非阻塞模式，基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，它 的实现过程是：会先对每个客户端注册感兴趣的事件，然后有一个线程专门去轮询每 个客户端是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理 完之后，便再转去继续轮询。如下图所示：\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/33ee136a8a2d491887385a59a60c952a.png)\\n\\n- NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的事件， 如下图所示：\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/bfd0b9ea9f8f4e72bdace86e7596c0ef.png)\\n\\n- NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被 注册到多路复用器上面，一个选择器线程可以同时处理成千上万个连接，系统不必创 建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/c1b3c7c99b8c4c70baceb', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:04:46');
INSERT INTO `sys_oper_log` VALUES (137, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO\",\"introduce\":\"Java 网络编程系列之 NIO\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/dfae8c0b0a2b4577aa268401bf0c60e4.jpg\",\"sort\":0,\"content\":\"### 1 NIO概述\\n\\n#### 1.1 IO概述\\nIO 的操作方式通常分为几种：同步阻塞 BIO、同步非阻塞 NIO、异步非阻塞 AIO。\\n\\n- 在 JDK1.4 之前，我们建立网络连接的时候采用的是 BIO 模式。\\n- Java NIO（New IO 或 Non Blocking IO）是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API。NIO 支持面向缓冲区的、基于通道的 IO 操作。 NIO 将以更加高效的方式进行文件的读写操作。BIO 与 NIO 一个比较重要的不同是， 我们使用 BIO 的时候往往会引入多线程，每个连接对应一个单独的线程；而 NIO 则是 使用单线程或者只使用少量的多线程，让连接共用一个线程。\\n- AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。\\n\\n\\n下面我们来详细介绍这几种 IO 方式\\n\\n#### 1.2 阻塞 IO (BIO)\\n阻塞 IO（BIO）是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，直至 有可供读取的数据或者数据能够写入。\\n\\n- 在 BIO 模式中，服务器会为每个客户端请求建立一个线程，由该线程单独负责 处理一个客户请求，这种模式虽然简单方便，但由于服务器为每个客户端的连接都采 用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，如果再有 用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。\\n- 大多数情况下为了避免上述问题，都采用了线程池模型。也就是创建一个固定大 小的线程池，如果有客户端请求，就从线程池中取一个空闲线程来处理，当客户端处 理完操作之后，就会释放对线程的占用。因此这样就避免为每一个客户端都要创建线 程带来的资源浪费，使得线程可以重用。但线程池也有它的弊端，如果连接大多是长 连接，可能会导致在一段时间内，线程池中的线程都被占用，那么当再有客户端请求 连接时，由于没有空闲线程来处理，就会导致客户端连接失败。传统的 BIO 模式如下 图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/86e940e7fb5e478aa334c15a9d8d8e8e.png)\\n\\n:::\\n\\n\\n#### 1.3 非阻塞 IO(NIO)\\n基于 BIO 的各种弊端，在 JDK1.4 开始出现了高性能 IO 设计模式非阻塞 IO（NIO）。\\n\\n- NIO 采用非阻塞模式，基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，它 的实现过程是：会先对每个客户端注册感兴趣的事件，然后有一个线程专门去轮询每 个客户端是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理 完之后，便再转去继续轮询。如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/33ee136a8a2d491887385a59a60c952a.png)\\n\\n:::\\n\\n\\n- NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的事件， 如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/bfd0b9ea9f8f4e72bdace86e7596c0ef.png)\\n\\n:::\\n\\n\\n- NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被 注册到多路复用器上面，一个选择器线程可以同时处理成千上万个连接，系统不必创 建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。\\n::: hljs-center\\', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:05:41');
INSERT INTO `sys_oper_log` VALUES (138, '字典类型', 1, 'com.jzj.vblog.web.controller.admin.SysDictDataController.add()', 'POST', 1, 'admin', NULL, '/system/dict/data', '127.0.0.1', '内网IP', '{\"dictValue\":\"10\",\"listClass\":\"primary\",\"dictSort\":0,\"remark\":\"NIO\",\"updateTime\":1664521628261,\"params\":{},\"dictType\":\"sys_article_tag\",\"dictLabel\":\"NIO\",\"createBy\":\"admin\",\"createTime\":1664521628261,\"status\":\"0\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:07:08');
INSERT INTO `sys_oper_log` VALUES (139, '字典类型', 9, 'com.jzj.vblog.web.controller.admin.SysDictTypeController.refreshCache()', 'DELETE', 1, 'admin', NULL, '/system/dict/type/refreshCache', '127.0.0.1', '内网IP', '{}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:07:16');
INSERT INTO `sys_oper_log` VALUES (140, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleSummary', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/2662e8eef71d439e81c62ba7cb850bd0.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:07:36');
INSERT INTO `sys_oper_log` VALUES (141, '归档管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleSummaryController.add()', 'POST', 1, 'admin', NULL, '/article/summary', '127.0.0.1', '内网IP', '{\"createTime\":1664521657431,\"author\":\"漫漫前路\",\"name\":\"尚硅谷NIO笔记\",\"banner\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/2662e8eef71d439e81c62ba7cb850bd0.jpg\",\"updateTime\":1664521657431,\"id\":\"6af32c16a767b5a74dc711d8d688236f\",\"params\":{},\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:07:37');
INSERT INTO `sys_oper_log` VALUES (142, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleSummary', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/4b416e9fee76496498e692c76eb59542.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:08:20');
INSERT INTO `sys_oper_log` VALUES (143, '归档管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleSummaryController.add()', 'POST', 1, 'admin', NULL, '/article/summary', '127.0.0.1', '内网IP', '{\"createTime\":1664521701092,\"author\":\"漫漫前路\",\"name\":\"尚硅谷MySQL笔记\",\"banner\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/4b416e9fee76496498e692c76eb59542.jpg\",\"updateTime\":1664521701092,\"id\":\"f796f398a0dd7e44a3e407837250f3c1\",\"params\":{},\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:08:21');
INSERT INTO `sys_oper_log` VALUES (144, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleSummary', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/e380b7f1034443fea069c6e3db3e2aab.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:08:48');
INSERT INTO `sys_oper_log` VALUES (145, '归档管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleSummaryController.add()', 'POST', 1, 'admin', NULL, '/article/summary', '127.0.0.1', '内网IP', '{\"createTime\":1664521729252,\"author\":\"漫漫前路\",\"name\":\"尚硅谷Netty笔记\",\"banner\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleSummary/2022/09/30/e380b7f1034443fea069c6e3db3e2aab.jpg\",\"updateTime\":1664521729252,\"id\":\"ac578e0aba0f32dffd9d1a10a159b04c\",\"params\":{},\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:08:49');
INSERT INTO `sys_oper_log` VALUES (146, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（概述）\",\"introduce\":\"Java 网络编程系列之 NIO\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/dfae8c0b0a2b4577aa268401bf0c60e4.jpg\",\"sort\":0,\"content\":\"### 1 IO概述\\nIO 的操作方式通常分为几种：同步阻塞 BIO、同步非阻塞 NIO、异步非阻塞 AIO。\\n\\n- 在 JDK1.4 之前，我们建立网络连接的时候采用的是 BIO 模式。\\n- Java NIO（New IO 或 Non Blocking IO）是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API。NIO 支持面向缓冲区的、基于通道的 IO 操作。 NIO 将以更加高效的方式进行文件的读写操作。BIO 与 NIO 一个比较重要的不同是， 我们使用 BIO 的时候往往会引入多线程，每个连接对应一个单独的线程；而 NIO 则是 使用单线程或者只使用少量的多线程，让连接共用一个线程。\\n- AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。\\n\\n\\n下面我们来详细介绍这几种 IO 方式\\n\\n### 2 阻塞 IO (BIO)\\n阻塞 IO（BIO）是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，直至 有可供读取的数据或者数据能够写入。\\n\\n- 在 BIO 模式中，服务器会为每个客户端请求建立一个线程，由该线程单独负责 处理一个客户请求，这种模式虽然简单方便，但由于服务器为每个客户端的连接都采 用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，如果再有 用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。\\n- 大多数情况下为了避免上述问题，都采用了线程池模型。也就是创建一个固定大 小的线程池，如果有客户端请求，就从线程池中取一个空闲线程来处理，当客户端处 理完操作之后，就会释放对线程的占用。因此这样就避免为每一个客户端都要创建线 程带来的资源浪费，使得线程可以重用。但线程池也有它的弊端，如果连接大多是长 连接，可能会导致在一段时间内，线程池中的线程都被占用，那么当再有客户端请求 连接时，由于没有空闲线程来处理，就会导致客户端连接失败。传统的 BIO 模式如下 图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/86e940e7fb5e478aa334c15a9d8d8e8e.png)\\n\\n:::\\n\\n\\n### 3 非阻塞 IO(NIO)\\n基于 BIO 的各种弊端，在 JDK1.4 开始出现了高性能 IO 设计模式非阻塞 IO（NIO）。\\n\\n- NIO 采用非阻塞模式，基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，它 的实现过程是：会先对每个客户端注册感兴趣的事件，然后有一个线程专门去轮询每 个客户端是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理 完之后，便再转去继续轮询。如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/33ee136a8a2d491887385a59a60c952a.png)\\n\\n:::\\n\\n\\n- NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的事件， 如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/bfd0b9ea9f8f4e72bdace86e7596c0ef.png)\\n\\n:::\\n\\n\\n- NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被 注册到多路复用器上面，一个选择器线程可以同时处理成千上万个连接，系统不必创 建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。\\n::: hljs-center\\n\\n![image.png](http', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:11:06');
INSERT INTO `sys_oper_log` VALUES (147, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/9022fbc5907d4e4ebe016e4d8976ce9d.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:13:29');
INSERT INTO `sys_oper_log` VALUES (148, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Channel）\",\"introduce\":\"Java网络编程-NIO（Channel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/9022fbc5907d4e4ebe016e4d8976ce9d.jpg\",\"sort\":0,\"content\":\"\",\"commentStatus\":\"0\",\"htmlContent\":\"\",\"articleTag\":\"0,10\",\"aggregateId\":\"6af32c16a767b5a74dc711d8d688236f\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"1\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:13:35');
INSERT INTO `sys_oper_log` VALUES (149, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（概述）\",\"introduce\":\"Java 网络编程系列之 NIO\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/dfae8c0b0a2b4577aa268401bf0c60e4.jpg\",\"sort\":0,\"content\":\"### 1 IO概述\\nIO 的操作方式通常分为几种：同步阻塞 BIO、同步非阻塞 NIO、异步非阻塞 AIO。\\n\\n- 在 JDK1.4 之前，我们建立网络连接的时候采用的是 BIO 模式。\\n- Java NIO（New IO 或 Non Blocking IO）是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API。NIO 支持面向缓冲区的、基于通道的 IO 操作。 NIO 将以更加高效的方式进行文件的读写操作。BIO 与 NIO 一个比较重要的不同是， 我们使用 BIO 的时候往往会引入多线程，每个连接对应一个单独的线程；而 NIO 则是 使用单线程或者只使用少量的多线程，让连接共用一个线程。\\n- AIO 也就是 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。\\n\\n\\n下面我们来详细介绍这几种 IO 方式\\n\\n### 2 阻塞 IO (BIO)\\n阻塞 IO（BIO）是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，直至 有可供读取的数据或者数据能够写入。\\n\\n- 在 BIO 模式中，服务器会为每个客户端请求建立一个线程，由该线程单独负责 处理一个客户请求，这种模式虽然简单方便，但由于服务器为每个客户端的连接都采 用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，如果再有 用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。\\n- 大多数情况下为了避免上述问题，都采用了线程池模型。也就是创建一个固定大 小的线程池，如果有客户端请求，就从线程池中取一个空闲线程来处理，当客户端处 理完操作之后，就会释放对线程的占用。因此这样就避免为每一个客户端都要创建线 程带来的资源浪费，使得线程可以重用。但线程池也有它的弊端，如果连接大多是长 连接，可能会导致在一段时间内，线程池中的线程都被占用，那么当再有客户端请求 连接时，由于没有空闲线程来处理，就会导致客户端连接失败。传统的 BIO 模式如下 图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/86e940e7fb5e478aa334c15a9d8d8e8e.png)\\n\\n:::\\n\\n\\n### 3 非阻塞 IO(NIO)\\n基于 BIO 的各种弊端，在 JDK1.4 开始出现了高性能 IO 设计模式非阻塞 IO（NIO）。\\n\\n- NIO 采用非阻塞模式，基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，它 的实现过程是：会先对每个客户端注册感兴趣的事件，然后有一个线程专门去轮询每 个客户端是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理 完之后，便再转去继续轮询。如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/33ee136a8a2d491887385a59a60c952a.png)\\n\\n:::\\n\\n\\n- NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的事件， 如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/bfd0b9ea9f8f4e72bdace86e7596c0ef.png)\\n\\n:::\\n\\n\\n- NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被 注册到多路复用器上面，一个选择器线程可以同时处理成千上万个连接，系统不必创 建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。\\n::: hljs-center\\n\\n![image.png](http', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:13:52');
INSERT INTO `sys_oper_log` VALUES (150, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/1e486540ca1647729ae0d8ec82573a98.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:15:13');
INSERT INTO `sys_oper_log` VALUES (151, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/04651f0d2f5a4406a16a901e27f75f95.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:17:45');
INSERT INTO `sys_oper_log` VALUES (152, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Channel）\",\"introduce\":\"Java网络编程-NIO（Channel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/9022fbc5907d4e4ebe016e4d8976ce9d.jpg\",\"sort\":0,\"content\":\"#### 1 Channel 概述\\nJava NIO 的通道类似流，但又有些不同：\\n1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\\n2. 通道可以异步地读写。\\n3. 通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。\\n\\n正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/1e486540ca1647729ae0d8ec82573a98.png)\\n\\n:::\\n\\n#### 2 Channel 实现\\n下面是 Java NIO 中最重要的 Channel 的实现：\\n1. FileChannel（从文件中读写数据）\\n2. DatagramChannel（能通过 UDP 读写网络中的数据）\\n3. SocketChannel（能通过 TCP 读写网络中的数据）\\n4. ServerSocketChannel（可以监听新进来的 TCP 连接，像 Web 服务器那样。对 每一个新进来的连接都会创建一个 SocketChannel）\\n\\n正如你所看到的，这些通道涵盖了 UDP 和 TCP 网络 IO，以及文件 IO\\n\\n#### 3 FileChannel 介绍和示例\\nFileChannel 类可以实现常用的 read，write 以及 scatter/gather 操作，同时它也提 供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/04651f0d2f5a4406a16a901e27f75f95.png)\\n\\n:::\\n\\n下面是一个使用 FileChannel 读取数据到 Buffer 中的示例：\\n```java\\npublic class FileChannelDemo01 {\\n    //FileChannel读取数据到buffer中\\n    public static void main(String[] args) throws Exception {\\n        //创建FileChannel\\n        RandomAccessFile accessFile = new RandomAccessFile(\\\"d:\\\\\\\\333.txt\\\", \\\"rw\\\");\\n        FileChannel channel = accessFile.getChannel();\\n        //创建Buffer\\n        ByteBuffer  buf = ByteBuffer.allocate(1024);\\n        //读取数据到buffer中\\n        int bytesRead = channel.read(buf);\\n        while (bytesRead !=-1){\\n            System.out.println(\\\"读取了：\\\"+bytesRead);\\n            buf.flip();\\n            while (buf.hasRemaining()){\\n                System.out.println((char) buf.get());\\n            }\\n            buf.clear();\\n            bytesRead = channel.read(buf);\\n        }\\n        accessFile.close();\\n        System.out.println(\\\"结束了\\\");\\n    }\\n}\\n```\\n\\nBuffer 通常的操作\\n1. 将数据写入缓冲区\\n2. ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:25:22');
INSERT INTO `sys_oper_log` VALUES (153, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Channel）\",\"introduce\":\"Java网络编程-NIO（Channel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/9022fbc5907d4e4ebe016e4d8976ce9d.jpg\",\"sort\":0,\"content\":\"#### 1 Channel 概述\\nJava NIO 的通道类似流，但又有些不同：\\n1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\\n2. 通道可以异步地读写。\\n3. 通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。\\n\\n正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/1e486540ca1647729ae0d8ec82573a98.png)\\n\\n:::\\n\\n#### 2 Channel 实现\\n下面是 Java NIO 中最重要的 Channel 的实现：\\n1. FileChannel（从文件中读写数据）\\n2. DatagramChannel（能通过 UDP 读写网络中的数据）\\n3. SocketChannel（能通过 TCP 读写网络中的数据）\\n4. ServerSocketChannel（可以监听新进来的 TCP 连接，像 Web 服务器那样。对 每一个新进来的连接都会创建一个 SocketChannel）\\n\\n正如你所看到的，这些通道涵盖了 UDP 和 TCP 网络 IO，以及文件 IO\\n\\n#### 3 FileChannel 介绍和示例\\nFileChannel 类可以实现常用的 read，write 以及 scatter/gather 操作，同时它也提 供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/04651f0d2f5a4406a16a901e27f75f95.png)\\n\\n:::\\n\\n下面是一个使用 FileChannel 读取数据到 Buffer 中的示例：\\n```java\\npublic class FileChannelDemo01 {\\n    //FileChannel读取数据到buffer中\\n    public static void main(String[] args) throws Exception {\\n        //创建FileChannel\\n        RandomAccessFile accessFile = new RandomAccessFile(\\\"d:\\\\\\\\333.txt\\\", \\\"rw\\\");\\n        FileChannel channel = accessFile.getChannel();\\n        //创建Buffer\\n        ByteBuffer  buf = ByteBuffer.allocate(1024);\\n        //读取数据到buffer中\\n        int bytesRead = channel.read(buf);\\n        while (bytesRead !=-1){\\n            System.out.println(\\\"读取了：\\\"+bytesRead);\\n            buf.flip();\\n            while (buf.hasRemaining()){\\n                System.out.println((char) buf.get());\\n            }\\n            buf.clear();\\n            bytesRead = channel.read(buf);\\n        }\\n        accessFile.close();\\n        System.out.println(\\\"结束了\\\");\\n    }\\n}\\n```\\n\\nBuffer 通常的操作\\n1. 将数据写入缓冲区\\n2. ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 15:33:34');
INSERT INTO `sys_oper_log` VALUES (154, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/3020d19255734776aea5f650ebd4946b.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 16:15:05');
INSERT INTO `sys_oper_log` VALUES (155, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/175b692f36164285b91181519562fc1f.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 16:16:20');
INSERT INTO `sys_oper_log` VALUES (156, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Channel）\",\"introduce\":\"Java网络编程-NIO（Channel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/9022fbc5907d4e4ebe016e4d8976ce9d.jpg\",\"sort\":0,\"content\":\"#### 1 Channel 概述\\nJava NIO 的通道类似流，但又有些不同：\\n1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\\n2. 通道可以异步地读写。\\n3. 通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。\\n\\n正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/1e486540ca1647729ae0d8ec82573a98.png)\\n\\n:::\\n\\n#### 2 Channel 实现\\n下面是 Java NIO 中最重要的 Channel 的实现：\\n1. FileChannel（从文件中读写数据）\\n2. DatagramChannel（能通过 UDP 读写网络中的数据）\\n3. SocketChannel（能通过 TCP 读写网络中的数据）\\n4. ServerSocketChannel（可以监听新进来的 TCP 连接，像 Web 服务器那样。对 每一个新进来的连接都会创建一个 SocketChannel）\\n\\n正如你所看到的，这些通道涵盖了 UDP 和 TCP 网络 IO，以及文件 IO\\n\\n#### 3 FileChannel 介绍和示例\\nFileChannel 类可以实现常用的 read，write 以及 scatter/gather 操作，同时它也提 供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/04651f0d2f5a4406a16a901e27f75f95.png)\\n\\n:::\\n\\n下面是一个使用 FileChannel 读取数据到 Buffer 中的示例：\\n```java\\npublic class FileChannelDemo01 {\\n    //FileChannel读取数据到buffer中\\n    public static void main(String[] args) throws Exception {\\n        //创建FileChannel\\n        RandomAccessFile accessFile = new RandomAccessFile(\\\"d:\\\\\\\\333.txt\\\", \\\"rw\\\");\\n        FileChannel channel = accessFile.getChannel();\\n        //创建Buffer\\n        ByteBuffer  buf = ByteBuffer.allocate(1024);\\n        //读取数据到buffer中\\n        int bytesRead = channel.read(buf);\\n        while (bytesRead !=-1){\\n            System.out.println(\\\"读取了：\\\"+bytesRead);\\n            buf.flip();\\n            while (buf.hasRemaining()){\\n                System.out.println((char) buf.get());\\n            }\\n            buf.clear();\\n            bytesRead = channel.read(buf);\\n        }\\n        accessFile.close();\\n        System.out.println(\\\"结束了\\\");\\n    }\\n}\\n```\\n\\nBuffer 通常的操作\\n1. 将数据写入缓冲区\\n2. ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 16:17:02');
INSERT INTO `sys_oper_log` VALUES (157, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 16:30:39');
INSERT INTO `sys_oper_log` VALUES (158, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（SocketChannel）\",\"introduce\":\"Java网络编程-NIO（SocketChannel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\",\"sort\":0,\"content\":\"\",\"commentStatus\":\"0\",\"htmlContent\":\"\",\"articleTag\":\"0,10\",\"aggregateId\":\"6af32c16a767b5a74dc711d8d688236f\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"1\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 16:30:44');
INSERT INTO `sys_oper_log` VALUES (159, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 16:33:27');
INSERT INTO `sys_oper_log` VALUES (160, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（SocketChannel）\",\"introduce\":\"Java网络编程-NIO（SocketChannel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\",\"sort\":0,\"content\":\"1. SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。\\n2. socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。\\n3. 设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。\\n\\n\\nAbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png)\\n\\n:::\\n\\n下面分别介绍这 3 个通道\\n\\n#### 1 ServerSocketChannel\\nServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。\\n\\n由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。\\n\\n同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。\\n\\n以下代码演示了如何使用一个非阻塞的 accept( )方法：\",\"commentStatus\":\"0\",\"htmlContent\":\"<ol>\\n<li>SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。</li>\\n<li>socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。</li>\\n<li>设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-09-30 16:34:49');
INSERT INTO `sys_oper_log` VALUES (161, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/57a63832c66f45c5bbff395c36d92be7.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 09:36:20');
INSERT INTO `sys_oper_log` VALUES (162, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/3e5b7a01f90e49efa8f1f6ad814858cd.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 09:39:02');
INSERT INTO `sys_oper_log` VALUES (163, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/3b10263a28184fa199557f6f2aeaa674.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 09:39:23');
INSERT INTO `sys_oper_log` VALUES (164, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/07e22f9e39af427b817c698bdc089c43.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 09:40:14');
INSERT INTO `sys_oper_log` VALUES (165, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（SocketChannel）\",\"introduce\":\"Java网络编程-NIO（SocketChannel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\",\"sort\":0,\"content\":\"1. SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。\\n2. socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。\\n3. 设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。\\n\\n\\nAbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png)\\n\\n:::\\n\\n下面分别介绍这 3 个通道\\n\\n#### 1 ServerSocketChannel\\nServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。\\n\\n由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。\\n\\n同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。\\n\\n以下代码演示了如何使用一个非阻塞的 accept( )方法：\\n```java\\npublic class ServerSocketChannelDemo {\\n    public static void main(String[] args) throws Exception {\\n        //端口号\\n        int port = 9999;\\n        //buffer\\n        ByteBuffer buffer = ByteBuffer.wrap(\\\"hello word\\\".getBytes(StandardCharsets.UTF_8));\\n\\n        //ServerSocketChannel\\n        ServerSocketChannel ssc = ServerSocketChannel.open();\\n        //绑定\\n        ssc.socket().bind(new InetSocketAddress(port));\\n        //设置非阻塞模式\\n        ssc.configureBlocking(false);\\n\\n        //监听是否有新链接传入\\n        while (true){\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 09:40:27');
INSERT INTO `sys_oper_log` VALUES (166, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（SocketChannel）\",\"introduce\":\"Java网络编程-NIO（SocketChannel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\",\"sort\":0,\"content\":\"1. SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。\\n2. socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。\\n3. 设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。\\n\\n\\nAbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png)\\n\\n:::\\n\\n下面分别介绍这 3 个通道\\n\\n#### 1 ServerSocketChannel\\nServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。\\n\\n由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。\\n\\n同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。\\n\\n以下代码演示了如何使用一个非阻塞的 accept( )方法：\\n```java\\npublic class ServerSocketChannelDemo {\\n    public static void main(String[] args) throws Exception {\\n        //端口号\\n        int port = 9999;\\n        //buffer\\n        ByteBuffer buffer = ByteBuffer.wrap(\\\"hello word\\\".getBytes(StandardCharsets.UTF_8));\\n\\n        //ServerSocketChannel\\n        ServerSocketChannel ssc = ServerSocketChannel.open();\\n        //绑定\\n        ssc.socket().bind(new InetSocketAddress(port));\\n        //设置非阻塞模式\\n        ssc.configureBlocking(false);\\n\\n        //监听是否有新链接传入\\n        while (true){\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 09:40:31');
INSERT INTO `sys_oper_log` VALUES (167, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（SocketChannel）\",\"introduce\":\"Java网络编程-NIO（SocketChannel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\",\"sort\":0,\"content\":\"1. SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。\\n2. socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。\\n3. 设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。\\n\\n\\nAbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png)\\n\\n:::\\n\\n下面分别介绍这 3 个通道\\n\\n#### 1 ServerSocketChannel\\nServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。\\n\\n由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。\\n\\n同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。\\n\\n以下代码演示了如何使用一个非阻塞的 accept( )方法：\\n```java\\npublic class ServerSocketChannelDemo {\\n    public static void main(String[] args) throws Exception {\\n        //端口号\\n        int port = 9999;\\n        //buffer\\n        ByteBuffer buffer = ByteBuffer.wrap(\\\"hello word\\\".getBytes(StandardCharsets.UTF_8));\\n\\n        //ServerSocketChannel\\n        ServerSocketChannel ssc = ServerSocketChannel.open();\\n        //绑定\\n        ssc.socket().bind(new InetSocketAddress(port));\\n        //设置非阻塞模式\\n        ssc.configureBlocking(false);\\n\\n        //监听是否有新链接传入\\n        while (true){\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 09:53:32');
INSERT INTO `sys_oper_log` VALUES (168, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（SocketChannel）\",\"introduce\":\"Java网络编程-NIO（SocketChannel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\",\"sort\":0,\"content\":\"1. SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。\\n2. socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。\\n3. 设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。\\n\\n\\nAbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png)\\n\\n:::\\n\\n下面分别介绍这 3 个通道\\n\\n#### 1 ServerSocketChannel\\nServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。\\n\\n由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。\\n\\n同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。\\n\\n以下代码演示了如何使用一个非阻塞的 accept( )方法：\\n```java\\npublic class ServerSocketChannelDemo {\\n    public static void main(String[] args) throws Exception {\\n        //端口号\\n        int port = 9999;\\n        //buffer\\n        ByteBuffer buffer = ByteBuffer.wrap(\\\"hello word\\\".getBytes(StandardCharsets.UTF_8));\\n\\n        //ServerSocketChannel\\n        ServerSocketChannel ssc = ServerSocketChannel.open();\\n        //绑定\\n        ssc.socket().bind(new InetSocketAddress(port));\\n        //设置非阻塞模式\\n        ssc.configureBlocking(false);\\n\\n        //监听是否有新链接传入\\n        while (true){\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 10:00:09');
INSERT INTO `sys_oper_log` VALUES (169, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（SocketChannel）\",\"introduce\":\"Java网络编程-NIO（SocketChannel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\",\"sort\":0,\"content\":\"1. SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。\\n2. socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。\\n3. 设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。\\n\\n\\nAbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png)\\n\\n:::\\n\\n下面分别介绍这 3 个通道\\n\\n#### 1 ServerSocketChannel\\nServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。\\n\\n由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。\\n\\n同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。\\n\\n以下代码演示了如何使用一个非阻塞的 accept( )方法：\\n```java\\npublic class ServerSocketChannelDemo {\\n    public static void main(String[] args) throws Exception {\\n        //端口号\\n        int port = 9999;\\n        //buffer\\n        ByteBuffer buffer = ByteBuffer.wrap(\\\"hello word\\\".getBytes(StandardCharsets.UTF_8));\\n\\n        //ServerSocketChannel\\n        ServerSocketChannel ssc = ServerSocketChannel.open();\\n        //绑定\\n        ssc.socket().bind(new InetSocketAddress(port));\\n        //设置非阻塞模式\\n        ssc.configureBlocking(false);\\n\\n        //监听是否有新链接传入\\n        while (true){\\n   ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 16:22:16');
INSERT INTO `sys_oper_log` VALUES (170, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Channel）\",\"introduce\":\"Java网络编程-NIO（Channel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/9022fbc5907d4e4ebe016e4d8976ce9d.jpg\",\"sort\":0,\"content\":\"### 1 Channel 概述\\nJava NIO 的通道类似流，但又有些不同：\\n1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\\n2. 通道可以异步地读写。\\n3. 通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。\\n\\n正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/1e486540ca1647729ae0d8ec82573a98.png)\\n\\n:::\\n\\n### 2 Channel 实现\\n下面是 Java NIO 中最重要的 Channel 的实现：\\n1. FileChannel（从文件中读写数据）\\n2. DatagramChannel（能通过 UDP 读写网络中的数据）\\n3. SocketChannel（能通过 TCP 读写网络中的数据）\\n4. ServerSocketChannel（可以监听新进来的 TCP 连接，像 Web 服务器那样。对 每一个新进来的连接都会创建一个 SocketChannel）\\n\\n正如你所看到的，这些通道涵盖了 UDP 和 TCP 网络 IO，以及文件 IO\\n\\n### 3 FileChannel 介绍和示例\\nFileChannel 类可以实现常用的 read，write 以及 scatter/gather 操作，同时它也提 供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/04651f0d2f5a4406a16a901e27f75f95.png)\\n\\n:::\\n\\n下面是一个使用 FileChannel 读取数据到 Buffer 中的示例：\\n```java\\npublic class FileChannelDemo01 {\\n    //FileChannel读取数据到buffer中\\n    public static void main(String[] args) throws Exception {\\n        //创建FileChannel\\n        RandomAccessFile accessFile = new RandomAccessFile(\\\"d:\\\\\\\\333.txt\\\", \\\"rw\\\");\\n        FileChannel channel = accessFile.getChannel();\\n        //创建Buffer\\n        ByteBuffer  buf = ByteBuffer.allocate(1024);\\n        //读取数据到buffer中\\n        int bytesRead = channel.read(buf);\\n        while (bytesRead !=-1){\\n            System.out.println(\\\"读取了：\\\"+bytesRead);\\n            buf.flip();\\n            while (buf.hasRemaining()){\\n                System.out.println((char) buf.get());\\n            }\\n            buf.clear();\\n            bytesRead = channel.read(buf);\\n        }\\n        accessFile.close();\\n        System.out.println(\\\"结束了\\\");\\n    }\\n}\\n```\\n\\nBuffer 通常的操作\\n1. 将数据写入缓冲区\\n2. 调用 ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 16:25:20');
INSERT INTO `sys_oper_log` VALUES (171, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（SocketChannel）\",\"introduce\":\"Java网络编程-NIO（SocketChannel）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/09/30/535d7be3e8614d5b92d3b4567f005bef.jpg\",\"sort\":0,\"content\":\"1. SocketChannel 就是 NIO 对于非阻塞 socket 操作的支持的组件，其在 socket 上 封装了一层，主要是支持了非阻塞的读写。同时改进了传统的单向流 API,，Channel 同时支持读写。\\n2. socket 通道类主要分为 DatagramChannel、SocketChannel 和 ServerSocketChannel，它们在被实例化时都会创建一个对等 socket 对象。要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类： SelectableChannel。就绪选择（readiness selection）是一种可以用来查询通道的 机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻塞 I/O 和 可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。\\n3. 设置或重新设置一个通道的阻塞模式是很简单的，只要调用 configureBlocking( )方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于 哪种模式。\\n\\n\\nAbstractSelectableChannel.java 中实现的 configureBlocking()方法如下：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/09/30/13ce8ae8652a4cafa8312081c19f7adc.png)\\n\\n:::\\n\\n下面分别介绍这 3 个通道\\n\\n### 1 ServerSocketChannel\\nServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket 执行相同的任务，不过它增加了通道语义，因此能够在非阻塞 模式下运行。\\n\\n由于 ServerSocketChannel 没有 bind()方法，因此有必要取出对等的 socket 并使用 它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根 据需要设置其他的 socket 选项。\\n\\n同 java.net.ServerSocket 一样，ServerSocketChannel 也有 accept( )方法。 ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象， SocketChannel 可以在非阻塞模式下运行。\\n\\n以下代码演示了如何使用一个非阻塞的 accept( )方法：\\n```java\\npublic class ServerSocketChannelDemo {\\n    public static void main(String[] args) throws Exception {\\n        //端口号\\n        int port = 9999;\\n        //buffer\\n        ByteBuffer buffer = ByteBuffer.wrap(\\\"hello word\\\".getBytes(StandardCharsets.UTF_8));\\n\\n        //ServerSocketChannel\\n        ServerSocketChannel ssc = ServerSocketChannel.open();\\n        //绑定\\n        ssc.socket().bind(new InetSocketAddress(port));\\n        //设置非阻塞模式\\n        ssc.configureBlocking(false);\\n\\n        //监听是否有新链接传入\\n        while (true){\\n    ', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 16:26:27');
INSERT INTO `sys_oper_log` VALUES (172, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/08/ad90335701f84465b105d9548cc6f992.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 16:36:48');
INSERT INTO `sys_oper_log` VALUES (173, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Buffer）\",\"introduce\":\"Java网络编程-NIO（Buffer）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/08/ad90335701f84465b105d9548cc6f992.jpg\",\"sort\":0,\"content\":\"\",\"commentStatus\":\"0\",\"htmlContent\":\"\",\"articleTag\":\"0,10\",\"aggregateId\":\"6af32c16a767b5a74dc711d8d688236f\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"1\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 16:37:01');
INSERT INTO `sys_oper_log` VALUES (174, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/ff63cf22b4fb456fa17b1bd67c58204d.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 16:55:24');
INSERT INTO `sys_oper_log` VALUES (175, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/e77b8d6b861b430c9dec09ed3d4b54e3.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 16:56:26');
INSERT INTO `sys_oper_log` VALUES (176, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/1d35274b372541158b8b959ff27ddeb1.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 16:59:24');
INSERT INTO `sys_oper_log` VALUES (177, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Buffer）\",\"introduce\":\"Java网络编程-NIO（Buffer）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/08/ad90335701f84465b105d9548cc6f992.jpg\",\"sort\":0,\"content\":\"### 1 Buffer 简介\\nJava NIO 中的 Buffer 用于和 NIO 通道进行交互。数据是从通道读入缓冲区，从缓冲 区写入到通道中的。\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/ff63cf22b4fb456fa17b1bd67c58204d.png)\\n\\n:::\\n\\n缓冲区 ==本质上是一块可以写入数据，然后可以从中读取数据的内存== 。这块内存被包装 成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。缓冲区实际上是 一个容器对象，更直接的说，其实就是一个数组，==在 NIO 库中，所有数据都是用缓冲 区处理的== 。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到 缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流 I/O 系统中，所有数据都是直接写入或者直接将数据读取到 Stream 对象中。 在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer，最常用的就是 ByteBuffer， 对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应，它们之间的继 承关系如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/e77b8d6b861b430c9dec09ed3d4b54e3.png)\\n\\n:::\\n\\n### 2 Buffer 的基本用法\\n\\n使用 Buffer 读写数据，一般遵循以下四个步骤：\\n- 写入数据到 Buffer\\n- 调用 flip()方法\\n- 从 Buffer 中读取数据\\n- 调用 clear()方法或者 compact()方法\\n\\n\\n当向 buffer 写入数据时，buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip()方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 buffer 的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有 两种方式能清空缓冲区：调用 clear()或 compact()方法。clear()方法会清空整个缓冲 区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起 始处，新写入的数据将放到缓冲区未读数据的后面。\\n\\n使用 Buffer 的例子：\\n```java\\npublic class BufferDemo01 {\\n    @Test\\n    public void buffer01() throws Exception {\\n        //FileChannel\\n        RandomAccessFile aFile = new RandomAccessFile(\\\"d:\\\\\\\\111.txt\\\",\\\"rw\\\");\\n        FileChannel channel = aFile.getChannel();\\n        //创建buffer,大小\\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\\n        //读\\n        int bytesRead = channel.read(buffer);\\n        while (bytesRead != -1){\\n            //read模式\\n            buffer.flip();\\n            while (buffer.hasRemaining()){\\n                System.out.println((char)buffer.get());\\n            }\\n            buffer.clear();\\n            bytesRead = channel.', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-08 17:09:04');
INSERT INTO `sys_oper_log` VALUES (178, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278266222,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:46');
INSERT INTO `sys_oper_log` VALUES (179, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470423000,\"updateTime\":1665278267686,\"id\":\"5968d94f9d2d78f383c9cb8ee0595756\",\"text\":\"好好好学习天天向上\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:47');
INSERT INTO `sys_oper_log` VALUES (180, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173369000,\"updateTime\":1665278270393,\"id\":\"d03d1664f7f5ac853cb5b3a37770bbb6\",\"text\":\"买手机\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:50');
INSERT INTO `sys_oper_log` VALUES (181, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278274156,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:54');
INSERT INTO `sys_oper_log` VALUES (182, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173369000,\"updateTime\":1665278274742,\"id\":\"d03d1664f7f5ac853cb5b3a37770bbb6\",\"text\":\"买手机\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:54');
INSERT INTO `sys_oper_log` VALUES (183, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278275430,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:55');
INSERT INTO `sys_oper_log` VALUES (184, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278277090,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:57');
INSERT INTO `sys_oper_log` VALUES (185, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173369000,\"updateTime\":1665278277870,\"id\":\"d03d1664f7f5ac853cb5b3a37770bbb6\",\"text\":\"买手机\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:57');
INSERT INTO `sys_oper_log` VALUES (186, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470423000,\"updateTime\":1665278278262,\"id\":\"5968d94f9d2d78f383c9cb8ee0595756\",\"text\":\"好好好学习天天向上\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:58');
INSERT INTO `sys_oper_log` VALUES (187, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278279478,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:17:59');
INSERT INTO `sys_oper_log` VALUES (188, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173369000,\"updateTime\":1665278280222,\"id\":\"d03d1664f7f5ac853cb5b3a37770bbb6\",\"text\":\"买手机\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:00');
INSERT INTO `sys_oper_log` VALUES (189, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470423000,\"updateTime\":1665278280774,\"id\":\"5968d94f9d2d78f383c9cb8ee0595756\",\"text\":\"好好好学习天天向上\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:00');
INSERT INTO `sys_oper_log` VALUES (190, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278281254,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:01');
INSERT INTO `sys_oper_log` VALUES (191, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173369000,\"updateTime\":1665278281814,\"id\":\"d03d1664f7f5ac853cb5b3a37770bbb6\",\"text\":\"买手机\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:01');
INSERT INTO `sys_oper_log` VALUES (192, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1660470423000,\"updateTime\":1665278282477,\"id\":\"5968d94f9d2d78f383c9cb8ee0595756\",\"text\":\"好好好学习天天向上\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:02');
INSERT INTO `sys_oper_log` VALUES (193, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278283102,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:03');
INSERT INTO `sys_oper_log` VALUES (194, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278287783,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:07');
INSERT INTO `sys_oper_log` VALUES (195, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278290078,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:10');
INSERT INTO `sys_oper_log` VALUES (196, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173369000,\"updateTime\":1665278291534,\"id\":\"d03d1664f7f5ac853cb5b3a37770bbb6\",\"text\":\"买手机\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:11');
INSERT INTO `sys_oper_log` VALUES (197, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1664173369000,\"updateTime\":1665278292438,\"id\":\"d03d1664f7f5ac853cb5b3a37770bbb6\",\"text\":\"买手机\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:12');
INSERT INTO `sys_oper_log` VALUES (198, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278292982,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:13');
INSERT INTO `sys_oper_log` VALUES (199, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278295150,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:15');
INSERT INTO `sys_oper_log` VALUES (200, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278297318,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":false}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:17');
INSERT INTO `sys_oper_log` VALUES (201, '备忘录', 2, 'com.jzj.vblog.web.controller.admin.SysTodoController.edit()', 'PUT', 1, 'admin', NULL, '/sys/todo', '127.0.0.1', '内网IP', '{\"createTime\":1663743462000,\"updateTime\":1665278300078,\"id\":\"bd8fd2b4e71b1a4efa58e5f19b26cde9\",\"text\":\"明天写bug\",\"params\":{},\"done\":true}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 09:18:20');
INSERT INTO `sys_oper_log` VALUES (202, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Buffer）\",\"introduce\":\"Java网络编程-NIO（Buffer）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/08/ad90335701f84465b105d9548cc6f992.jpg\",\"sort\":0,\"content\":\"### 1 Buffer 简介\\nJava NIO 中的 Buffer 用于和 NIO 通道进行交互。数据是从通道读入缓冲区，从缓冲 区写入到通道中的。\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/ff63cf22b4fb456fa17b1bd67c58204d.png)\\n\\n:::\\n\\n缓冲区 ==本质上是一块可以写入数据，然后可以从中读取数据的内存== 。这块内存被包装 成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。缓冲区实际上是 一个容器对象，更直接的说，其实就是一个数组，==在 NIO 库中，所有数据都是用缓冲 区处理的== 。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到 缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流 I/O 系统中，所有数据都是直接写入或者直接将数据读取到 Stream 对象中。 在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer，最常用的就是 ByteBuffer， 对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应，它们之间的继 承关系如下图所示：\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/08/e77b8d6b861b430c9dec09ed3d4b54e3.png)\\n\\n:::\\n\\n### 2 Buffer 的基本用法\\n\\n使用 Buffer 读写数据，一般遵循以下四个步骤：\\n- 写入数据到 Buffer\\n- 调用 flip()方法\\n- 从 Buffer 中读取数据\\n- 调用 clear()方法或者 compact()方法\\n\\n\\n当向 buffer 写入数据时，buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip()方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 buffer 的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有 两种方式能清空缓冲区：调用 clear()或 compact()方法。clear()方法会清空整个缓冲 区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起 始处，新写入的数据将放到缓冲区未读数据的后面。\\n\\n使用 Buffer 的例子：\\n```java\\npublic class BufferDemo01 {\\n    @Test\\n    public void buffer01() throws Exception {\\n        //FileChannel\\n        RandomAccessFile aFile = new RandomAccessFile(\\\"d:\\\\\\\\111.txt\\\",\\\"rw\\\");\\n        FileChannel channel = aFile.getChannel();\\n        //创建buffer,大小\\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\\n        //读\\n        int bytesRead = channel.read(buffer);\\n        while (bytesRead != -1){\\n            //read模式\\n            buffer.flip();\\n            while (buffer.hasRemaining()){\\n                System.out.println((char)buffer.get());\\n            }\\n            buffer.clear();\\n            bytesRead = channel.', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 10:48:28');
INSERT INTO `sys_oper_log` VALUES (203, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/dd6766ece27b4fcf90dcd0a5167297d0.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 10:51:32');
INSERT INTO `sys_oper_log` VALUES (204, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/7ae9446e0bca4a518b305073e07475d0.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 10:52:17');
INSERT INTO `sys_oper_log` VALUES (205, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/4f68bfeb91434f1eb900f948f52e0dae.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 10:53:44');
INSERT INTO `sys_oper_log` VALUES (206, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Selector）\",\"introduce\":\"Java网络编程-NIO（Selector）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/dd6766ece27b4fcf90dcd0a5167297d0.jpg\",\"sort\":0,\"content\":\"### 1 Selector 简介\\n#### 1.1 Selector 和 Channel 关系\\nSelector 一般称 为选择器 ，也可以翻译为 多路复用器 。它是 Java NIO 核心组件中 的一个，用于检查一个或多个 NIO Channel（通道）的状态是否处于可读、可写。如 此可以实现单线程管理多个 channels,也就是可以管理多个网络链接。\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/7ae9446e0bca4a518b305073e07475d0.png)\\n\\n:::\\n\\n使用 Selector 的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个 线程，避免了线程上下文切换带来的开销。\\n\\n#### 1.2 可选择通道(SelectableChannel)\\n（1）不是所有的 Channel 都可以被 Selector 复用的。比方说，FileChannel 就不能 被选择器复用。判断一个 Channel 能被 Selector 复用，有一个前提：判断他是否继承了一个抽象类 SelectableChannel。如果继承了 SelectableChannel，则可以被复 用，否则不能。\\n\\n（2）SelectableChannel 类提供了实现通道的可选择性所需要的公共方法。它是所有 支持就绪检查的通道类的父类。所有 socket 通道，都继承了 SelectableChannel 类 都是可选择的，包括从管道(Pipe)对象的中获得的通道。而 FileChannel 类，没有继 承 SelectableChannel，因此是不是可选通道。\\n\\n（3）一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。通 道和选择器之间的关系，使用注册的方式完成。SelectableChannel 可以被注册到 Selector 对象上，在注册的时候，需要指定通道的哪些操作，是 Selector 感兴趣的。\\n\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/4f68bfeb91434f1eb900f948f52e0dae.png)\\n\\n:::\\n\\n#### 1.3 Channel 注册到 Selector\\n（1）使用 Channel.register（Selector sel，int ops）方法，将一个通道注册到一个 选择器时。第一个参数，指定通道要注册的选择器。第二个参数指定选择器需要查询 的通道操作。 \\n（2）可以供选择器查询的通道操作，从类型来分，包括以下四种：\\n- 可读 : SelectionKey.OP_READ\\n- 可写 : SelectionKey.OP_WRITE\\n- 连接 : SelectionKey.OP_CONNECT\\n- 接收 : SelectionKey.OP_ACCEPT\\n\\n如果 Selector 对通道的多操作类型感兴趣，可以用“位或”操作符来实现： 比如：int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE ;\\n\\n（3）选择器查询的不是通道的操作，而是通道的某个操作的一种就绪状态。什么是操 作的就绪状态？一旦通道具备完成某个操作的条件，表示该通道的某个操作已经就绪， 就可以被 Selector 查询到，程序可以对通道进行对应的操作。比方说，某个 SocketChannel 通道可以连接到一个服务器，则处于“连接就绪”(OP_CONNECT)。 再比方说，一个 ServerSocketChannel 服务器通道准备好接收新进入的连接，则处于 “接收就绪”（OP_ACCEPT）状态。还比方说，一个有数据可读的通道，可以说是 “读就绪”(OP_READ)。一个等待写数据的通道可以说是“写就绪”(OP_WRITE)。\\n\\n#### 1.4 选择键(Sel', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 10:56:26');
INSERT INTO `sys_oper_log` VALUES (207, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Selector）\",\"introduce\":\"Java网络编程-NIO（Selector）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/dd6766ece27b4fcf90dcd0a5167297d0.jpg\",\"sort\":0,\"content\":\"### 1 Selector 简介\\n#### 1.1 Selector 和 Channel 关系\\nSelector 一般称 为选择器 ，也可以翻译为 多路复用器 。它是 Java NIO 核心组件中 的一个，用于检查一个或多个 NIO Channel（通道）的状态是否处于可读、可写。如 此可以实现单线程管理多个 channels,也就是可以管理多个网络链接。\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/7ae9446e0bca4a518b305073e07475d0.png)\\n\\n:::\\n\\n使用 Selector 的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个 线程，避免了线程上下文切换带来的开销。\\n\\n#### 1.2 可选择通道(SelectableChannel)\\n（1）不是所有的 Channel 都可以被 Selector 复用的。比方说，FileChannel 就不能 被选择器复用。判断一个 Channel 能被 Selector 复用，有一个前提：判断他是否继承了一个抽象类 SelectableChannel。如果继承了 SelectableChannel，则可以被复 用，否则不能。\\n\\n（2）SelectableChannel 类提供了实现通道的可选择性所需要的公共方法。它是所有 支持就绪检查的通道类的父类。所有 socket 通道，都继承了 SelectableChannel 类 都是可选择的，包括从管道(Pipe)对象的中获得的通道。而 FileChannel 类，没有继 承 SelectableChannel，因此是不是可选通道。\\n\\n（3）一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。通 道和选择器之间的关系，使用注册的方式完成。SelectableChannel 可以被注册到 Selector 对象上，在注册的时候，需要指定通道的哪些操作，是 Selector 感兴趣的。\\n\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/4f68bfeb91434f1eb900f948f52e0dae.png)\\n\\n:::\\n\\n#### 1.3 Channel 注册到 Selector\\n（1）使用 Channel.register（Selector sel，int ops）方法，将一个通道注册到一个 选择器时。第一个参数，指定通道要注册的选择器。第二个参数指定选择器需要查询 的通道操作。 \\n（2）可以供选择器查询的通道操作，从类型来分，包括以下四种：\\n- 可读 : SelectionKey.OP_READ\\n- 可写 : SelectionKey.OP_WRITE\\n- 连接 : SelectionKey.OP_CONNECT\\n- 接收 : SelectionKey.OP_ACCEPT\\n\\n如果 Selector 对通道的多操作类型感兴趣，可以用“位或”操作符来实现： 比如：int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE ;\\n\\n（3）选择器查询的不是通道的操作，而是通道的某个操作的一种就绪状态。什么是操 作的就绪状态？一旦通道具备完成某个操作的条件，表示该通道的某个操作已经就绪， 就可以被 Selector 查询到，程序可以对通道进行对应的操作。比方说，某个 SocketChannel 通道可以连接到一个服务器，则处于“连接就绪”(OP_CONNECT)。 再比方说，一个 ServerSocketChannel 服务器通道准备好接收新进入的连接，则处于 “接收就绪”（OP_ACCEPT）状态。还比方说，一个有数据可读的通道，可以说是 “读就绪”(OP_READ)。一个等待写数据的通道可以说是“写就绪”(OP_WRITE)。\\n\\n#### 1.4 选择键(Sel', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 15:59:37');
INSERT INTO `sys_oper_log` VALUES (208, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/e0f6fb09458242b08216b9cbeec18f1b.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 16:52:21');
INSERT INTO `sys_oper_log` VALUES (209, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"introduce\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/e0f6fb09458242b08216b9cbeec18f1b.jpg\",\"sort\":0,\"content\":\"\",\"commentStatus\":\"0\",\"htmlContent\":\"\",\"articleTag\":\"0,10\",\"aggregateId\":\"6af32c16a767b5a74dc711d8d688236f\",\"articleType\":\"0\",\"topStatus\":\"0\",\"originStatus\":\"1\",\"status\":\"1\"}', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 16:52:28');
INSERT INTO `sys_oper_log` VALUES (210, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/2f9b2e23b0414df2a415fbd52fca6338.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 16:52:57');
INSERT INTO `sys_oper_log` VALUES (211, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"introduce\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/e0f6fb09458242b08216b9cbeec18f1b.jpg\",\"sort\":0,\"content\":\"### 1 Pipe\\n\\nJava NIO 管道是 2 个线程之间的单向数据连接。Pipe 有一个 source 通道和一个 sink 通道。数据会被写到 sink 通道，从 source 通道读取。\\n\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/2f9b2e23b0414df2a415fbd52fca6338.png)\\n\\n:::\\n\\n#### 1.1 创建管道\\n通过 Pipe.open()方法打开管道。\\n```java\\nPipe pipe = Pipe.open();\\n```\\n\\n#### 1.2 写入管道\\n要向管道写数据，需要访问 sink 通道。：\\n```java\\nPipe.SinkChannel sinkChannel = pipe.sink();\\n```\\n\\n通过调用 SinkChannel 的 write()方法，将数据写入 SinkChannel：\\n```java\\nString newData = \\\"New String to write to file...\\\" + System.currentTimeMillis(); \\nByteBuffer buf = ByteBuffer.allocate(48); \\nbuf.clear(); buf.put(newData.getBytes()); \\nbuf.flip(); \\nwhile(buf.hasRemaining()) { \\nsinkChannel.write(buf); \\n}\\n```\\n\\n#### 1.3 从管道读取数据\\n从读取管道的数据，需要访问 source 通道，像这样：\\n```java\\nPipe.SourceChannel sourceChannel = pipe.source();\\n```\\n\\n调用 source 通道的 read()方法来读取数据：\\n```java\\nByteBuffer buf = ByteBuffer.allocate(48); \\nint bytesRead = sourceChannel.read(buf);\\n```\\nread()方法返回的 int 值会告诉我们多少字节被读进了缓冲区。\\n\\n#### 1.4 示例\\n```java\\npublic static void main(String[] args) throws Exception {\\n        //获取管道\\n        Pipe pipe = Pipe.open();\\n        //获取sink通道\\n        Pipe.SinkChannel sinkChannel = pipe.sink();\\n        //创建缓冲区\\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\\n        byteBuffer.put(\\\"Jzjzzzz\\\".getBytes(StandardCharsets.UTF_8));\\n        byteBuffer.flip();\\n        //写入数据\\n        sinkChannel.write(byteBuffer);\\n        //获取source通道\\n        Pipe.SourceChannel sourceChannel = pipe.source();\\n        //创建缓冲区,读取数据\\n        //ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\\n        byteBuffer.flip();\\n        int length = sourceChannel.read(byteBuffer);\\n        System.out.println(new String(byteBuffer.array(),0,leng', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 16:55:36');
INSERT INTO `sys_oper_log` VALUES (212, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"introduce\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/e0f6fb09458242b08216b9cbeec18f1b.jpg\",\"sort\":0,\"content\":\"### 1 Pipe\\n\\nJava NIO 管道是 2 个线程之间的单向数据连接。Pipe 有一个 source 通道和一个 sink 通道。数据会被写到 sink 通道，从 source 通道读取。\\n\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/2f9b2e23b0414df2a415fbd52fca6338.png)\\n\\n:::\\n\\n#### 1.1 创建管道\\n通过 Pipe.open()方法打开管道。\\n```java\\nPipe pipe = Pipe.open();\\n```\\n\\n#### 1.2 写入管道\\n要向管道写数据，需要访问 sink 通道。：\\n```java\\nPipe.SinkChannel sinkChannel = pipe.sink();\\n```\\n\\n通过调用 SinkChannel 的 write()方法，将数据写入 SinkChannel：\\n```java\\nString newData = \\\"New String to write to file...\\\" + System.currentTimeMillis(); \\nByteBuffer buf = ByteBuffer.allocate(48); \\nbuf.clear(); buf.put(newData.getBytes()); \\nbuf.flip(); \\nwhile(buf.hasRemaining()) { \\nsinkChannel.write(buf); \\n}\\n```\\n\\n#### 1.3 从管道读取数据\\n从读取管道的数据，需要访问 source 通道，像这样：\\n```java\\nPipe.SourceChannel sourceChannel = pipe.source();\\n```\\n\\n调用 source 通道的 read()方法来读取数据：\\n```java\\nByteBuffer buf = ByteBuffer.allocate(48); \\nint bytesRead = sourceChannel.read(buf);\\n```\\nread()方法返回的 int 值会告诉我们多少字节被读进了缓冲区。\\n\\n#### 1.4 示例\\n```java\\npublic static void main(String[] args) throws Exception {\\n        //获取管道\\n        Pipe pipe = Pipe.open();\\n        //获取sink通道\\n        Pipe.SinkChannel sinkChannel = pipe.sink();\\n        //创建缓冲区\\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\\n        byteBuffer.put(\\\"Jzjzzzz\\\".getBytes(StandardCharsets.UTF_8));\\n        byteBuffer.flip();\\n        //写入数据\\n        sinkChannel.write(byteBuffer);\\n        //获取source通道\\n        Pipe.SourceChannel sourceChannel = pipe.source();\\n        //创建缓冲区,读取数据\\n        //ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\\n        byteBuffer.flip();\\n        int length = sourceChannel.read(byteBuffer);\\n        System.out.println(new String(byteBuffer.array(),0,leng', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 17:05:32');
INSERT INTO `sys_oper_log` VALUES (213, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"introduce\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/e0f6fb09458242b08216b9cbeec18f1b.jpg\",\"sort\":0,\"content\":\"### 1 Pipe\\n\\nJava NIO 管道是 2 个线程之间的单向数据连接。Pipe 有一个 source 通道和一个 sink 通道。数据会被写到 sink 通道，从 source 通道读取。\\n\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/2f9b2e23b0414df2a415fbd52fca6338.png)\\n\\n:::\\n\\n#### 1.1 创建管道\\n通过 Pipe.open()方法打开管道。\\n```java\\nPipe pipe = Pipe.open();\\n```\\n\\n#### 1.2 写入管道\\n要向管道写数据，需要访问 sink 通道。：\\n```java\\nPipe.SinkChannel sinkChannel = pipe.sink();\\n```\\n\\n通过调用 SinkChannel 的 write()方法，将数据写入 SinkChannel：\\n```java\\nString newData = \\\"New String to write to file...\\\" + System.currentTimeMillis(); \\nByteBuffer buf = ByteBuffer.allocate(48); \\nbuf.clear(); buf.put(newData.getBytes()); \\nbuf.flip(); \\nwhile(buf.hasRemaining()) { \\nsinkChannel.write(buf); \\n}\\n```\\n\\n#### 1.3 从管道读取数据\\n从读取管道的数据，需要访问 source 通道，像这样：\\n```java\\nPipe.SourceChannel sourceChannel = pipe.source();\\n```\\n\\n调用 source 通道的 read()方法来读取数据：\\n```java\\nByteBuffer buf = ByteBuffer.allocate(48); \\nint bytesRead = sourceChannel.read(buf);\\n```\\nread()方法返回的 int 值会告诉我们多少字节被读进了缓冲区。\\n\\n#### 1.4 示例\\n```java\\npublic static void main(String[] args) throws Exception {\\n        //获取管道\\n        Pipe pipe = Pipe.open();\\n        //获取sink通道\\n        Pipe.SinkChannel sinkChannel = pipe.sink();\\n        //创建缓冲区\\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\\n        byteBuffer.put(\\\"Jzjzzzz\\\".getBytes(StandardCharsets.UTF_8));\\n        byteBuffer.flip();\\n        //写入数据\\n        sinkChannel.write(byteBuffer);\\n        //获取source通道\\n        Pipe.SourceChannel sourceChannel = pipe.source();\\n        //创建缓冲区,读取数据\\n        //ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\\n        byteBuffer.flip();\\n        int length = sourceChannel.read(byteBuffer);\\n        System.out.println(new String(byteBuffer.array(),0,leng', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 17:17:52');
INSERT INTO `sys_oper_log` VALUES (214, '文章管理', 2, 'com.jzj.vblog.web.controller.admin.ArticleInformController.updateById()', 'PUT', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"introduce\":\"Java网络编程-NIO（Pipe 和 FileLock）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/e0f6fb09458242b08216b9cbeec18f1b.jpg\",\"sort\":0,\"content\":\"### 1 Pipe\\n\\nJava NIO 管道是 2 个线程之间的单向数据连接。Pipe 有一个 source 通道和一个 sink 通道。数据会被写到 sink 通道，从 source 通道读取。\\n\\n::: hljs-center\\n\\n![image.png](https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/2f9b2e23b0414df2a415fbd52fca6338.png)\\n\\n:::\\n\\n#### 1.1 创建管道\\n通过 Pipe.open()方法打开管道。\\n```java\\nPipe pipe = Pipe.open();\\n```\\n\\n#### 1.2 写入管道\\n要向管道写数据，需要访问 sink 通道。：\\n```java\\nPipe.SinkChannel sinkChannel = pipe.sink();\\n```\\n\\n通过调用 SinkChannel 的 write()方法，将数据写入 SinkChannel：\\n```java\\nString newData = \\\"New String to write to file...\\\" + System.currentTimeMillis(); \\nByteBuffer buf = ByteBuffer.allocate(48); \\nbuf.clear(); buf.put(newData.getBytes()); \\nbuf.flip(); \\nwhile(buf.hasRemaining()) { \\nsinkChannel.write(buf); \\n}\\n```\\n\\n#### 1.3 从管道读取数据\\n从读取管道的数据，需要访问 source 通道，像这样：\\n```java\\nPipe.SourceChannel sourceChannel = pipe.source();\\n```\\n\\n调用 source 通道的 read()方法来读取数据：\\n```java\\nByteBuffer buf = ByteBuffer.allocate(48); \\nint bytesRead = sourceChannel.read(buf);\\n```\\nread()方法返回的 int 值会告诉我们多少字节被读进了缓冲区。\\n\\n#### 1.4 示例\\n```java\\npublic static void main(String[] args) throws Exception {\\n        //获取管道\\n        Pipe pipe = Pipe.open();\\n        //获取sink通道\\n        Pipe.SinkChannel sinkChannel = pipe.sink();\\n        //创建缓冲区\\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\\n        byteBuffer.put(\\\"Jzjzzzz\\\".getBytes(StandardCharsets.UTF_8));\\n        byteBuffer.flip();\\n        //写入数据\\n        sinkChannel.write(byteBuffer);\\n        //获取source通道\\n        Pipe.SourceChannel sourceChannel = pipe.source();\\n        //创建缓冲区,读取数据\\n        //ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\\n        byteBuffer.flip();\\n        int length = sourceChannel.read(byteBuffer);\\n        System.out.println(new String(byteBuffer.array(),0,leng', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 17:23:50');
INSERT INTO `sys_oper_log` VALUES (215, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '//api/upload/uploadImg', '127.0.0.1', '内网IP', 'articleLog', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/1671f73bdd3140f3a2cc646e948d98f0.jpg\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 17:24:22');
INSERT INTO `sys_oper_log` VALUES (216, '文件管理', 1, 'com.jzj.vblog.web.controller.UploadController.uploadImg()', 'POST', 1, 'admin', NULL, '/api/upload/uploadImg', '127.0.0.1', '内网IP', 'article', '{\"code\":20000,\"data\":{\"url\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/article/2022/10/09/99340617865d41659cbde12e476c8b64.png\"},\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 17:28:47');
INSERT INTO `sys_oper_log` VALUES (217, '文章管理', 1, 'com.jzj.vblog.web.controller.admin.ArticleInformController.add()', 'POST', 1, 'admin', NULL, '/article/inform', '127.0.0.1', '内网IP', '{\"articleTitle\":\"Java网络编程-NIO（其他）\",\"introduce\":\"Java网络编程-NIO（其他）\",\"logImg\":\"https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/articleLog/2022/10/09/1671f73bdd3140f3a2cc646e948d98f0.jpg\",\"sort\":0,\"content\":\"### 1 Path\\n#### 1.1 Path 简介\\nJava Path 接口是 Java NIO 更新的一部分，同 Java NIO 一起已经包括在 Java6 和 Java7 中。Java Path 接口是在 Java7 中添加到 Java NIO 的。Path 接口位于 java.nio.file 包中，所以 Path 接口的完全限定名称为 java.nio.file.Path。\\n\\nJava Path 实例表示文件系统中的路径。一个路径可以指向一个文件或一个目录。路径 可以是绝对路径，也可以是相对路径。绝对路径包含从文件系统的根目录到它指向的 文件或目录的完整路径。相对路径包含相对于其他路径的文件或目录的路径。\\n\\n在许多方面，java.nio.file.Path 接口类似于 java.io.File 类，但是有一些差别。不过， 在许多情况下，可以使用 Path 接口来替换 File 类的使用。\\n\\n#### 1.2 创建 Path 实例\\n\\n使用 java.nio.file.Path 实例必须创建一个 Path 实例。可以使用 Paths 类 (java.nio.file.Paths)中的静态方法 Paths.get()来创建路径实例。\\n\\n示例代码:\\n\\n```java\\npublic static void main(String[] args) {\\n        //创建Path实例\\n        Path path = Paths.get(\\\"d:\\\\\\\\111.txt\\\");\\n    }\\n```\\n上述代码，可以理解为，Paths.get()方法是 Path 实例的工厂方法。\\n\\n#### 1.3 创建绝对路径\\n\\n（1）创建绝对路径，通过调用 Paths.get()方法，给定绝对路径文件作为参数来完成。\\n\\n示例代码：\\n```java\\nPath path = Paths.get(\\\"d:\\\\\\\\atguigu\\\\\\\\001.txt\\\");\\n```\\n上述代码中，绝对路径是 d:\\\\atguigu\\\\001.txt。在 Java 字符串中， \\\\是一个转义字符， 需要编写\\\\\\\\，告诉 Java 编译器在字符串中写入一个\\\\字符。\\n\\n（2）如果在 Linux、MacOS 等操作字体上，上面的绝对路径可能如下:\\n\\n```java\\nPath path = Paths.get(\\\"/home/jakobjenkov/myfile.txt\\\");\\n```\\n\\n绝对路径现在为/home/jakobjenkov/myfile.txt.\\n\\n（3）如果在 Windows 机器上使用了从/开始的路径，那么路径将被解释为相对于当 前驱动器。\\n\\n#### 1.4 创建相对路径\\nJava NIO Path 类也可以用于处理相对路径。您可以使用 Paths.get(basePath, relativePath)方法创建一个相对路径。\\n\\n示例代码:\\n\\n```java\\n//代码 1 \\nPath projects = Paths.get(\\\"d:\\\\\\\\atguigu\\\", \\\"projects\\\"); \\n//代码 2 \\nPath file = Paths.get(\\\"d:\\\\\\\\atguigu\\\", \\\"projects\\\\\\\\002.txt\\\");\\n```\\n代码 1 创建了一个 Java Path 的实例，指向路径(目录):d:\\\\atguigu\\\\projects \\n代码 2 创建了一个 Path 的实例，指向路径(文件):d:\\\\atguigu\\\\projects\\\\002.txt\\n\\n#### 1.5 Path.normalize()\\nPath 接口的 normalize()方法可以使路径标准化。标准化意味着它将移除所有在路径 字符串的中间的.和..代码，并解析路径字符串所引用的路径。\\n\\nPath.normalize()示例:\\n```java\\nString originalPath = \\\"d:\\\\\\\\atguigu\\\\\\\\projects\\\\\\\\..\\\\\\\\yygh-project\\\"; \\nPath path1 = Paths.', '{\"code\":20000,\"msg\":\"操作成功\",\"success\":true}', 0, NULL, '2022-10-09 17:28:59');

-- ----------------------------
-- Table structure for sys_todo
-- ----------------------------
DROP TABLE IF EXISTS `sys_todo`;
CREATE TABLE `sys_todo`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT 'id',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `done` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '状态',
  `text` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '内容',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '备忘录' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_todo
-- ----------------------------
INSERT INTO `sys_todo` VALUES ('5968d94f9d2d78f383c9cb8ee0595756', '2022-08-14 17:47:03', '2022-10-09 09:18:02', '0', '好好好学习天天向上');
INSERT INTO `sys_todo` VALUES ('bd8fd2b4e71b1a4efa58e5f19b26cde9', '2022-09-21 14:57:42', '2022-10-09 09:18:20', '1', '明天写bug');
INSERT INTO `sys_todo` VALUES ('d03d1664f7f5ac853cb5b3a37770bbb6', '2022-09-26 14:22:49', '2022-10-09 09:18:12', '0', '买手机');

-- ----------------------------
-- Table structure for sys_web_information
-- ----------------------------
DROP TABLE IF EXISTS `sys_web_information`;
CREATE TABLE `sys_web_information`  (
  `id` int(11) NOT NULL COMMENT 'id',
  `web_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网站名称',
  `web_details` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网站详情',
  `web_avatar` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `qq` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'qq',
  `wechat` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '微信',
  `github` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'github',
  `gitee` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'gitee',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `home_banner` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '首页背景图',
  `article_banner` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章背景图',
  `wechat_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '微信二维码',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `comment_img` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论头像',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '网站基本信息' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_web_information
-- ----------------------------
INSERT INTO `sys_web_information` VALUES (1, '漫漫前路', '<p>长路漫漫，吾将上下而求索。</p>', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/09/16/de051c412f2f46ba92de7817496cb605.jpg', '946232976', 'fr946232976', 'https://github.com/Jzjzzzz', 'https://gitee.com/jzjzz', '2022-07-28 20:16:13', '2022-09-26 10:56:20', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/08/09/a108c42fa21a43a4940c3e08cfd33c4f.jpg', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/08/10/9d26abe18ec84eadbaa8b9f180fefee6.jpg', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/09/08/f2330c187a6040ed8a74df5aae1cb763.jpg', '946232976@qq.com', 'https://vue-vblog.oss-cn-shenzhen.aliyuncs.com/webLogo/2022/09/19/1b0d32a2d72e4ed58b7cc6ede72621b0.png');

-- ----------------------------
-- Table structure for website_resource
-- ----------------------------
DROP TABLE IF EXISTS `website_resource`;
CREATE TABLE `website_resource`  (
  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '资源站点表id',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '状态',
  `resource_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '资源名称',
  `resource_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '资源地址',
  `resource_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '资源图片',
  `resource_type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '资源分类',
  `click_rate` bigint(20) NOT NULL COMMENT '点击量',
  `resource_detail` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '资源描述',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '资源站点' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of website_resource
-- ----------------------------

SET FOREIGN_KEY_CHECKS = 1;
